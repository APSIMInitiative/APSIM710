<folder version="15" name="Developers">
  <ini>
    <filename>
    </filename>
  </ini>
  <broccoli />
  <lettuce />
  <potato />
  <tclui name="Rotation Management">
    <uiscript><![CDATA[
package req struct
package req tdom
trace remove variable XMLDoc read setXML

# Get the value of one of our parameters
proc getValue {id thing} {
   foreach node [$id childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         return [$node text]
      }
   }
   return ""
}

# Get the values of one of our parameters
proc getValues {id thing} {
   set result {}
   foreach node [$id childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         lappend result [$node text]
      }
   }
   return $result
}


# return the tag of an item near (x,y)
proc getTag {c x y} {
   set tag [lindex [$c find overlapping [expr $x-5] [expr $y-5] [expr $x+5] [expr $y+5]] end]
   if {[llength $tag] > 0} {
      foreach tag [$c gettags $tag] {
         if {$tag != "current"} {
             return $tag
         }
      }
   }
   return {}
}

# Select an object near (x,y)
proc select {w x y} {
   upvar #0 $w cfg
   if {$cfg(selected) != {}} {
      foreach {type name} [split $cfg(selected) :] {break}
      if {$type == "node"} {
          catch {$cfg(c) itemconf $cfg(selected) -outline black -width 1}
      } elseif {$type == "arc"} {
          catch {$cfg(c) itemconf $cfg(selected) -fill black -width 1}
      }
   }
   ## set x [$cfg(c) canvasx $x]; set y [$cfg(c) canvasy $y]
   set tag [getTag $cfg(c) $x $y]
   if {$tag != {}} {
      set cfg(selected) $tag
      set cfg(selectedX) $x
      set cfg(selectedY) $y
      foreach {type name} [split $tag :] {break}
      if {$type == "node"} {
        catch {$cfg(c) itemconf $tag -outline blue -width 3}
      } elseif {$type == "arc"} {
        catch {$cfg(c) itemconf $tag -fill blue -width 3}
      }
      showSelection $w $type $name
   } else {
      set cfg(selected) {}
      set cfg(selectedX) {}
      set cfg(selectedY) {}
      set cfg(message) "No items selected."
      showSelection $w help dummy
   }
}

# Move an already selected object
proc move {w x y} {
   upvar #0 $w cfg
   if {$cfg(selected) != {}} {
      set dx [expr {$x - $cfg(selectedX)}]
      set dy [expr {$y - $cfg(selectedY)}]
      set cfg(selectedX) $x
      set cfg(selectedY) $y
      foreach {type name} [split $cfg(selected) :] {break}
      if {$type == "node"} {
         $cfg(c) move $cfg(selected) $dx $dy
         foreach {x1 y1 x2 y2} [$cfg(c) coords $cfg(selected)] {}
         foreach what {x1 y1 x2 y2} {$cfg(g) node set $name $what [set $what]}
         foreach arc [$cfg(g) arcs -adj $name] {
             fixupArrow $w arc:$arc "node:[$cfg(g) arc source $arc]" "node:[$cfg(g) arc target $arc]"
         }
      } elseif {$type == "arc"} {
         set coords [$cfg(c) coords $cfg(selected)]
         set newx [expr $dx + [lindex $coords 2]]
         set newy [expr $dy + [lindex $coords 3]]
         $cfg(g) arc set $name x $newx
         $cfg(g) arc set $name y $newy
         fixupArrow $w $cfg(selected) "node:[$cfg(g) arc source $name]" "node:[$cfg(g) arc target $name]"
      }
   }
}


#Return a point on the edge of the node on a line to (x,y)
# NB. canvas origin at upper left corner
# Used to find arrow positions between nodes
proc findEdge {w x y node} {
   upvar #0 $w cfg
   set maxy [$w cget -height]

   # center of node
   set nc [$cfg(c) coords $node]
   set xn [expr ([lindex $nc 2] + [lindex $nc 0])/2.0]
   set yn [expr $maxy - ([lindex $nc 3] + [lindex $nc 1])/2.0]

   # angle of midline
   set a 0.0
   catch {set a [expr atan((($maxy-$y)-$yn)/($x-$xn))]}

   # Cheat - assume its always a circle and just take mid point of box
   set r [expr abs(([lindex $nc 2] - [lindex $nc 0])/2.0)]
   set dx [expr $x-$xn]
   set dy [expr ($maxy-$y)-$yn]
   if {$dx < 0} {
     set xe [expr $xn - $r * cos($a)]
     set ye [expr $yn - $r * sin($a)]
   } else {
     set xe [expr $xn + $r * cos($a)]
     set ye [expr $yn + $r * sin($a)]
   }
   return [list $xe [expr $maxy - $ye]]
}

# Set the arc coordinates between 2 nodes.
proc fixupArrow {w arc srcNode destNode} {
   upvar #0 $w cfg
   set arc [lindex [split $arc ":"] 1]
   set xm [$cfg(g) arc get $arc x]
   set ym [$cfg(g) arc get $arc y]

   set p0 [findEdge $w $xm $ym $srcNode]
   set p1 [findEdge $w $xm $ym $destNode]

   $cfg(c) coords arc:$arc [concat $p0 $xm $ym $p1]
   #set cfg(message) "$arc = '[$cfg(c) coords arc:$arc]'"
   #set cfg(message) "$arc = [concat $p0 $xm $ym $p1]"
}

# Right button click - post a context sensitive menu
proc action {w x y} {
   upvar #0 $w cfg
   set tag [getTag $cfg(c) $x $y]
   if {$cfg(selected) == {}} {
      postNewNodeMenu $w $x $y
   } elseif {$cfg(selected) != {} && "$tag" == $cfg(selected)} {
      postChangeMenu $w $tag $x $y
   } elseif {$cfg(selected) != {} && "$tag" != {} && "$tag" != $cfg(selected)} {
      postAddArcMenu $w $cfg(selected) $tag $x $y
   }
}

proc postNewNodeMenu {w x y} {
   upvar #0 $w cfg
   if {[winfo exists $cfg(c).newNodeMenu]} {destroy $cfg(c).newNodeMenu}
   menu $cfg(c).newNodeMenu -tearoff 0
   $cfg(c).newNodeMenu add command -label "Add New State" -command "addNewNode $w $x $y"
   tk_popup $cfg(c).newNodeMenu [expr [winfo rootx $cfg(c)]+$x] [expr [winfo rooty $cfg(c)]+$y]
}

proc addNewNode {w x y} {
   upvar #0 $w cfg
   set n 0; while {[$cfg(g) node exists n$n]} {incr n}; set n "n$n"
   $cfg(g) node insert $n
   $cfg(g) node set $n x1 [set x1 [expr $x-50]]
   $cfg(g) node set $n y1 [set y1 [expr $y-50]]
   $cfg(g) node set $n x2 [set x2 [expr $x+50]]
   $cfg(g) node set $n y2 [set y2 [expr $y+50]]
   $cfg(g) node set $n fill brown
   $cfg(g) node set $n name $n
   $cfg(g) node set $n desc  "New state"
   $cfg(g) node set $n alias "newnode"

   $cfg(c) create oval $x1 $y1 $x2 $y2 -fill brown -tags node:$n
   set mx($n) [expr ($x1 + $x2) / 2.0]; set my($n) [expr ($y1 + $y2) / 2.0]
   $cfg(c) create text $mx($n) $my($n) -text "$n" -anchor center -tags node:$n

   select $w $x $y
}

proc deleteNode {w tag} {
   upvar #0 $w cfg
   set node [lindex [split $tag :] 1]
   foreach arcTag [$cfg(g) arcs -adj $node] {
      $cfg(c) delete arc:$arcTag
   }
   $cfg(c) delete $tag
   $cfg(g) node delete $node
   set cfg(selected) {}
   select $w 0 0
}

proc postAddArcMenu {w srcTag destTag x y} {
   upvar #0 $w cfg
   catch {destroy $cfg(c).addArcMenu}
   menu $cfg(c).addArcMenu -tearoff 0
   set srcName [lindex [split $srcTag :] 1]; set destName [lindex [split $destTag :] 1]

   if {![catch {set src [$cfg(g) node get $srcName name]; set dest [$cfg(g) node get $destName name]}]} {
      $cfg(c).addArcMenu add command \
          -label "Add arc from $src to $dest" \
          -command "addNewArc $w $srcTag $destTag"
      tk_popup $cfg(c).addArcMenu [expr [winfo rootx $cfg(c)]+$x] [expr [winfo rooty $cfg(c)]+$y]
   }
}

proc addNewArc {w srcTag destTag} {
   upvar #0 $w cfg
   set n 0; while {[$cfg(g) arc exists arc$n]} {incr n}
   set arc "arc$n"
   set c1 [$cfg(c) coords $srcTag]
   set x1 [expr ([lindex $c1 0] + [lindex $c1 2])/2]
   set y1 [expr ([lindex $c1 1] + [lindex $c1 3])/2]
   set c2 [$cfg(c) coords $destTag]
   set x2 [expr ([lindex $c2 0] + [lindex $c2 2])/2]
   set y2 [expr ([lindex $c2 1] + [lindex $c2 3])/2]
   set mx [expr ($x1 + $x2) / 2.0]; set my [expr ($y1 + $y2) / 2.0]
   $cfg(c) create line $x1 $y1 $mx $my $x2 $y2 -smooth bezier -tags arc:$arc -arrow last -arrowshape {15 25 10}

   $cfg(g) arc insert [lindex [split $srcTag :] 1] [lindex [split $destTag :] 1] $arc
   $cfg(g) arc lappend $arc rules   {}
   $cfg(g) arc lappend $arc actions {}
   $cfg(g) arc set $arc x $mx
   $cfg(g) arc set $arc y $my
}

proc deleteArc {w tag} {
   upvar #0 $w cfg
   $cfg(c) delete $tag
   $cfg(g) arc delete [lindex [split $tag :] 1]
}

proc postChangeMenu {w tag x y} {
   upvar #0 $w cfg
   set isNode [string match "node*" $tag]
   catch {destroy $cfg(c).postChangeMenu}
   menu $cfg(c).postChangeMenu -tearoff 0
   if {$isNode} {
      $cfg(c).postChangeMenu add command -label "Delete" -command "deleteNode $w $tag"
   } else {
      $cfg(c).postChangeMenu add command -label "Delete" -command "deleteArc $w $tag"
   }
   tk_popup $cfg(c).postChangeMenu  [expr [winfo rootx $cfg(c)]+$x] [expr [winfo rooty $cfg(c)]+$y]
}

# Create the UI for the current object and fill it out
proc showSelection {w type name} {
   upvar #0 $w cfg
   if {"$cfg(s)" != "$w.$type"} { setup_$type $w $name}
   show_$type $w
}

proc setup_help {w junk} {
   upvar #0 $w cfg
   catch {destroy $cfg(s)}
   set f [set cfg(s) [text $w.help -width 70 -height 10]]
   $f insert end {<left-click>: select a node or arc.
<right-click>:  shows a context-sensitive  menu.

Once a node/arc is selected, it can be dragged to a new position.

Nodes are created by right-clicking on a blank area.

Arcs are created by firstly selecting a source node, then right-
clicking over a target node.
}
   grid $f -row 3 -column 1 -sticky ew
}
proc show_help {w} {}

# UI for node editing
proc setup_node {w name} {
   upvar #0 $w cfg
   catch {destroy $cfg(s)}
   set f [set cfg(s) [frame $w.node]]
   label $f.l1 -text "Name"
   entry $f.e1 -textvariable $w\(name\) -width 12 -validate key -vcmd {string is wordchar %P}
   label $f.l2 -text "Alias"
   entry $f.e2 -textvariable $w\(alias\) -width 12 -validate key -vcmd {string is wordchar %P}
   label $f.l3 -text "Description"
   entry $f.e3 -textvariable $w\(desc\) -width 40
   label $f.l4 -text "Colour"
   entry $f.e4 -textvariable $w\(fill\) -width 12

   frame $f.b
   button $f.b.apply -text Apply -command "set_node $w" -state disabled
   button $f.b.revert -text Revert -command "show_node $w" -state disabled
   set cfg(buttons) [list $f.b.apply $f.b.revert]
   foreach e [list $f.e1 $f.e2 $f.e3 $f.e4] {
      bind $e  <Any-KeyRelease> "+armButtons $w"
      bind $e  <Key-Return> "+set_node $w"
   }

   grid $f.l1 -row 1 -column 1 -sticky w
   grid $f.e1 -row 1 -column 2 -sticky w
   grid $f.l2 -row 2 -column 1 -sticky w
   grid $f.e2 -row 2 -column 2 -sticky w
   grid $f.l3 -row 3 -column 1 -sticky w
   grid $f.e3 -row 3 -column 2 -sticky ew
   grid $f.l4 -row 4 -column 1 -sticky w
   grid $f.e4 -row 4 -column 2 -sticky w
   grid $f.b.apply -row 1 -column 1 -sticky w -padx 20
   grid $f.b.revert -row 1 -column 2 -sticky w -padx 20
   grid $f.b -row 5 -column 1 -sticky ew
   grid $f -row 3 -column 1 -sticky ew
}

proc show_node {w} {
   upvar #0 $w cfg
   set node [lindex [split $cfg(selected) :] 1]
   set cfg(name) [$cfg(g) node get $node name]
   set cfg(alias) [$cfg(g) node get $node alias]
   set cfg(desc) [$cfg(g) node get $node desc]
   set cfg(fill) [$cfg(g) node get $node fill]

   set cfg(message) "State $cfg(name)"
   disarmButtons $w
}

proc set_node {w} {
   upvar #0 $w cfg
   set node [lindex [split $cfg(selected) :] 1]

   # Make the node name unique: append a "_1", "_2" etc.. if needed.
   set candidate $cfg(name); set found 1
   while {$found} {
      set found 0
      foreach otherNode [$cfg(g) nodes] {
         if {"$node" != "$otherNode" &&
             [string equal [$cfg(g) node get $otherNode name] $candidate]} {
            set found 1
         }
      }
      if {$found} {
         set num [lindex [split $candidate "_"] end]
         if {! [string is integer -strict $num]} {
           set candidate "${candidate}_1"
         } else {
           set root [join [lrange [split $candidate "_"] 0 end-1] "_"]
           set candidate "${root}_[expr 1+$num]"
         }
      }
   }

   $cfg(g) node set $node name [set cfg(name) $candidate]
   $cfg(g) node set $node alias $cfg(alias)
   $cfg(g) node set $node desc $cfg(desc)
   $cfg(g) node set $node fill $cfg(fill)
   foreach id [$cfg(c) find withtag node:$node] {
     if {[$cfg(c) type $id] == "text"}  {$cfg(c) itemconf $id -text $cfg(name)}
     if {[$cfg(c) type $id] == "oval"}  {$cfg(c) itemconf $id -fill $cfg(fill)}
   }
   disarmButtons $w
}

proc setup_arc {w name} {
   upvar #0 $w cfg
   catch {destroy $cfg(s)}
   set f [set cfg(s) [frame $w.arc]]
   label $f.l1 -text "Rules"
   set cfg(rulesW) [text $f.rules -height 4 -wrap none  -yscrollcommand "$f.rsbar set"]
   scrollbar $f.rsbar -orient vertical -command "$f.rules yview"
   label $f.l2 -text "Actions"
   set cfg(actionsW) [text $f.actions -height 3 -wrap none  -yscrollcommand "$f.asbar set"]
   scrollbar $f.asbar -orient vertical -command "$f.actions yview"

   frame $f.b
   button $f.b.apply -text Apply -command "set_arc $w" -state disabled
   button $f.b.revert -text Revert -command "show_arc $w" -state disabled
   set cfg(buttons) [list $f.b.apply $f.b.revert]

   foreach t [list $cfg(actionsW) $cfg(rulesW)] {
      bind $t  <Any-KeyRelease>  "+armButtons $w "
   }
   grid $f.l1 -row 1 -column 1 -sticky w
   grid $f.rules -row 2 -column 1 -sticky ew
   grid $f.rsbar -row 2 -column 2 -sticky w
   grid $f.l2 -row 3 -column 1 -sticky w
   grid $f.actions -row 4 -column 1 -sticky ew
   grid $f.asbar -row 3 -column 2 -sticky w -rowspan 2
   grid $f.b.apply -row 1 -column 1 -sticky w -padx 20
   grid $f.b.revert -row 1 -column 2 -sticky w -padx 20
   grid $f.b -row 5 -column 1 -sticky ew

   grid $f -row 3 -column 1 -sticky ew
}
proc show_arc {w} {
   upvar #0 $w cfg
   set arc [lindex [split $cfg(selected) :] 1]

   $cfg(rulesW) delete 0.0 end
   foreach rule [$cfg(g) arc get $arc rules] {
      $cfg(rulesW) insert end "$rule\n"
   }
   $cfg(actionsW) delete 0.0 end
   foreach action [$cfg(g) arc get $arc actions] {
      $cfg(actionsW) insert end "$action\n"
   }
   set src [$cfg(g) node get [$cfg(g) arc source $arc] name]
   set dest [$cfg(g) node get [$cfg(g) arc target $arc] name]
   set cfg(message) "Transition from $src to $dest"
   disarmButtons $w
}

proc set_arc {w} {
   upvar #0 $w cfg
   set arc [lindex [split $cfg(selected) :] 1]

   $cfg(g) arc set $arc rules {}
   foreach rule [split [$cfg(rulesW) get 0.0 end] "\n"] {
      if {$rule != {}} {$cfg(g) arc lappend $arc rules $rule}
   }
   $cfg(g) arc set $arc actions {}
   foreach action [split [$cfg(actionsW) get 0.0 end] "\n"] {
      $cfg(g) arc lappend $arc actions $action
   }
   disarmButtons $w
}

proc disarmButtons {w} {
   upvar #0 $w cfg
   foreach b $cfg(buttons) { $b config -state disabled }
}
proc armButtons {w} {
   upvar #0 $w cfg
   foreach b $cfg(buttons) { $b config -state active }
}

# Save the graph to an XML tree. Makes both our node/ arc  objects, and an invisible rule
# for the manager.
proc saveGraph {w} {
   upvar #0 $w cfg

   if {!$cfg(setupOk)} {error "Initialisation failed - Not saving"}

   set x "<tclui name=\"[$cfg(docroot) getAttribute name]\">\n"
   append x "<uiscript><!\[CDATA\[[getValue $cfg(docroot) uiscript]\]\]></uiscript>\n"
   set rule "<rule name=\"Init rule\" invisible=\"yes\" condition=\"init\">\n"
   append rule "<!\[CDATA\[package require struct\n"
   append rule "::struct::graph stateGraph\n"

   foreach node [$cfg(g) nodes] {
      append x "<node>\n"
      foreach key [$cfg(g) node keys $node] {
         set value [$cfg(g) node get $node $key]
         append x " <$key>$value</$key>\n"
      }
      append x "</node>\n"
      append rule "stateGraph node insert \"[$cfg(g) node get $node name]\"\n"
      append rule "set alias([$cfg(g) node get $node name]) \"[$cfg(g) node get $node alias]\"\n"
      append rule "set colour([$cfg(g) node get $node name]) \"[$cfg(g) node get $node fill]\"\n"
   }
   foreach arc [$cfg(g) arcs] {
      append x "<arc><name>$arc</name>\n"
      set sourceNodeName [$cfg(g) node get [$cfg(g) arc source $arc] name]
      append x " <source>$sourceNodeName</source>\n"
      set targetNodeName [$cfg(g) node get [$cfg(g) arc target $arc] name]
      append x " <target>$targetNodeName</target>\n"
      append rule "stateGraph arc insert \"$sourceNodeName\" \"$targetNodeName\" \"$arc\"\n"

      foreach {key value} [$cfg(g) arc getall $arc] {
         if {$key != "rules" && $key != "actions"} {
            append x " <$key>$value</$key>\n"
         } else {
            foreach thing [$cfg(g) arc get $arc $key] {
               append rule "stateGraph arc lappend \"$arc\" $key \{$thing\}\n"
               set thing [string map {\< "&lt;"  \> "&gt;"
                                      \& "&amp;" \" "&quot;"
                                      \[ "&#91;" \] "&#93;"} $thing]
               append x " <$key>$thing</$key>\n"
            }
         }
      }
      append x "</arc>\n"
   }

   append x "$rule\]\]></rule>\n"
   append x "</tclui>\n"

   return $x
}

# Read the graph from an XML tree
proc openGraph {w} {
   upvar #0 $w cfg
   catch {$cfg(g) destroy}
   catch {g destroy}

   set errorsFound 0

   global XMLDoc
   set cfg(doc) [dom parse $XMLDoc]
   set cfg(docroot) [$cfg(doc) documentElement]

   set cfg(g) [::struct::graph g]
   foreach node [$cfg(docroot) selectNodes //node] {
      $cfg(g) node insert [set nodeName [getValue $node name]]
      $cfg(g) node set $nodeName name $nodeName
      foreach {what default} {x1 100 x2 200 y1 100 y2 200 fill purple desc "No description" alias zzz} {
         if {[set value [getValue $node $what]] == ""} {
            $cfg(g) node set $nodeName $what $default
         } else {
            $cfg(g) node set $nodeName $what $value
         }
      }
   }

   foreach arc [$cfg(docroot) selectNodes //arc] {
      set arcName [getValue $arc name]
      set sourceNode [getValue $arc source]
      set targetNode [getValue $arc target]
      if {[$cfg(g) node exists $sourceNode] && [$cfg(g) node exists $targetNode]} {
         $cfg(g) arc insert $sourceNode $targetNode $arcName
         foreach {what default} {x 300 y 300} {
            if {[set value [getValue $arc $what]] == ""} {
                $cfg(g) arc set $arcName $what $default
            } elseif {$what != "name"} {
                $cfg(g) arc set $arcName $what $value
            }
         }
         foreach {what} {rules actions} {
            foreach value [getValues $arc $what] {
               set value [string map {"&lt;"  \<  "&gt;" \>
                                      "&amp;" \&  "&quot;"  \"
                                      "&#91;" \[  "&#93;" \] } $value]

               $cfg(g) arc lappend $arcName $what $value
            }
         }
      } else {
         tk_messageBox -title "Whoops!!" -message "source ($sourceNode) and/or target ($targetNode) is missing??" -type ok
         set errorsFound 1
      }
   }
   set cfg(setupOk) [expr ! $errorsFound]
}

# Create a graph on a canvas
proc createGraph {w} {
   upvar #0 $w cfg
   foreach id [$cfg(c) find all] {$cfg(c) delete $id}
   foreach n [$cfg(g) nodes] {
      foreach what {x1 y1 x2 y2 name fill} {set $what [$cfg(g) node get $n $what]}
      $cfg(c) create oval $x1 $y1 $x2 $y2 -fill $fill -tags node:$n
      set mx($n) [expr ($x1 + $x2) / 2.0]; set my($n) [expr ($y1 + $y2) / 2.0]
      $cfg(c) create text $mx($n) $my($n) -text $name -anchor center -tags node:$n
   }

   foreach a [$cfg(g) arcs] {
      set n1 [$cfg(g) arc source $a]
      set n2 [$cfg(g) arc target $a]
      $cfg(c) create line 0 0 0 0 -smooth bezier -tags arc:$a -arrow last -arrowshape {15 25 10}
      fixupArrow $w arc:$a "node:$n1" "node:$n2"
   }

   bind $cfg(c) <Button-1>  "+select $w %x %y"
   bind $cfg(c) <B1-Motion> "+move $w %x %y"
   bind $cfg(c) <Button-3>  "+action $w %x %y"
   set cfg(selected) {}
   showSelection $w help dummy
}

##############################
catch {unset .w}
catch {destroy .w}

set .w(g) {}
set .w(c) .w.c
set .w(s) {}
set .w(setupOk) 0

if {[catch {openGraph .w}]} {tk_messageBox -title "openGraph" -message "$errorInfo" -type ok}

frame .w
canvas .w.c
label .w.m -width 40 -textvariable .w(message) -anchor w

if {[catch {createGraph .w}]} {tk_messageBox -title "createGraph" -message "$errorInfo" -type ok}

grid forget .
grid .w.c -row 1 -column 1 -sticky nsew
grid .w.m -row 2 -column 1 -sticky ew
grid .w -row 1 -column 1   -sticky nsew

grid columnconf .w 1 -weight 1
grid rowconf    .w 1 -weight 1
grid columnconf . 1 -weight 1
grid rowconf    . 1 -weight 1

trace add variable XMLDoc read setXML
proc setXML {name1 name2 op} {
   if {[catch {set newXML [saveGraph .w]}]} {
      global errorInfo
      tk_messageBox -title "Error - not saved" -message $errorInfo -type ok
   }  else {
      global XMLDoc
      set XMLDoc $newXML
   }
}
]]></uiscript>
    <rule name="Init rule" invisible="yes" condition="init"><![CDATA[package require struct
::struct::graph stateGraph
]]></rule>
  </tclui>
  <tclui name="Rotation Rug Plot">
    <uiscript>
# Displays a rug plot of crop rotations

trace remove variable XMLDoc read setXML
package req tdom

# Get the value of one of our parameters
proc getValue {id thing} {
   foreach node [$id childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         return [$node text]
      }
   }
   return ""
}

# Set the value of our 'thing'
proc setValue {w thing what} {
   upvar #0 $w data
   foreach node [$data(docroot) childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         $data(docroot) removeChild $node
      }
   }
   set node [$data(doc) createElement $thing]
   $node appendChild [$data(doc) createTextNode $what]
   $data(docroot) appendChild $node
}

proc appletInit {w} {
   upvar #0 $w data
   global XMLDoc
   set data(doc) [dom parse $XMLDoc]
   set data(docroot) [$data(doc) documentElement]
   set data(filename) [getValue $data(docroot) filename]
}

# Read in the logfile
proc readIn {w} {
   upvar #0 $w data

   if {![file exists $data(filename)]} { set data(message) "$data(filename) does not exist."; return 0}

   set data(message) "Reading."; update

   set fp [open $data(filename) r]
   set data(finishedOK) 0
   set data(crops) {fallow}
   set date "X"
   while {[gets $fp line] &gt; 0} {
      if {[scan $line "%d,%d" day year]} {
         set date $line
         set data(latest) $date
      } elseif {[string match "Starting*" $line]} {
         set date [lindex $line 1]
         set data(earliest) $date; set data(latest) $date
      } elseif {[string match "paddocks*" $line]} {
         set data(paddocks) [join [lindex [split $line =] 1]]
         foreach paddock $data(paddocks) {
            set data($paddock,timeline) [list [list $data(earliest) fallow]]
         }
      } elseif {[string match "Finished*" $line]} {
         set data(finishedOK) 1
      } elseif {[string match colour* $line]} {
         set state [lindex $line 1]
         set data(colours,$state) [lindex $line 2]
      } elseif {[string match changeState* $line]} {
         set paddock [lindex $line 1]
         set state [lindex $line 2]
         lappend data($paddock,timeline) [list $date $state]
         if {[lsearch $data(crops) $state] &lt; 0} {lappend data(crops) $state}
         append data(text,$date) "$line\n"
      } else {
         append data(text,$date) "$line\n"
      }
   }
   close $fp
   if {![info exists data(earliest)]} {set data(message) "No 'Starting' tag found - is this really a logfile??"; return 0}
   if {$data(finishedOK) == 0} {set data(message) "No 'Finished' tag found - did the run crash??";return 0}

   foreach paddock $data(paddocks) {
      lappend data($paddock,timeline) [list $data(latest) end]
   }

   set message "Finished Reading."; update
   return 1
}

proc setupUI {w} {
   upvar #0 $w data

   panedwindow $w.p

   # Filename selector
   frame $w.f
   label $w.f.l -text "Filename"
   entry $w.f.e -textvariable $w\(filename\) -width 80
   button $w.f.b -text Browse -command "browseFilename $w"
   grid $w.f.l  -row 1 -column 1 -sticky w
   grid $w.f.e  -row 1 -column 2 -sticky ew
   grid $w.f.b  -row 1 -column 3 -sticky w
   grid columnconf $w.f 1 -weight 1

   # The rugplot canvas
   set data(canvas) [canvas $w.p.c]

   # Scrollable text window
   frame $w.p.t
   set data(text) [text $w.p.t.t -takefocus 0 -font "normal 14" -yscrollcommand "$w.p.t.sb set"]
   scrollbar $w.p.t.sb -orient v -command "$w.p.t.t yview"
   grid $w.p.t.t  -row 1 -column 1 -sticky nsew
   grid $w.p.t.sb -row 1 -column 2 -sticky nsw
   grid columnconf $w.p.t 1 -weight 1
   grid rowconf $w.p.t 1 -weight 1

   message $w.m  -textvariable $w\(message\) -aspect 1000 -anchor w

   $w.p add $w.p.c -sticky nsew
   $w.p add $w.p.t -sticky new

   grid $w.f  -row 1 -column 1 -sticky w
   grid $w.p  -row 2 -column 1 -sticky nsew
   grid $w.m  -row 3 -column 1  -sticky ew

   bind $w.p.c &lt;Motion&gt; "catch \"canvasMotion $w %x %y\""
   bind $w.p.c &lt;Button-1&gt;      "+focus %W; catch \"canvasButton $w %x %y\""
   bind $w.p.c &lt;Key-Up&gt;     "+catch \"canvasUp $w\""
   bind $w.p.c &lt;Key-Down&gt;   "+catch \"canvasDown $w\""
   bind $w.p.c &lt;Key-Left&gt;   "+catch \"canvasLeft $w\""
   bind $w.p.c &lt;Key-Right&gt;  "+catch \"canvasRight $w\""

   bind $w.p.c &lt;Configure&gt;  "+catch \"draw $w\""

   grid columnconf $w 1 -weight 1
   grid rowconf    $w 2 -weight 1
   focus $w.p.c
   return 1
}

proc browseFilename {w} {
   set types {
       {{Log Files}  .log }
       {{All Files} * }
   }
   set newFile [tk_getOpenFile -filetypes $types -multiple 0 -title "Choose log file"]
   if {$newFile != ""} {
      upvar #0 $w data
      set data(filename) $newFile
      setValue $w filename $newFile
      if {[readIn $w]} {draw $w}
   }
}

proc min {a b} { return [expr ($a &lt; $b) ? $a : $b] }
proc max {a b} { return [expr ($a &gt; $b) ? $a : $b] }

# Coordinate transforms
proc ctowx {w cx} {
   upvar #0 $w data
   set colwidth [expr ($data(width)-$data(xMargin))/[llength $data(paddocks)]]
   return [max [expr ($cx-$data(xMargin))/$colwidth] 0]
}
proc wtocx {w wx} {
   upvar #0 $w data
   set colwidth [expr ($data(width)-$data(xMargin))/[llength $data(paddocks)]]
   return [expr $data(xMargin) + $wx * $colwidth]
}
proc wtocy {w wy} {
   upvar #0 $w data
   return [expr 20 + ([date2num $wy]+$data(offsetY))*$data(scaleFactY) ]
}
proc ctowy {w cy} {
   upvar #0 $w data
   return [expr (($cy-20)/$data(scaleFactY))-$data(offsetY) ]
}
proc date2num {d} {
   set z [split $d ","]
   return [expr [lindex $z 1]+ [lindex $z 0]/365.0]
}
proc num2date {n} {
   set y [expr int($n)]
   set d [min 366 [max [expr int(($n-$y)*365.0)] 1]]
   return "$d,$y"
}

# Canvas bindings - mouse and keys
proc canvasMotion {w x y} {
   upvar #0 $w data
   set time [split [num2date [ctowy $w $y]] ","]
   set dstr ""
   catch {
     set dstr [clock format [clock scan "1/1/[lindex $time 1] + [expr [lindex $time 0]-1] days"] -format "%d-%b-%Y"]
   }
   set paddockName [lindex $data(paddocks) [ctowx $w $x]]
   set data(message) "$paddockName ; date=$dstr"
   update
}
proc canvasButton {w x y} {
   upvar #0 $w data
   set data(currTime) [num2date [ctowy $w $y]]
   set data(currPaddock) [lindex $data(paddocks) [ctowx $w $x]]
   showText $w
}
proc canvasUp {w} {
   upvar #0 $w data
   foreach {day year} [split $data(currTime) ","] {break}
   set day [expr $day-1]
   if {$day &lt;= 0} {set day 366; set year [expr $year-1]}
   set data(currTime) "$day,$year"
   showText $w
}
proc canvasDown {w} {
   upvar #0 $w data
   foreach {day year} [split $data(currTime) ","] {break}
   set day [expr $day+1]
   if {$day &gt; 366} {set day 1; set year [expr $year+1]}
   set data(currTime) "$day,$year"
   showText $w
}
proc canvasLeft {w} {
   upvar #0 $w data
   set paddock [lsearch $data(paddocks) $data(currPaddock)]
   set paddock [expr $paddock-1]
   if {$paddock &lt; 0} {set paddock [expr [llength $data(paddocks)]-1]}
   set data(currPaddock) [lindex $data(paddocks) $paddock]
   showText $w
}
proc canvasRight {w} {
   upvar #0 $w data
   set paddock [lsearch $data(paddocks) $data(currPaddock)]
   set paddock [expr $paddock+1]
   if {$paddock &gt; [expr [llength $data(paddocks)]-1]} {set paddock 0}
   set data(currPaddock) [lindex $data(paddocks) $paddock]
   showText $w
}

# Display the current ruleset in the text window
proc showText {w} {
   upvar #0 $w data
   set stime [split $data(currTime) ","]
   set year [lindex $stime 1]; set day [max [expr [lindex $stime 0]-1] 0]

   set dstr [clock format [clock scan "1/1/$year + $day days"] -format "%d-%b-%Y"]
   $data(text) delete 0.0 end
   $data(text) insert end "$dstr ($data(currTime))\n"
   if {[info exists data(text,$data(currTime))]} {
      $data(text) insert end $data(text,$data(currTime))
   }

   set paddock [lsearch $data(paddocks) $data(currPaddock)]
   $data(canvas) coords currPos [wtocx $w 0] [wtocy $w $data(currTime)] [wtocx $w [llength $data(paddocks)]] [wtocy $w $data(currTime)]
}

# Draw the paddock history
proc draw {w} {
   upvar #0 $w data

   $data(canvas) delete all

   set data(height) [winfo height $data(canvas)]
   set data(width)  [winfo width $data(canvas)]
   set data(xMargin) 60

   set t0 [date2num $data(earliest)]
   set t1 [date2num $data(latest)]
   set data(scaleFactY) [expr ($data(height)-20)/($t1 - $t0)]
   set data(offsetY) [expr - $t0]

   # boxes
   set column 0
   foreach paddock $data(paddocks) {
      for {set i 1} {$i &lt; [llength $data($paddock,timeline)]} {incr i} {
         set t0 [lindex [lindex $data($paddock,timeline) [expr $i-1]] 0]
         set t1 [lindex [lindex $data($paddock,timeline)       $i   ] 0]
         set what [lindex [lindex $data($paddock,timeline) [expr $i-1]] 1]
         if {[info exists data(colours,$what)]} {set colour $data(colours,$what)} else {set colour white}
         $data(canvas) create rect [wtocx $w $column] [wtocy $w $t0] [wtocx $w [expr $column+1]] [wtocy $w $t1] -fill $colour -outline {}
      }
      incr column
   }
   # text
   set column 0
   foreach paddock $data(paddocks) {
      for {set i 1} {$i &lt; [llength $data($paddock,timeline)]} {incr i} {
         set t0 [lindex [lindex $data($paddock,timeline) [expr $i-1]] 0]
         set t1 [lindex [lindex $data($paddock,timeline)       $i   ] 0]
         set what [lindex [lindex $data($paddock,timeline) [expr $i-1]] 1]
         $data(canvas) create text [expr 5 + [wtocx $w $column]] [wtocy $w $t0] -text $what -anchor nw
      }
      incr column
   }
   # column boundaries
   for {set col 0} {$col &lt; [llength $data(paddocks)]} {incr col} {
      $data(canvas) create line [wtocx $w $col] [wtocy $w $data(earliest)] [wtocx $w $col] [wtocy $w $data(latest)] -fill lightgray
   }
   # year boundaries
   for {set y [lindex [split $data(earliest) ","] 1]} {$y &lt;= [lindex [split $data(latest) ","] 1]} {incr y} {
      $data(canvas) create line [wtocx $w 0] [wtocy $w "1,$y"] [wtocx $w [llength $data(paddocks)]] [wtocy $w "1,$y"] -fill lightgray
      $data(canvas) create text 5 [wtocy $w "1,$y"] -text "1/1/$y" -anchor w
   }
   # top margin text
   set y [wtocy $w $data(earliest)]
   for {set x 0} {$x &lt; [llength $data(paddocks)]} {incr x} {
      $data(canvas) create text [expr 20 + [wtocx $w $x]] $y -text "[lindex $data(paddocks) $x]" -anchor sw
   }
   #Current position
   $data(canvas) create line [wtocx $w 0] [wtocy $w $data(earliest)] [wtocx $w 1] [wtocy $w $data(earliest)] -fill white -tag currPos
   set data(message) "Finished Drawing. ($data(width)x$data(height))"
}

##############################
########Main program starts here
##############################
catch {unset .w}
catch {destroy .w}

frame .w
grid forget .
grid .w -row 1 -column 1 -sticky nsew
grid columnconf . 1 -weight 1
grid rowconf    . 1 -weight 1

appletInit .w
setupUI .w
if {[readIn .w]} {draw .w}

proc setXML {name1 name2 op} {
   upvar #0 .w data
   if {[catch {set newXML [$data(doc) asXML]}]} {
      global errorInfo; tk_messageBox -title "Error - not updating" -message "$errorInfo" -type ok
   } else {
      global XMLDoc
      set XMLDoc $newXML
   }
}
trace add variable XMLDoc read setXML
</uiscript>
  </tclui>
  <Plant2>
    <ini />
  </Plant2>
</folder>