     ###     ######     #####   #   #     #   
    #   #    #     #   #        #   ##   ##   
   #     #   #     #   #        #   ##   ##   
   #######   ######     #####   #   # # # #   
   #     #   #              #   #   #  #  #   
   #     #   #         #####    #   #  #  #   
                                              
                                              
 The Agricultural Production Systems Simulator
             Copyright(c) APSRU               

Version                = 7.10
Title                  = LivsimSample
   Component                        "clock" = %apsim%\Model\Clock.dll
   Component                 "LivsimOutput" = %apsim%\Model\Report.dll
   Component                          "met" = %apsim%\Model\Input.dll
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                         "Area" = %apsim%\Model\Manager2.dll
   Component                    "Economics" = %apsim%\Model\Manager2.dll
   Component          "Cow Herd Management" = %apsim%\Model\Manager2.dll
   Component        "Shoat Herd Management" = %apsim%\Model\Manager2.dll
   Component               "bransupplement" = %apsim%\Model\Manager2.dll
   Component          "Maize_residue_store" = %apsim%\Model\Manager2.dll
   Component        "Sorghum_residue_store" = %apsim%\Model\Manager2.dll
   Component      "Groundnut_residue_store" = %apsim%\Model\Manager2.dll
   Component         "Mucuna_residue_store" = %apsim%\Model\Manager2.dll
   Component                        "magic" = %apsim%\Model\Manager2.dll
   Component              "Crop Management" = %apsim%\Model\TclLink.dll
   Component                 "Feed Quality" = %apsim%\Model\RLink.dll
   Component                       "shoats" = %apsim%\Model\RLink.dll
   Component                         "cows" = %apsim%\Model\RLink.dll
   Component                  "Ind Tracker" = %apsim%\Model\RLink.dll
   Component                  "Run Summary" = %apsim%\Model\RLink.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                       "canopy" = %apsim%\Model\Canopy.dll
   Component                   "Fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component         "SurfaceOrganicMatter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                       "peanut" = %apsim%\Model\Plant.dll
   Component                       "mucuna" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                        "maize" = %apsim%\Model\Maize.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                       "canopy" = %apsim%\Model\Canopy.dll
   Component                   "Fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component         "SurfaceOrganicMatter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                       "peanut" = %apsim%\Model\Plant.dll
   Component                       "mucuna" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                        "maize" = %apsim%\Model\Maize.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                       "canopy" = %apsim%\Model\Canopy.dll
   Component                   "Fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component         "SurfaceOrganicMatter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                       "peanut" = %apsim%\Model\Plant.dll
   Component                       "mucuna" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                        "maize" = %apsim%\Model\Maize.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "Fertiliser" = %apsim%\Model\Fertiliser.dll
   Component            "Establish pasture" = %apsim%\Model\Manager.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component         "SurfaceOrganicMatter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "grasp" = %apsim%\Model\Grasp.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll

------- clock Initialisation --------------------------------------------------
     Sequencer phases:
        prepare
        init_step
        do_management
        run_one_step
        do_pasture_water
        process
        do_pasture_growth
        do_stock
        do_cashbook
        post
        end_step
     Using start date from the met file.
     Using end date from the met file.
     Simulation start date =  1/01/1988
     Simulation end date   = 30/04/1990
     Time step =           = 1440 (mins)

------- LivsimOutput Initialisation -------------------------------------------
     Output variables:
        dd/mm/yyyy as Date
        herdsize_shoats
        herdsize_cows
        inputdmOfShoats
        faecdmOfShoats
        milkOfShoats
        inputdmOfCows
        faecdmOfCows
        milkOfCows
        grass_eaten
        maize_eaten
        bran_eaten
        sorghum_eaten
        mucuna_eaten
        resd_eaten
        store

     Output file = LivsimSample LivsimOutput.out
     Format = normal

------- met Initialisation ----------------------------------------------------
     Sparse data is not allowed
     INPUT File name: %apsim%\Examples\MetFiles\Dalby.met

------- accum Initialisation --------------------------------------------------
     Initialising

------- Area Initialisation ---------------------------------------------------

------- Economics Initialisation ----------------------------------------------

------- Cow Herd Management Initialisation ------------------------------------

------- Shoat Herd Management Initialisation ----------------------------------

------- bransupplement Initialisation -----------------------------------------

------- Maize_residue_store Initialisation ------------------------------------

------- Sorghum_residue_store Initialisation ----------------------------------

------- Groundnut_residue_store Initialisation --------------------------------

------- Mucuna_residue_store Initialisation -----------------------------------

------- magic Initialisation --------------------------------------------------
Crop Management: 
     Copyright (C) 1991-1994 The Regents of the University of California.
     Copyright (C) 1996-1997 Sun Microsystems, Inc.
     Copyright (C) 2001      ActiveState.
     --->Section: end_month

set cow [apsimGetOptional inputdmOfCows]; if {$cow == ""} {set cow 0}
set shoat [apsimGetOptional inputdmOfShoats]; if {$shoat == ""} {set shoat 0}

set year [apsimGet year]
lappend annual($year,dm_eaten) [expr $cow + $shoat]

     --->Section: end_simulation

          
close_annual_stuff
close_harvest_stuff


close_iat_stuff


     --->Section: end_year

foreach paddock $config(paddocks) {
   set weeds($paddock,Events)  0
}
do_end_year
     --->Section: init

set config(paddocks) [list plot1 plot2 plot3]
set config(pasturePaddocks) [list verges]

for {set i 0} {$i < [llength $config(paddocks)]} {incr i} {
  set config([lindex $config(paddocks) $i],area) [apsimGet [lindex $config(paddocks) $i]_area]
}

for {set i 0} {$i < [llength $config(pasturePaddocks)]} {incr i} {
  set config([lindex $config(pasturePaddocks) $i],area) [apsimGet [lindex $config(pasturePaddocks) $i]_area]
}

# A list of crops in each paddock
set config(crops) [list maize peanut mucuna sorghum]

apsimRegisterGetSet config(paddocks)
foreach paddock $config(paddocks) {
  set config($paddock,initialState) F0
  set config($paddock,history) {}
  set config($paddock,graphNames) ${paddock}graph
  set state($paddock) {}
}

set simName [apsimGet title]
# Sow this crop
proc sow_Maize_crop {paddock} {
  apsimSendMessage $paddock.maize sow {plants 4.4} {sowing_depth 30} {cultivar  sc501} {row_spacing 750} {crop_class  plant}
}

proc sow_Maize {paddock} {
  global config

  if {"yes" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Maize_crop $paddock

  if {0 > 0} {
     apsimSendMessage $paddock.fertiliser apply {type no3_n} {amount 0}
     apsimSendMessage economics expenditure {category fertilisercost} "name  no3_n" \
               "rate 0" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type no3_n" \
               "fertiliser_rate 0" {incrop_cost {}} "crop maize" \
               "comment Fertiliser"
  }
  doManure Maize $paddock

  if {"no" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }

  apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  operateLabour "operator male" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Maize {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin 15-jan 15-feb] } {
      if {( [apsimGet rain\[3\]] >= 20 ) ||
          ( "yes" == "yes" && [dateIs 15-feb] ) } {
          return 1
      }
    }
  }
  return 0
}

# Return whether any crop in our paddock is not "out"
proc paddockIsFallow {paddock} {
   global config
   foreach crop $config(crops) {
      set status [apsimGetOptional $paddock.$crop.plant_status]
      if {$status != "" && $status != "out"} {
         return 0
      }
   }
   return 1
}

##########Date functions (general)
proc dateWithin {t0 t1} {
   set year [apsimGet year]
   set d0 [date2day $t0 $year]
   set d1 [date2day $t1 $year]
   return [dayWithin $d0 $d1]
}

proc dateIs {t} {
   set d [date2day $t [apsimGet year]]
   return [dayIs $d]
}

proc dayWithin {t0 t1} {
   set t [apsimGet day]
   if {$t0 > $t1} {
      return [expr $t >= $t0 || $t <= $t1]
   } else {
      return [expr $t >= $t0 && $t <= $t1]
   }
   # notreached
}

proc dayIs {t} {
   return [expr $t == [apsimGet day]]
}

proc leapyr {y} {
   return [expr ($y%4 == 0) && ($y%100 != 0) || ($y%400 == 0)]
}

proc date2day {date year} {
   foreach {mday month} [split $date "-"] {break}
   if {[leapyr $year]} {
      array set daysin {jan 0  feb 31 mar 58 apr 89 may 119 jun 150 jul 180 aug 211 sep 242 oct 272 nov 303 dec 333}
   } else {
      array set daysin {jan 0  feb 31 mar 59 apr 90 may 120 jun 151 jul 181 aug 212 sep 243 oct 273 nov 304 dec 334}
   }
   return [expr $mday + $daysin($month)]
}

# Sow this crop
proc sow_Groundnut_crop {paddock} {
  apsimSendMessage $paddock.peanut sow {plants 2.8} {sowing_depth 30} {cultivar  early_bunch} {row_spacing 750} {crop_class  plant}
}
proc sow_Groundnut {paddock} {
  global config

  if {"no" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Groundnut_crop $paddock

  if {0 > 0} {
     apsimSendMessage $paddock.fertiliser apply {type no3_n} {amount 0}
     apsimSendMessage economics expenditure {category fertilisercost} "name  no3_n" \
               "rate 0" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type no3_n" \
               "fertiliser_rate 0" {incrop_cost {}} "crop peanut" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Groundnuts $paddock

  if {"no" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator male" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Groundnut {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin 15-jan 15-feb] } {
      if {( [apsimGet rain\[4\]] >= 25 ) ||
          ( "yes" == "yes" && [dateIs 15-feb] ) } {
          return 1
      }
    }
  }
  return 0
}


# Sow this crop
proc sow_Sorghum_crop {paddock} {
  apsimSendMessage $paddock.sorghum sow {plants 8} {sowing_depth 30} {cultivar  Buster} {row_spacing 750} {crop_class  [class]}
}
proc sow_Sorghum {paddock} {
  global config

  if {"no" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Sorghum_crop $paddock

  if {0 > 0} {
     apsimSendMessage $paddock.fertiliser apply {type no3_n} {amount 0}
     apsimSendMessage economics expenditure {category fertilisercost} "name  no3_n" \
               "rate 0" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type no3_n" \
               "fertiliser_rate 0" {incrop_cost {}} "crop sorghum" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Sorghum $paddock

  if {"no" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator male" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Sorghum {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin 10-feb 10-feb] } {
      if {( [apsimGet rain\[3\]] >= 25 ) ||
          ( "yes" == "yes" && [dateIs 10-feb] ) } {
          return 1
      }
    }
  }
  return 0
}


# Sow this crop
proc sow_Mucuna_crop {paddock} {
  apsimSendMessage $paddock.mucuna sow {plants 2.8} {sowing_depth 30} {cultivar  mucuna_gen} {row_spacing 750} {crop_class  plant}
}
proc sow_Mucuna {paddock} {
  global config

  if {"no" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Mucuna_crop $paddock

  if {0 > 0} {
     apsimSendMessage $paddock.fertiliser apply {type no3_n} {amount 0}
     apsimSendMessage economics expenditure {category fertilisercost} "name  no3_n" \
               "rate 0" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type no3_n" \
               "fertiliser_rate 0" {incrop_cost {}} "crop mucuna" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Groundnuts $paddock

  if {"no" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator male" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Mucuna {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin 10-feb 10-feb] } {
      if {( [apsimGet rain\[4\]] >= 25 ) ||
          ( "yes" == "yes" && [dateIs 10-feb] ) } {
          return 1
      }
    }
  }
  return 0
}


set config(manurecrops) [list Maize]

proc doManure {crop paddock} {
   global config
   if {[lsearch $config(manurecrops) $crop] >= 0} {
     apsimSet cows.manurepaddock  $paddock
     apsimSendMessage "cows" ApplyStoredManure
   }
}

if {[expr 0+0+100+0] != 100} {error "maize harvest residue fractions dont add to 100%"}

proc harvest_Maize {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator male" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.maize.yield]/1000.0]
   set biomass [apsimGet $paddock.maize.biomass]
   if {"maize" == "sorghum" } {
     set grainWt [apsimGet $paddock.maize.graingreenWt]
     if {$grainWt > 0} {
       set grainN [apsimGet $paddock.maize.graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.maize.LeafGreenWt] + \
                       [apsimGet $paddock.maize.LeafSenescedWt] + \
                       [apsimGet $paddock.maize.StemGreenWt] ) ]
     if {$stover > 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.maize.LeafGreenN] + \
                                [apsimGet $paddock.maize.LeafSenescedN] + \
                                [apsimGet $paddock.maize.StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"maize" == "maize"} {
     set grainProtein [apsimGet $paddock.maize.grain_protein] ;# (%)
     set stover [expr [apsimGet $paddock.maize.stover_wt] * 10.0 ]
     if {$stover > 0} {
        set stoverProtein [expr ([apsimGet $paddock.maize.stover_n] * 10.0) / $stover * 100.0 * 5.71]
     } else {
        set stoverProtein 0.0
     }
   } else {
     set grainProtein [expr [apsimGet $paddock.maize.grainN] / \
                            [apsimGet $paddock.maize.grainWt] * 100.0 * 5.71] ;# (%)
     set stover [expr ($biomass - $yield) ]
     set stoverProtein [expr [apsimGet $paddock.maize.vegetativeN] / \
                             [apsimGet $paddock.maize.vegetativeWt]* 100.0 * 5.71]
   }

   apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name maize"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop maize" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.maize  harvest  "remove 0.0"
   apsimSendMessage $paddock.maize  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {0 > 0} {
      set grazedFrac [expr 0 / 100.0]
   }
   set storedFrac 0.0
   if {100 > 0} {
      set storedFrac [expr 100 / 100.0]
      apsimSet Maize_residue_store.store [expr [apsimGet Maize_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + 0) / 100.0]
   if {$removedFrac > 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,maize,harvest)]} {
     set annual($year,maize,harvest) [expr $annual($year,maize,harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,maize,harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock maize \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock maize_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],maize,\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_Maize {paddock} {
  return [expr [string equal [apsimGet $paddock.maize.StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.maize.plant_status] "dead"]]
}



if {[expr 0+0+100+0] != 100} {error "peanut harvest residue fractions dont add to 100%"}

proc harvest_Groundnut {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator male" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.peanut.yield]/1000.0]  ;# tonnes/ha
   set biomass [apsimGet $paddock.peanut.biomass]
   if {"peanut" == "sorghum" } {
     set grainWt [apsimGet $paddock.peanut.graingreenWt]
     if {$grainWt > 0} {
       set grainN [apsimGet $paddock.peanut.graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.peanut.LeafGreenWt] + \
                       [apsimGet $paddock.peanut.LeafSenescedWt] + \
                       [apsimGet $paddock.peanut.StemGreenWt] ) ]
     if {$stover > 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.peanut.LeafGreenN] + \
                                [apsimGet $paddock.peanut.LeafSenescedN] + \
                                [apsimGet $paddock.peanut.StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } else {
     set grainWt [apsimGet $paddock.peanut.grainWt]
     if {$grainWt > 0} {
       set grainProtein [expr [apsimGet $paddock.peanut.grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
       set stover [expr ($biomass - 1000* $yield) ]
       set stoverProtein [expr [apsimGet $paddock.peanut.vegetativeN] / \
                             [apsimGet $paddock.peanut.vegetativeWt]* 100.0 * 5.71]
     } else {
       set stover 0.0
       set stoverProtein 0.0
       set grainProtein 0.0
     }
   }

   apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name peanut"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop peanut" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.peanut  harvest  "remove 0.0"
   apsimSendMessage $paddock.peanut  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {0 > 0} {
      set grazedFrac [expr 0 / 100.0]
   }
   set storedFrac 0.0
   if {100 > 0} {
      set storedFrac [expr 100 / 100.0]
      apsimSet Groundnut_residue_store.store [expr [apsimGet Groundnut_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + 0) / 100.0]
   if {$removedFrac > 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,peanut,harvest)]} {
     set annual($year,peanut,harvest) [expr $annual($year,peanut,harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,peanut,harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock peanut \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock peanut_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],peanut,\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_Groundnut {paddock} {
  return [expr [string equal [apsimGet $paddock.peanut.StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.peanut.plant_status] "dead"]]
}



if {[expr 0+0+0+100] != 100} {error "sorghum harvest residue fractions dont add to 100%"}

proc harvest_Sorghum {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator male" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.sorghum.yield]/1000.0]
   set biomass [apsimGet $paddock.sorghum.biomass]
   if {"sorghum" == "sorghum"} {
     set grainWt [apsimGet $paddock.sorghum.graingreenWt]
     if {$grainWt > 0} {
       set grainN [apsimGet $paddock.sorghum.graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.sorghum.LeafGreenWt] + \
                       [apsimGet $paddock.sorghum.LeafSenescedWt] + \
                       [apsimGet $paddock.sorghum.StemGreenWt] ) ]
     if {$stover > 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.sorghum.LeafGreenN] + \
                                [apsimGet $paddock.sorghum.LeafSenescedN] + \
                                [apsimGet $paddock.sorghum.StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"sorghum" == "maize"} {
     set grainProtein [apsimGet $paddock.sorghum.grain_protein]        ;# (%)
     set stover [apsimGet $paddock.sorghum.stover]
     set stoverProtein [expr [apsimGet $paddock.sorghum.stover_n] / \
                             [apsimGet $paddock.sorghum.stover_wt] * 100.0 * 5.71] ;# (%)
   } else {
     set grainWt [apsimGet $paddock.sorghum.grainWt]
     if {$grainWt > 0} {
       set grainProtein [expr [apsimGet $paddock.sorghum.grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ($biomass - $yield) ]
     set stoverProtein [expr [apsimGet $paddock.sorghum.vegetativeN] / \
                             [apsimGet $paddock.sorghum.vegetativeWt]* 100.0 * 5.71]
   }

   apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name sorghum"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop sorghum" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.sorghum  harvest  "remove 0.0"
   apsimSendMessage $paddock.sorghum  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {0 > 0} {
      set grazedFrac [expr 0 / 100.0]
   }
   set storedFrac 0.0
   if {0 > 0} {
      set storedFrac [expr 0 / 100.0]
      apsimSet Sorghum_residue_store.store [expr [apsimGet Sorghum_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + 0) / 100.0]
   if {$removedFrac > 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,sorghum,harvest)]} {
     set annual($year,sorghum,harvest) [expr $annual($year,sorghum,harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,sorghum,harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock sorghum \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock sorghum_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],sorghum,\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_Sorghum {paddock} {
  return [expr [string equal [apsimGet $paddock.sorghum.StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.sorghum.plant_status] "dead"]]
}



if {[expr 0+0+100+0] != 100} {error "mucuna harvest residue fractions dont add to 100%"}

proc harvest_Mucuna {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator male" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.mucuna.yield]/1000.0]  ;# tonnes/ha
   set biomass [apsimGet $paddock.mucuna.biomass]
   if {"mucuna" == "sorghum"} {
     set grainWt [apsimGet $paddock.mucuna.graingreenWt]
     if {$grainWt > 0} {
       set grainN [apsimGet $paddock.mucuna.graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.mucuna.LeafGreenWt] + \
                       [apsimGet $paddock.mucuna.LeafSenescedWt] + \
                       [apsimGet $paddock.mucuna.StemGreenWt] ) ]
     if {$stover > 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.mucuna.LeafGreenN] + \
                                [apsimGet $paddock.mucuna.LeafSenescedN] + \
                                [apsimGet $paddock.mucuna.StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"mucuna" == "maize"} {
     set grainProtein [apsimGet $paddock.mucuna.grain_protein]        ;# (%)
     set stover [apsimGet $paddock.mucuna.stover]
     set stoverProtein [expr [apsimGet $paddock.mucuna.stover_n] / \
                             [apsimGet $paddock.mucuna.stover_wt] * 100.0 * 5.71] ;# (%)
   } else {
     set grainWt [apsimGet $paddock.mucuna.grainWt]
     if {$grainWt > 0} {
       set grainProtein [expr [apsimGet $paddock.mucuna.grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ($biomass - 1000 * $yield) ]
     if {[apsimGet $paddock.mucuna.vegetativeWt] > 0 } {
       set stoverProtein [expr [apsimGet $paddock.mucuna.vegetativeN] / \
                               [apsimGet $paddock.mucuna.vegetativeWt]* 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
   }

   apsimSendMessage economics expenditure \
                   "cost [expr 0 * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name mucuna"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop mucuna" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.mucuna  harvest  "remove 0.0"
   apsimSendMessage $paddock.mucuna  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {0 > 0} {
      set grazedFrac [expr 0 / 100.0]
   }
   set storedFrac 0.0
   if {100 > 0} {
      set storedFrac [expr 100 / 100.0]
      apsimSet Mucuna_residue_store.store [expr [apsimGet Mucuna_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + 0) / 100.0]
   if {$removedFrac > 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,mucuna,harvest)]} {
     set annual($year,mucuna,harvest) [expr $annual($year,mucuna,harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,mucuna,harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock mucuna \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock mucuna_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],mucuna,\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_Mucuna {paddock} {
  return [expr [string equal [apsimGet $paddock.mucuna.StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.mucuna.plant_status] "dead"]]
}


proc checkWeeds {} {
   global daysSinceLastTillage weeds config
   set rainCrit [apsimGet rain\[4\]]

   foreach paddock $config(paddocks) {
      incr daysSinceLastTillage($paddock)
      set weeds($paddock,status) [apsimGet $paddock.weed.plant_status]
      if {$daysSinceLastTillage($paddock) > 20 &&
          $weeds($paddock,status) == "out" &&
          $rainCrit >= 25 &&
          $weeds($paddock,Events) < 0} {
           apsimWriteToSummaryFile "Weeds germinating in $paddock"
           apsimSendMessage $paddock.weed sow {crop_class summer_grass} {plants 20} {sowing_depth 75} {cultivar early} {row_spacing 750}
           incr weeds($paddock,Events)
      } elseif {$weeds($paddock,status) == "dead" || [apsimGet $paddock.weed.StageName] == "harvest_ripe"} {
           killWeeds $paddock
      }
   }
}

proc killWeeds {paddock} {
   global weeds daysSinceLastTillage annual
   apsimWriteToSummaryFile "Killing weeds in $paddock"
   if {$weeds($paddock,status) != "out"} {
     apsimSendMessage $paddock.weed end_crop
   }
   set weeds($paddock,status) "out"
   set annual($paddock,weedings) [expr $annual($paddock,weedings) + 1.0]
   set daysSinceLastTillage($paddock) 0
}

proc doFallowTillage40 {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "user_defined" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} {f_incorp 0.9} {tillage_depth 100}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined}
   }
   set daysSinceLastTillage($paddock) 0
}

proc doTillageSometime {paddock operator activity routine} {
   global config
   operateLabour "operator $operator" "activity $activity" \
                 "area $config($paddock,area)" "callback [list $routine $paddock]" \
                 "paddock $paddock" "costtype incrop_cost" {comment "Fallow tillage"}

}

proc doTillageNow {paddock routine} {
   $routine $paddock
}


proc doIncropTillage21 {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "user_defined" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} {f_incorp 0.9} {tillage_depth 100}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined}
   }
   set daysSinceLastTillage($paddock) 0
}

proc doIncropTillage45 {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "user_defined" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} {f_incorp 0.9} {tillage_depth 100}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined}
   }

   set daysSinceLastTillage($paddock) 0
}

proc doPresowTillage {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "user_defined" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} {f_incorp 0.9} {tillage_depth 100}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined}
   }

   operateLabour "operator male" "activity presow_till"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "Pre sowing tillage"}
   set daysSinceLastTillage($paddock) 0
}



proc doSowingTillage {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "user_defined" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} {f_incorp 0.1} {tillage_depth 100}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined}
   }

   operateLabour "operator male" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "Sowing tillage"}
   set daysSinceLastTillage($paddock) 0
}


# Return area (ha) planted to a crop
proc areaOf {crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set sum 0.0
   foreach paddock $config(cropPaddocks) {
      set state [currentState $paddock]
      if {[info exists config($state,alias)]} {set state $config($state,alias)}
      if {"$state" == "$crop"} {
        set sum [expr $sum + $config($paddock,area)]
      }
   }
   return $sum
}

proc areaPlantedOk {crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set f [expr [areaOf $crop] / $config(allCropArea)]

   return [expr $f < $config(maxFract,$crop)]
}

proc historyOk {paddock crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set max $config(maxContinuous,$crop)
   set n [llength $config($paddock,history)]
   for {set i $n} {$i >= $n - $max} {decr i} {
      if {[lindex $config($paddock,history)] != $crop} {return 1}
   }
   return 0
}



########### Support procedures

proc max {a b} { return [expr {($a > $b) ? $a : $b}] }
proc min {a b} { return [expr {($a > $b) ? $b : $a}] }

# Return the current state of the system
proc currentState {paddock} {
   global state
   return $state($paddock)
}

# Gather arguments (eg sowing depth, fert rate etc} from defaults array
# $action: the operation (sow, fert ...
# $what: the module (wheat, sorghum ...
proc gatherArgs {action what} {
   global defaults config

   # 1. "sow,..."
   foreach {index value} [array get defaults $action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 2. override above with any "wheat,sow,..."
   foreach {index value} [array get defaults $what,$action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 3. override above with any "SpringWheat,sow,..."
   if {[info exists config($what,alias)]} {
      foreach {index value} [array get defaults $config($what,alias),$action,*] {
         set args([lindex [split $index ","] end]) $value
      }
   }
   return [array get args]
}

# Mash a list into name/value pairs to pass via the apsim message system
proc mash {list} {
   set result {}
   foreach {name value} $list {lappend result [list $name $value]}
   return $result
}

# Sum a list
proc lsum {list} {
   set result 0.0
   foreach value $list {set result [expr $result + $value]}
   return $result
}

# Linear interpolation
proc linint {x_coords y_coords value} {
   set y  0.0

   if {[llength $x_coords] <= 0 || [llength $y_coords] <= 0 || [llength $x_coords] != [llength $y_coords]} {
      error "bad coordinates in linear_interp_real"
   }

   for {set indx 0} {$indx < [llength $x_coords]} {incr indx} {
      if {$value <= [lindex $x_coords $indx]} {
         if {$indx == 0} {
            set y [lindex $y_coords $indx]
         } else {
            if {abs($value - [lindex $x_coords $indx]) < 1.0E-4} {
               set y [lindex $y_coords $indx]
            } else  {
               set y_part [expr [lindex $y_coords $indx] - [lindex $y_coords [expr $indx-1]] ]
               set x_part [expr [lindex $x_coords $indx] - [lindex $x_coords [expr $indx-1]] ]
               set y [expr ($y_part/$x_part) * ($value - [lindex $x_coords [expr $indx - 1]]) + [lindex $y_coords [expr $indx- 1]] ]
            }
         break;
         }
      } elseif {$indx == [lindex $x_coords $indx]-1} {
         set y  [lindex $y_coords $indx]
      } else {
         set y  0.0
      }
   }
   return $y
}

#############################
############### The decision routine(s).
#############################
# Return the score for planting "what"
proc checkRules {thisPaddock} {
  global config

  uplevel #0 set paddock \"$thisPaddock\"
  set bestScore -1.0; set bestTarget {}; set bestArc {}; set bestGraph {}
  foreach graph $config($thisPaddock,graphNames) {
     foreach arc [$graph arcs -out [currentState $thisPaddock]] {
        set expr {}
        set target [$graph arc target $arc]
        foreach rule [$graph arc get $arc rules] {
           set value [uplevel #0 expr $rule]
           lappend expr $value
           if {$value == 0} {break} ;# no need to continue evaluating subsequent rules
        }
        if {[llength $expr] > 0} {
           set score [expr [join $expr "*"]]
           if {$score > $bestScore} {
              set bestScore  $score
              set bestTarget $target
              set bestArc    $arc
              set bestGraph  $graph
           }
        }
     }
  }
  return [list  $bestScore $bestGraph $bestTarget $bestArc]
}

# A place holder function to monitor state transitions
proc logState {graph paddock state} {
  ###puts "$graph $paddock $state"
}

# Change state to another
proc changeState {paddock graph arc} {
   global state
   uplevel #0 set paddock \"$paddock\"
   puts "$graph - Changing state in paddock $paddock from $state($paddock) to [$graph arc target $arc]"
   if {[$graph arc keyexists $arc actions]} {
      foreach action [$graph arc get $arc actions] {
         puts "      - undertaking action $action"
         uplevel #0 $action
      }
   }
   set state($paddock) [$graph arc target $arc]
   logState $graph $paddock $state($paddock)
}

# Do daily process at top level
proc doProcess {} {
   global date config daysSinceLastHarvest

   set date "[apsimGet day],[apsimGet year]"

   set more 1
   while {$more} {
      set more 0
      # 1. Find out what's possible
      set bestPaddock {}; set bestScore -1.0
      foreach paddock $config(paddocks) {
         foreach {score graph target arc} [checkRules $paddock] {break}
         if {$score > $bestScore} {
            set bestPaddock $paddock; set bestScore $score; set bestGraph $graph; set bestTarget $target; set bestArc $arc
         }
      }
      if {$bestScore > 0.0} {
         changeState $bestPaddock $bestGraph $bestArc
         set more 1
      }
   }

   foreach paddock $config(paddocks) {
      incr daysSinceLastHarvest($paddock)
   }
}

# pass events to various output files
proc reportEvent {from what} {
   foreach {event args} [split $what "-"] {break}
}

puts "Done farm"

package require struct
foreach {paddock sequence} {plot1 Maize plot2 Groundnut plot3 Mucuna} {
   ::struct::graph ${paddock}graph
   set states [split $sequence "."]
   for {set istate 0} {$istate < [llength $states]} {incr istate} { ${paddock}graph node insert "F$istate" }
   for {set istate 0} {$istate < [llength $states]} {incr istate} {
     set myState [lindex $states $istate].$istate
     ${paddock}graph node insert $myState
     ${paddock}graph arc insert F$istate $myState "arc$istate"
     if {[lindex $states $istate] == "SR_X" } {
       ${paddock}graph arc lappend "arc$istate" rules "\[dateIs 14-mar\]"
     } elseif {[lindex $states $istate] == "LR_X"} {
       ${paddock}graph arc lappend "arc$istate" rules "\[dateIs 14-sep\]"
     } else {
       ${paddock}graph arc lappend "arc$istate" actions "sow_[lindex $states $istate] $paddock"
       ${paddock}graph arc lappend "arc$istate" rules "\[canSow_[lindex $states $istate] $paddock \]"
       ${paddock}graph arc lappend "arc$istate" rules "\$daysAfterHarvest(\$paddock) > 1"
     }
     if {$istate == [llength $states] - 1} {
        ${paddock}graph arc insert $myState F0 "arc${istate}Out"
     } else {
        ${paddock}graph arc insert $myState F[expr $istate+1] "arc${istate}Out"
     }
     if {[lindex $states $istate] == "LR_X" || [lindex $states $istate] == "SR_X"} {
       ${paddock}graph arc lappend "arc${istate}Out" rules "1"
     } else {
       ${paddock}graph arc lappend "arc${istate}Out" actions "harvest_[lindex $states $istate] $paddock"
       ${paddock}graph arc lappend "arc${istate}Out" actions "set daysAfterHarvest(\$paddock) 0"
       ${paddock}graph arc lappend "arc${istate}Out" rules "\[canHarvest_[lindex $states $istate] $paddock \]"
     }
   }
   puts "Paddock $paddock cropping sequence:"
   foreach node [${paddock}graph nodes] {
     puts " Node $node"
     foreach key [${paddock}graph node keys $node *] {
       puts " $key: [${paddock}graph node get $node $key]"
     }
     foreach arc [${paddock}graph arcs -out $node] {
       foreach key [${paddock}graph arc keys $arc *] {
          puts " $arc:$key [${paddock}graph arc get $arc $key]"
       }
     }
   }
}

foreach paddock $config(paddocks) {set daysAfterHarvest($paddock) 30}


# Utilities
proc lsum {list} {return [expr  [join $list "+"]]}
proc lavg {list} {
  if {[llength $list] > 0} {
    return [expr [lsum $list] / [llength $list]]
  }
  return 0.0
}

# Annual summary of whole farm averages

proc open_annual_stuff {} {
   global annual annualcrop config
   set year [expr [apsimGet year] - 1 ]
   set annual(years) $year
   set annual(accRain) 0.0
   set annual($year,balance) [apsimGetOptional balance]
   set annual($year,income) [apsimGetOptional income]
   set annual($year,expenditure) [apsimGetOptional expenditure]
   foreach {accumulator} { dm_eaten} {
     set annual($year,$accumulator) 0
   }
   foreach {accumulator} {runoff drain soil_loss es weedings} {
     foreach paddock $config(paddocks) {
        set annual($paddock,$accumulator) 0.0
     }
   }
}

proc do_end_year {} {
   global config annual annualcrop

   set year [apsimGet year]

   foreach {accumulator} {runoff drain soil_loss es weedings} {
     foreach paddock $config(paddocks) {
        set annual($year,$paddock,$accumulator) $annual($paddock,$accumulator)
        set annual($paddock,$accumulator) 0.0
     }
   }
   foreach paddock $config(paddocks) {
     set annual($year,$paddock,avg_cover) [apsimGetOptional "$paddock.tracker.avg_cover"]
     if {$annual($year,$paddock,avg_cover) == ""} {set annual($year,$paddock,avg_cover) "*"}

     set annual($year,$paddock,avg_carbon) [apsimGetOptional "$paddock.tracker.avg_carbon"]
     if {$annual($year,$paddock,avg_carbon) == ""} {set annual($year,$paddock,avg_carbon) "*"}
   }
   set annual($year,accRain) $annual(accRain)
   set annual(accRain) 0.0
   set annual($year,balance) [apsimGetOptional balance]
   set annual($year,income) [apsimGetOptional income]
   set annual($year,expenditure) [apsimGetOptional expenditure]
   lappend annual(years) $year
}

proc close_annual_stuff {} {
   global simName config annual annualcrop
   puts "close_annual_stuff called"
   parray annual

   # Heading
   set fp [open $simName.annual.out w]
   puts $fp "Title = $simName"
   puts $fp ""
   puts -nonewline $fp "year "
   foreach {accumulator} {runoff drain soil_loss es avg_cover avg_carbon rain weedings dm_eaten} {
      puts -nonewline $fp " $accumulator"
   }
   foreach id [getLabourers] {
      puts -nonewline $fp " ${id}_labour"
   }
   foreach crop $config(crops) {
      puts -nonewline $fp " ${crop}_harvest"
   }
   puts $fp " income expenditure profit"

   puts -nonewline $fp "() "
   foreach {accumulator} {runoff drain soil_loss es rain } {
      puts -nonewline $fp " (mm)"
   }
   puts -nonewline $fp " ()  ()  () (kg)"
   foreach id [getLabourers] {
      puts -nonewline $fp " (hours)"
   }
   foreach crop $config(crops) {
      puts -nonewline $fp " (tonnes-wet)"
   }
   puts $fp " ($) ($) ($)"

   # Area weighted averages of environmental stuff
   set tfa 0.0
   foreach paddock $config(paddocks) {set tfa [expr $tfa + $config($paddock,area)]}
   if {$tfa <= 0.0} {close $fp; return}

   foreach year [lrange $annual(years) 1 end] {
      puts -nonewline $fp "$year "
      foreach {accumulator} {runoff drain soil_loss es} {
         set s 0.0
         foreach paddock $config(paddocks) {
            set s [expr $s + $annual($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
         }
         puts -nonewline $fp " [format %.2f $s]"
      }
      foreach {accumulator} {avg_cover avg_carbon} {
         set s 0.0
         foreach paddock $config(paddocks) {
            if {![string is double -strict $annual($year,$paddock,$accumulator)]} {
               set s " *"
               break
            } else {
               set s [expr $s + $annual($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
            }
         }
         if {[string is double -strict $s]} {
            puts -nonewline $fp " [format %.2f $s]"
         } else {
            puts -nonewline $fp " *"
         }
      }
      puts -nonewline $fp " [format %.2f $annual($year,accRain)]"
      set s 0.0
      foreach paddock $config(paddocks) {set s [expr $s + $annual($year,$paddock,weedings)] }
      puts -nonewline $fp " [format %.0f $s]"
      if {[info exists annual($year,dm_eaten)]} {
         puts -nonewline $fp " [lsum $annual($year,dm_eaten)]"
      } else {
         puts -nonewline $fp " 0"
      }
      foreach id [getLabourers] {
        if {[info exists annual($year,labourhours)]} {
          puts -nonewline $fp " $annual($year,$id,labourhours)"
        } else {
          puts -nonewline $fp " 0"
        }
      }
      foreach crop $config(crops) {
         if {[info exists annual($year,$crop,harvest)]} {
           puts -nonewline $fp " [format %.3f $annual($year,$crop,harvest)]"
         } else {
           puts -nonewline $fp " *"
         }
      }

      if {[info exists annual($year,income)] && [string is double -strict $annual($year,income)] } {
         puts -nonewline $fp " [format %.2f $annual($year,income)]"
      } else {
         puts -nonewline $fp " *"
      }
      if {[info exists annual($year,expenditure)] && [string is double -strict $annual($year,expenditure)]} {
         puts -nonewline $fp " [format %.2f $annual($year,expenditure)]"
      } else {
         puts -nonewline $fp " *"
      }
      # profit = change in bank balance each year
      catch {
         puts -nonewline $fp " [format %.2f [expr $annual($year,balance) - $annual([expr $year-1],balance)]]"
      }
      puts $fp ""
   }
   close $fp
}
# Annual summary of whole farm averages

proc open_harvest_stuff {} {
   global harvest config
   set harvest {}
}


proc close_harvest_stuff {} {
   global simName config harvest
   puts "close_harvest_stuff called"

   # Heading
   set fp [open $simName.harvest.out w]
   puts $fp "Title = $simName"
   puts $fp ""
   puts $fp "Date         season paddock crop biomass  yield   protein"
   puts $fp "(dd/mm/yyyy)     ()      ()   () (kg/ha) (kg/ha)  (%)"

   foreach line $harvest {
      puts $fp $line
   }
   close $fp
}


# Annual summary of whole farm averages

proc open_iat_stuff {} {
   global iat config
   set iat {}
}


proc close_iat_stuff {} {
   global simName config iat
   puts "close_iat_stuff called"

   # Heading
   set fp [open $simName.iat.csv w]
   puts $fp "Date,crop,biomass,grain.yield,grain.protein,residue.yield,residue.protein"
   puts $fp "(dd/mm/yyyy),(),(kg/ha),(kg/ha),(%),(kg/ha),(%)"

   foreach line $iat {
      puts $fp $line
   }
   close $fp
}


# Apsim Machinery (sub)Module
# Contains Tractors, Implements & Labour.

# Operations:
# bool available(<config>)    ; See if a configuration can be used today (read)
# operate <config> <area>     ; Operate a configuration over an area until finished (event)

########################## Apsim interface code here
source $apsuite/Model/TclLink/CIDataTypes.tcl

# A trace handler for status. This handler is called whenever another module
# asks us whether machinery is available.
#    NB. Careful! Errors in trace routines are not caught!!!
proc machinery:maProc {name1 name2 op} {
   if {$op == "read" } {
      global config $name1
      foreach {junk operator implement} [split $name1 "_"] { break }

      # Check they are known to us
      if {[lsearch $config(operators) $operator] < 0} {
         set msg "operator \"$operator\" is unknown - I only know about $config(operators)"
         error $msg
      }
      if {[lsearch $config(implements) $implement] < 0} {
         set msg "implement \"$implement\" is unknown - I only know about $config(implements)"
         error $msg
      }

      # Now see if they are busy
      set avail 1
      catch {
         global machinery:jobs
         foreach job ${machinery:jobs} {
            foreach {tid iid area paddock costtype} [split $job ","] {break}
            if {"$operator" == "$tid" || "$implement" == "$iid"} {set avail 0}
         }
      } msg
      if {$msg != ""} {apsimWriteToSummaryFile $msg; error $msg}

      # Set the variable - this is what is returned to apsim.
      set $name1 $avail
   }
}

# An event handler.
proc operateLabour {args} {
  foreach arg $args {
     regsub -all "'" [lindex $arg 0] {} _name
     regsub -all "'" [lrange $arg 1 end] {} _value
     if {"$_name" != "callback"} {
        set [string tolower $_name] [string tolower $_value]
     } else {
        set $_name $_value
     }
  }
  if {![info exists operator] || ![info exists activity] || ![info exists area]} {
     error "Must specify a operator, activity, and area to operate over."
  }
  if { ![info exists paddock] } {set paddock {}}
  if { ![info exists costtype] } {set costtype unknown}
  if { ![info exists callback]}  {
    machinery:operate $operator $activity $area $paddock $costtype
  } else {
    machinery:operateLater $operator $activity $area $paddock $costtype $callback
  }
}

# Now register the event handlers.
#apsimSubscribeVariant operate            "machinery:operateHandler"
#apsimSubscribeVariant operate_later      "machinery:operateLaterHandler"
apsimSubscribeNull process            "machinery:process"
apsimSubscribeNull end_financial_year "machinery:end_year"
########################## End apsim interface code

########################## Machinery configuration code
# Read in our configuration
proc machinery:initialise {} {
   global config
   if {![info exists config(operators)]} {set config(operators) {}}
   if {![info exists config(implements)]} {set config(implements) {}}
}

# return the work rate for this combo can cover per hour
proc getCombo {operator implement thing} {
   global config
   if {![info exists config(machinery,$operator,$implement,$thing)]} {
      error "No $thing specified for $operator and $implement"
   }
   return $config(machinery,$operator,$implement,$thing)
}

proc getRate {tid iid} {
   return [getCombo $tid $iid workrate]
}

proc getValue {id thing} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (get)"
   }
   return $config(machinery,$id,$thing)
}

# Return the cost of labour per hour
proc labourCost {} {
   global config
   if {![info exists config(economics,labourCost)]} {
      error "No labourCost specified"
   }
   return $config(economics,labourCost)
}

# return the labour cost this combo uses per hour
proc getLabourCost {tid iid} {
   return [expr [getCombo $tid $iid workrate] * [ labourCost ]]
}

proc getLabourers {} {
   global config
   return $config(operators)
}


# Return the number of hours worked per day
proc getHoursPerDay {tid iid} {
   return [getCombo $tid $iid hoursperday]
}

proc setValue {id thing value} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (set)"
   }
   set config(machinery,$id,$thing) $value
}

##############
# Operate a configuration over an area. Just add it to the job queue
# and let process look after it.
proc machinery:operate {operator implement area paddock costtype} {
   if {![string is double -strict $area]} {
      error "Area should be a number (not $area)"
   }
   global machinery:jobs
   lappend machinery:jobs $operator,$implement,$area,$paddock,$costtype,
   apsimWriteToSummaryFile "Machinery job \"$operator + $implement\" is queued"
}

proc machinery:operateLater {operator implement area paddock costtype command} {
   if {![string is double -strict $area]} {
      error "Area should be a number (not $area)"
   }
   global machinery:jobs
   lappend machinery:jobs $operator,$implement,$area,$paddock,$costtype,$command
   apsimWriteToSummaryFile "Machinery job \"$operator + $implement\" is queued"
}

# The daily process routine. Manages the job queue
proc machinery:process {} {
   global machinery:jobs annual
   set tomorrowsJobs {}
   # Go through each job. If an item is in use in any prior job, we can't do it today.
   for {set ijob 0} {$ijob < [llength ${machinery:jobs}]} {incr ijob} {
      set job [lindex ${machinery:jobs} $ijob]
      foreach {tid iid area paddock costtype command} [split $job ","] {break}
      set inuse 0
      for {set j 0} {$j < $ijob} {incr j} {
         foreach {Ttid Tiid Tarea Tpaddock Tcosttype Tcommand} [split [lindex ${machinery:jobs} $j] ","] {break}
         if {$tid == $Ttid || $iid == $Tiid} {set inuse 1}
      }
      if {!$inuse} {
        # The job is running today. Work out how many hours, and then the costs
        set maxHours [getHoursPerDay $tid $iid]
        set rate [getRate $tid $iid]

        if {$maxHours * $rate <= $area} {
           set hours $maxHours
           set areaToday [expr $maxHours * $rate]
        } else {
           set hours [expr $area / $rate]
           set areaToday [expr $hours * $rate]
        }
        set cost [expr $hours * [getLabourCost $tid $iid]]
        apsimSendMessage "" expenditure [list hours $hours] [list cost $cost] [list comment "operating costs of $tid + $iid"] [list paddock $paddock] [list area $areaToday] [list $costtype {}]
        set year [apsimGet year]
        if {![info exists annual($year,labourhours)]} {
           set annual($year,$tid,labourhours) $hours
        } else {
           set annual($year,$tid,labourhours) [expr $annual($year,labourhours) + $hours]
        }

        set rate [expr $hours * [getRate $tid $iid]]
        set area [expr $area - $rate]

        if {$area > 0} {
           lappend tomorrowsJobs $tid,$iid,$area,$paddock,$costtype,$command
        } else {
           apsimWriteToSummaryFile "Labour job '$tid + $iid' in $paddock has finished"
           if {$command != ""} { apsimWriteToSummaryFile "doing $command"; eval $command }
        }
      } else {
        lappend tomorrowsJobs $job
      }
   }
   set machinery:jobs $tomorrowsJobs
}

# The "end_year" routine. Do loan payments and replacement
proc machinery:end_year {} {
   global annual
   global machinery:jobs

}

lappend config(operators) "male"
set config(machinery,male,age) "0"

set config(machinery,male,sowing,workrate) "0.5"
set config(machinery,male,sowing,hoursperday) "12"

set config(machinery,male,weeding,workrate) "0.8"
set config(machinery,male,weeding,hoursperday) "12"

set config(machinery,male,harvesting,workrate) "0.2"
set config(machinery,male,harvesting,hoursperday) "8"

set config(machinery,male,presow_till,workrate) "0.1"
set config(machinery,male,presow_till,hoursperday) "8"

set config(machinery,male,spraying,workrate) "0.1"
set config(machinery,male,spraying,hoursperday) "8"

set config(economics,labourCost) "0.0"
          
     --->Section: post

foreach paddock $config(paddocks) {
   if {[apsimGetOptional $paddock.maize.DaysAfterSowing] == 21} {
      doTillageSometime $paddock male weeding doIncropTillage21
   }
}

foreach paddock $config(paddocks) {
   if {[apsimGetOptional $paddock.maize.DaysAfterSowing] == 45} {
      doTillageSometime $paddock male weeding doIncropTillage45
   }
}
foreach paddock $config(paddocks) {incr daysAfterHarvest($paddock)}
          
   set annual(accRain) [expr $annual(accRain) + [apsimGet rain]]
   foreach {accumulator} {runoff drain es } {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet $config($paddock,watBal).$accumulator]]
         }
      }
   }
   foreach {accumulator} {soil_loss} {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet $paddock.erosion.$accumulator]]
         }
      }
   }
   
     --->Section: prepare

checkWeeds

foreach paddock $config(paddocks) {
   if {$daysSinceLastHarvest($paddock) == 40} {
      doTillageSometime $paddock male weeding doFallowTillage40
   }
}

if {[dateIs 15-mar]} {
   if {"no" == "yes"} {
      foreach paddock $config(paddocks) {
         apsimSendMessage $config($paddock,watBal) reset
         apsimSendMessage $config($paddock,nModule) reset
      }
   }
   apsimSendMessage "" lr_start
}
if {[dateIs 14-sep]} {
  apsimSendMessage "" lr_end
}

     --->Section: process

# Housekeeping
if {[catch {doProcess } msg]} {
   puts "$errorInfo"
   error "$msg\n$errorInfo"
}


     --->Section: start_simulation

foreach paddock $config(paddocks) {
   set weeds($paddock,GermDay) {}
   set weeds($paddock,Events)  0
   set daysSinceLastTillage($paddock)    0
}
foreach paddock $config(paddocks) {
  set state($paddock)         $config($paddock,initialState) ;# Should get this from xml
  set history($paddock)       $config($paddock,history)
  set daysSinceLastHarvest($paddock) 60
}

# All our soils are called "Soil.."
foreach paddock $config(paddocks) {
   set config($paddock,watBal)   "$paddock.Soil Water"
   set config($paddock,nModule)  "$paddock.Soil Nitrogen"
}

set config(states) {}


catch "file delete $simName.annual.out"

open_annual_stuff
catch "file delete $simName.harvest.out"

open_harvest_stuff


catch "file delete $simName.iat.csv"

open_iat_stuff



# Finally, load our configuration database and initialise states
machinery:initialise
set machinery:jobs {}

# Now tell apsim we own it, set up the trace variable we use to trigger when the variable is read
foreach tid $config(operators) {
  foreach iid $config(implements) {
     set v available_${tid}_${iid}
     set $v 0
     apsimRegisterGetSet $v
     trace add variable $v read "machinery:maProc"
  }
}

apsimWriteToSummaryFile "Labour:\nOperators=$config(operators)\nImplements=$config(implements)"


     --->End
Done farm
Paddock plot1 cropping sequence:
 Node Maize.0
 arc0Out:actions {harvest_Maize plot1} {set daysAfterHarvest($paddock) 0}
 arc0Out:rules {[canHarvest_Maize plot1 ]}
 Node F0
 arc0:actions {sow_Maize plot1}
 arc0:rules {[canSow_Maize plot1 ]} {$daysAfterHarvest($paddock) > 1}
Paddock plot2 cropping sequence:
 Node Groundnut.0
 arc0Out:actions {harvest_Groundnut plot2} {set daysAfterHarvest($paddock) 0}
 arc0Out:rules {[canHarvest_Groundnut plot2 ]}
 Node F0
 arc0:actions {sow_Groundnut plot2}
 arc0:rules {[canSow_Groundnut plot2 ]} {$daysAfterHarvest($paddock) > 1}
Paddock plot3 cropping sequence:
 Node F0
 arc0:actions {sow_Mucuna plot3}
 arc0:rules {[canSow_Mucuna plot3 ]} {$daysAfterHarvest($paddock) > 1}
 Node Mucuna.0
 arc0Out:actions {harvest_Mucuna plot3} {set daysAfterHarvest($paddock) 0}
 arc0Out:rules {[canHarvest_Mucuna plot3 ]}
Feed Quality: 
     RLink Initialisation
     Loading R from C:/Program Files/R/R-3.6.3
     Warning: couldnt load R library Rcpp
     Warning: couldnt load R library RInside
Error: function 'setCurrentScope' not provided by package 'Rcpp'
In addition: Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called 'Rcpp'
Execution halted

