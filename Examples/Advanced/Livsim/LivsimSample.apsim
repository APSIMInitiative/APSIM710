<folder version="36" creator="Apsim 7.5-r3197" name="simulations">
  <simulation name="LivsimSample">
    <metfile name="met">
      <filename name="filename" input="yes">%apsim%/Examples/MetFiles/Dalby.met</filename>
    </metfile>
    <clock />
    <accum>
      <variable type="text" description="variable">rain[4]</variable>
    </accum>
    <summaryfile />
    <manager2 name="Area">
      <ui>
        <plot1 type="text" description="Name of plot 1">plot1</plot1>
        <plot1_area type="text" description="Area of plot 1">1.5</plot1_area>
        <plot2 type="text" description="Name of plot 2">plot2</plot2>
        <plot2_area type="text" description="Area of plot 2">1</plot2_area>
        <plot3 type="text" description="Name of plot 3">plot3</plot3>
        <plot3_area type="text" description="Area of plot 3">1</plot3_area>
        <verges type="text" description="Name of plot 4">verges</verges>
        <verges_area type="text" description="Area of plot 4">25</verges_area>
      </ui>
      <text>
using System;
using ModelFramework;

public class Script 
{      
   
   [Param, Output] string plot1;
   [Param, Output] double plot1_area;
   [Param, Output] string plot2;
   [Param, Output] double plot2_area;
   [Param, Output] string plot3;
   [Param, Output] double plot3_area;
   [Param, Output] string verges;
   [Param, Output] double verges_area;
   
}
       </text>
    </manager2>
    <tclmanager name="Crop Management">
      <rule name="Setup">
        <ui>
          <cat type="category" description="Paddock Descriptions" />
          <paddocks type="text" description="Paddocks">plot1 plot2 plot3</paddocks>
          <pasturePaddocks type="text" description="Paddocks">verges</pasturePaddocks>
        </ui>
        <script>
          <text>
set config(paddocks) [list [paddocks]]
set config(pasturePaddocks) [list [pasturePaddocks]]

for {set i 0} {$i &lt; [llength $config(paddocks)]} {incr i} {
  set config([lindex $config(paddocks) $i],area) [apsimGet [lindex $config(paddocks) $i]_area]
}

for {set i 0} {$i &lt; [llength $config(pasturePaddocks)]} {incr i} {
  set config([lindex $config(pasturePaddocks) $i],area) [apsimGet [lindex $config(pasturePaddocks) $i]_area]
}

# A list of crops in each paddock
set config(crops) [list maize peanut mucuna sorghum]

apsimRegisterGetSet config(paddocks)
foreach paddock $config(paddocks) {
  set config($paddock,initialState) F0
  set config($paddock,history) {}
  set config($paddock,graphNames) ${paddock}graph
  set state($paddock) {}
}

set simName [apsimGet title]</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Sow Maize">
        <ui>
          <category type="category" description="Sowing criteria" />
          <date1 type="ddmmmdate" description="Enter sowing window START date (dd-mmm) : ">15-jan</date1>
          <date2 type="ddmmmdate" description="Enter sowing window END date (dd-mmm) : ">15-feb</date2>
          <must_sow type="yesno" description="Must sow? : ">yes</must_sow>
          <raincrit type="text" description="Amount of rainfall : ">20</raincrit>
          <rainnumdays type="text" description="Number of days of rainfall : ">3</rainnumdays>
          <category type="category" description="Sowing parameters" />
          <crop type="crop" description="Enter name of crop to sow : ">maize</crop>
          <density type="text" description="Enter sowing density  (plants/m2) : ">4.4</density>
          <depth type="text" description="Enter sowing depth  (mm) : ">30</depth>
          <cultivar type="cultivars" description="Enter cultivar : ">sc501</cultivar>
          <class type="classes" description="Enter crop growth class : ">plant</class>
          <row_spacing type="text" description="Enter row spacing (mm) : ">750</row_spacing>
          <category2 type="category" description="Fertiliser parameters" />
          <fert_amt type="text" description="Amount of fertiliser">0</fert_amt>
          <fert_type type="text" description="Type of fertiliser">no3_n</fert_type>
          <category2 type="category" description="Economic parameters" />
          <cost type="text" description="Cost of sowing (seed) ($/ha)">0</cost>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <category2 type="category" description="Tillage parameters" />
          <presow_days type="text" description="Presow Tillage days before window">0</presow_days>
          <presowtill type="yesno" description="Presow Tillage operation">yes</presowtill>
          <sowtill type="yesno" description="Sowing Tillage operation">no</sowtill>
        </ui>
        <script>
          <text>
# Sow this crop
proc sow_Maize_crop {paddock} {
  apsimSendMessage $paddock.[crop] sow {plants [density]} {sowing_depth [depth]} {cultivar  [cultivar]} {row_spacing [row_spacing]} {crop_class  [class]}
}

proc sow_Maize {paddock} {
  global config

  if {"[presowtill]" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Maize_crop $paddock

  if {[fert_amt] &gt; 0} {
     apsimSendMessage $paddock.fertiliser apply {type [fert_type]} {amount [fert_amt]}
     apsimSendMessage economics expenditure {category fertilisercost} "name  [fert_type]" \
               "rate [fert_amt]" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type [fert_type]" \
               "fertiliser_rate [fert_amt]" {incrop_cost {}} "crop [crop]" \
               "comment Fertiliser"
  }
  doManure Maize $paddock

  if {"[sowtill]" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }

  apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  operateLabour "operator [operator]" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Maize {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin [date1] [date2]] } {
      if {( [apsimGet rain\[[rainnumdays]\]] &gt;= [raincrit] ) ||
          ( "[must_sow]" == "yes" &amp;&amp; [dateIs [date2]] ) } {
          return 1
      }
    }
  }
  return 0
}

# Return whether any crop in our paddock is not "out"
proc paddockIsFallow {paddock} {
   global config
   foreach crop $config(crops) {
      set status [apsimGetOptional $paddock.$crop.plant_status]
      if {$status != "" &amp;&amp; $status != "out"} {
         return 0
      }
   }
   return 1
}

##########Date functions (general)
proc dateWithin {t0 t1} {
   set year [apsimGet year]
   set d0 [date2day $t0 $year]
   set d1 [date2day $t1 $year]
   return [dayWithin $d0 $d1]
}

proc dateIs {t} {
   set d [date2day $t [apsimGet year]]
   return [dayIs $d]
}

proc dayWithin {t0 t1} {
   set t [apsimGet day]
   if {$t0 &gt; $t1} {
      return [expr $t &gt;= $t0 || $t &lt;= $t1]
   } else {
      return [expr $t &gt;= $t0 &amp;&amp; $t &lt;= $t1]
   }
   # notreached
}

proc dayIs {t} {
   return [expr $t == [apsimGet day]]
}

proc leapyr {y} {
   return [expr ($y%4 == 0) &amp;&amp; ($y%100 != 0) || ($y%400 == 0)]
}

proc date2day {date year} {
   foreach {mday month} [split $date "-"] {break}
   if {[leapyr $year]} {
      array set daysin {jan 0  feb 31 mar 58 apr 89 may 119 jun 150 jul 180 aug 211 sep 242 oct 272 nov 303 dec 333}
   } else {
      array set daysin {jan 0  feb 31 mar 59 apr 90 may 120 jun 151 jul 181 aug 212 sep 243 oct 273 nov 304 dec 334}
   }
   return [expr $mday + $daysin($month)]
}
</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Sow Groundnut">
        <ui>
          <category type="category" description="Sowing criteria" />
          <date1 type="ddmmmdate" description="Enter sowing window START date (dd-mmm) : ">15-jan</date1>
          <date2 type="ddmmmdate" description="Enter sowing window END date (dd-mmm) : ">15-feb</date2>
          <must_sow type="yesno" description="Must sow? : ">yes</must_sow>
          <raincrit type="text" description="Amount of rainfall : ">25</raincrit>
          <rainnumdays type="text" description="Number of days of rainfall : ">4</rainnumdays>
          <category type="category" description="Peanut sowing parameters" />
          <crop type="crop" description="Enter name of crop to sow : ">peanut</crop>
          <density type="text" description="Enter sowing density  (plants/m2) : ">2.8</density>
          <depth type="text" description="Enter sowing depth  (mm) : ">30</depth>
          <cultivar type="cultivars" description="Enter cultivar : ">early_bunch</cultivar>
          <class type="classes" description="Enter crop growth class : ">plant</class>
          <row_spacing type="text" description="Enter row spacing (mm) : ">750</row_spacing>
          <category2 type="category" description="Fertiliser parameters" />
          <fert_amt type="text" description="Amount of fertiliser">0</fert_amt>
          <fert_type type="text" description="Type of fertiliser">no3_n</fert_type>
          <category type="category" description="Economic parameters" />
          <cost type="text" description="Cost of Sowing ($/ha)">0</cost>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <category2 type="category" description="Tillage parameters" />
          <presow_days type="text" description="Presow Tillage days before window">0</presow_days>
          <presowtill type="yesno" description="Presow Tillage operation">no</presowtill>
          <sowtill type="yesno" description="Sowing Tillage operation">no</sowtill>
        </ui>
        <script>
          <text>
# Sow this crop
proc sow_Groundnut_crop {paddock} {
  apsimSendMessage $paddock.[crop] sow {plants [density]} {sowing_depth [depth]} {cultivar  [cultivar]} {row_spacing [row_spacing]} {crop_class  [class]}
}
proc sow_Groundnut {paddock} {
  global config

  if {"[presowtill]" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Groundnut_crop $paddock

  if {[fert_amt] &gt; 0} {
     apsimSendMessage $paddock.fertiliser apply {type [fert_type]} {amount [fert_amt]}
     apsimSendMessage economics expenditure {category fertilisercost} "name  [fert_type]" \
               "rate [fert_amt]" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type [fert_type]" \
               "fertiliser_rate [fert_amt]" {incrop_cost {}} "crop [crop]" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Groundnuts $paddock

  if {"[sowtill]" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator [operator]" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Groundnut {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin [date1] [date2]] } {
      if {( [apsimGet rain\[[rainnumdays]\]] &gt;= [raincrit] ) ||
          ( "[must_sow]" == "yes" &amp;&amp; [dateIs [date2]] ) } {
          return 1
      }
    }
  }
  return 0
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Sow Sorghum">
        <ui>
          <category type="category" description="Sowing criteria" />
          <date1 type="ddmmmdate" description="Enter sowing window START date (dd-mmm) : ">10-feb</date1>
          <date2 type="ddmmmdate" description="Enter sowing window END date (dd-mmm) : ">10-feb</date2>
          <must_sow type="yesno" description="Must sow? : ">yes</must_sow>
          <raincrit type="text" description="Amount of rainfall : ">25</raincrit>
          <rainnumdays type="text" description="Number of days of rainfall : ">3</rainnumdays>
          <category type="category" description="Peanut sowing parameters" />
          <crop type="crop" description="Enter name of crop to sow : ">sorghum</crop>
          <density type="text" description="Enter sowing density  (plants/m2) : ">8</density>
          <depth type="text" description="Enter sowing depth  (mm) : ">30</depth>
          <cultivar type="cultivars" description="Enter cultivar : ">Buster</cultivar>
          <row_spacing type="text" description="Enter row spacing (mm) : ">750</row_spacing>
          <category2 type="category" description="Fertiliser parameters" />
          <fert_amt type="text" description="Amount of fertiliser">0</fert_amt>
          <fert_type type="text" description="Type of fertiliser">no3_n</fert_type>
          <category type="category" description="Economic parameters" />
          <cost type="text" description="Cost of Sowing ($/ha)">0</cost>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <category2 type="category" description="Tillage parameters" />
          <presow_days type="text" description="Presow Tillage days before window">0</presow_days>
          <presowtill type="yesno" description="Presow Tillage operation">no</presowtill>
          <sowtill type="yesno" description="Sowing Tillage operation">no</sowtill>
        </ui>
        <script>
          <text>
# Sow this crop
proc sow_Sorghum_crop {paddock} {
  apsimSendMessage $paddock.[crop] sow {plants [density]} {sowing_depth [depth]} {cultivar  [cultivar]} {row_spacing [row_spacing]} {crop_class  [class]}
}
proc sow_Sorghum {paddock} {
  global config

  if {"[presowtill]" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Sorghum_crop $paddock

  if {[fert_amt] &gt; 0} {
     apsimSendMessage $paddock.fertiliser apply {type [fert_type]} {amount [fert_amt]}
     apsimSendMessage economics expenditure {category fertilisercost} "name  [fert_type]" \
               "rate [fert_amt]" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type [fert_type]" \
               "fertiliser_rate [fert_amt]" {incrop_cost {}} "crop [crop]" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Sorghum $paddock

  if {"[sowtill]" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator [operator]" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Sorghum {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin [date1] [date2]] } {
      if {( [apsimGet rain\[[rainnumdays]\]] &gt;= [raincrit] ) ||
          ( "[must_sow]" == "yes" &amp;&amp; [dateIs [date2]] ) } {
          return 1
      }
    }
  }
  return 0
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Sow Mucuna">
        <ui>
          <category type="category" description="Sowing criteria" />
          <date1 type="ddmmmdate" description="Enter sowing window START date (dd-mmm) : ">10-feb</date1>
          <date2 type="ddmmmdate" description="Enter sowing window END date (dd-mmm) : ">10-feb</date2>
          <must_sow type="yesno" description="Must sow? : ">yes</must_sow>
          <raincrit type="text" description="Amount of rainfall : ">25</raincrit>
          <rainnumdays type="text" description="Number of days of rainfall : ">4</rainnumdays>
          <category type="category" description="Peanut sowing parameters" />
          <crop type="crop" description="Enter name of crop to sow : ">mucuna</crop>
          <density type="text" description="Enter sowing density  (plants/m2) : ">2.8</density>
          <depth type="text" description="Enter sowing depth  (mm) : ">30</depth>
          <cultivar type="cultivars" description="Enter cultivar : ">mucuna_gen</cultivar>
          <class type="classes" description="Enter crop growth class : ">plant</class>
          <row_spacing type="text" description="Enter row spacing (mm) : ">750</row_spacing>
          <category2 type="category" description="Fertiliser parameters" />
          <fert_amt type="text" description="Amount of fertiliser">0</fert_amt>
          <fert_type type="text" description="Type of fertiliser">no3_n</fert_type>
          <category type="category" description="Economic parameters" />
          <cost type="text" description="Cost of Sowing ($/ha)">0</cost>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <category2 type="category" description="Tillage parameters" />
          <presow_days type="text" description="Presow Tillage days before window">0</presow_days>
          <presowtill type="yesno" description="Presow Tillage operation">no</presowtill>
          <sowtill type="yesno" description="Sowing Tillage operation">no</sowtill>
        </ui>
        <script>
          <text>
# Sow this crop
proc sow_Mucuna_crop {paddock} {
  apsimSendMessage $paddock.[crop] sow {plants [density]} {sowing_depth [depth]} {cultivar  [cultivar]} {row_spacing [row_spacing]} {crop_class  [class]}
}
proc sow_Mucuna {paddock} {
  global config

  if {"[presowtill]" == "yes"} {
     doTillageNow $paddock doPresowTillage
  }

  sow_Mucuna_crop $paddock

  if {[fert_amt] &gt; 0} {
     apsimSendMessage $paddock.fertiliser apply {type [fert_type]} {amount [fert_amt]}
     apsimSendMessage economics expenditure {category fertilisercost} "name  [fert_type]" \
               "rate [fert_amt]" "area $config($paddock,area)"  "paddock $paddock" "fertiliser_type [fert_type]" \
               "fertiliser_rate [fert_amt]" {incrop_cost {}} "crop [crop]" \
               "comment Fertiliser"
  }

  apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "sowing costs"}

  doManure Groundnuts $paddock

  if {"[sowtill]" == "yes"} {
     doTillageNow $paddock doSowingTillage
  }
  operateLabour "operator [operator]" "activity sowing"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"
  set config(season) "LR"
}

# Can we sow a crop?
proc canSow_Mucuna {paddock} {
  if {[paddockIsFallow $paddock]} {
    if {[dateWithin [date1] [date2]] } {
      if {( [apsimGet rain\[[rainnumdays]\]] &gt;= [raincrit] ) ||
          ( "[must_sow]" == "yes" &amp;&amp; [dateIs [date2]] ) } {
          return 1
      }
    }
  }
  return 0
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Manure">
        <ui>
          <cat type="category" description="Paddock Descriptions" />
          <cropsToManure type="text" description="Crops to manure">Maize</cropsToManure>
        </ui>
        <script>
          <text>
set config(manurecrops) [list [cropsToManure]]

proc doManure {crop paddock} {
   global config
   if {[lsearch $config(manurecrops) $crop] &gt;= 0} {
     apsimSet cows.manurepaddock  $paddock
     apsimSendMessage "cows" ApplyStoredManure
   }
}</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Harvest Maize">
        <ui>
          <category type="category" />
          <cropname type="text" description="Enter friendly name of crop: ">Maize</cropname>
          <crop type="crop" description="Enter apsim name of crop to harvest when ripe : ">maize</crop>
          <cost type="text" description="Cost of Harvesting ($/ha)">0</cost>
          <removed type="text" description="%age of residues removed (0-100)">0</removed>
          <grazed type="text" description="%age of residues grazed in situ (0-100)">0</grazed>
          <stored type="text" description="%age of residues stored for feed (0-100)">100</stored>
          <left type="text" description="%age of residues left for fertility (0-100)">0</left>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
        </ui>
        <script>
          <text>

if {[expr [removed]+[grazed]+[stored]+[left]] != 100} {error "[crop] harvest residue fractions dont add to 100%"}

proc harvest_[cropname] {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator [operator]" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.[crop].yield]/1000.0]
   set biomass [apsimGet $paddock.[crop].biomass]
   if {"[crop]" == "sorghum" } {
     set grainWt [apsimGet $paddock.[crop].graingreenWt]
     if {$grainWt &gt; 0} {
       set grainN [apsimGet $paddock.[crop].graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.[crop].LeafGreenWt] + \
                       [apsimGet $paddock.[crop].LeafSenescedWt] + \
                       [apsimGet $paddock.[crop].StemGreenWt] ) ]
     if {$stover &gt; 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.[crop].LeafGreenN] + \
                                [apsimGet $paddock.[crop].LeafSenescedN] + \
                                [apsimGet $paddock.[crop].StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"[crop]" == "maize"} {
     set grainProtein [apsimGet $paddock.[crop].grain_protein] ;# (%)
     set stover [expr [apsimGet $paddock.[crop].stover_wt] * 10.0 ]
     if {$stover &gt; 0} {
        set stoverProtein [expr ([apsimGet $paddock.[crop].stover_n] * 10.0) / $stover * 100.0 * 5.71]
     } else {
        set stoverProtein 0.0
     }
   } else {
     set grainProtein [expr [apsimGet $paddock.[crop].grainN] / \
                            [apsimGet $paddock.[crop].grainWt] * 100.0 * 5.71] ;# (%)
     set stover [expr ($biomass - $yield) ]
     set stoverProtein [expr [apsimGet $paddock.[crop].vegetativeN] / \
                             [apsimGet $paddock.[crop].vegetativeWt]* 100.0 * 5.71]
   }

   apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name [crop]"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop [crop]" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.[crop]  harvest  "remove 0.0"
   apsimSendMessage $paddock.[crop]  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {[grazed] &gt; 0} {
      set grazedFrac [expr [grazed] / 100.0]
   }
   set storedFrac 0.0
   if {[stored] &gt; 0} {
      set storedFrac [expr [stored] / 100.0]
      apsimSet [cropname]_residue_store.store [expr [apsimGet [cropname]_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + [removed]) / 100.0]
   if {$removedFrac &gt; 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,[crop],harvest)]} {
     set annual($year,[crop],harvest) [expr $annual($year,[crop],harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,[crop],harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop] \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop]_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],[crop],\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_[cropname] {paddock} {
  return [expr [string equal [apsimGet $paddock.[crop].StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.[crop].plant_status] "dead"]]
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Harvest Groundnut">
        <ui>
          <category type="category" />
          <cropname type="text" description="Enter friendly name of crop: ">Groundnut</cropname>
          <crop type="crop" description="Enter apsim name of crop to harvest when ripe : ">peanut</crop>
          <cost type="text" description="Cost of Harvesting ($/ha)">0</cost>
          <removed type="text" description="%age of residues removed (0-100)">0</removed>
          <grazed type="text" description="%age of residues grazed in situ (0-100)">0</grazed>
          <stored type="text" description="%age of residues stored for feed (0-100)">100</stored>
          <left type="text" description="%age of residues left for fertility (0-100)">0</left>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
        </ui>
        <script>
          <text>

if {[expr [removed]+[grazed]+[stored]+[left]] != 100} {error "[crop] harvest residue fractions dont add to 100%"}

proc harvest_[cropname] {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator [operator]" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.[crop].yield]/1000.0]  ;# tonnes/ha
   set biomass [apsimGet $paddock.[crop].biomass]
   if {"[crop]" == "sorghum" } {
     set grainWt [apsimGet $paddock.[crop].graingreenWt]
     if {$grainWt &gt; 0} {
       set grainN [apsimGet $paddock.[crop].graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.[crop].LeafGreenWt] + \
                       [apsimGet $paddock.[crop].LeafSenescedWt] + \
                       [apsimGet $paddock.[crop].StemGreenWt] ) ]
     if {$stover &gt; 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.[crop].LeafGreenN] + \
                                [apsimGet $paddock.[crop].LeafSenescedN] + \
                                [apsimGet $paddock.[crop].StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } else {
     set grainWt [apsimGet $paddock.[crop].grainWt]
     if {$grainWt &gt; 0} {
       set grainProtein [expr [apsimGet $paddock.[crop].grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
       set stover [expr ($biomass - 1000* $yield) ]
       set stoverProtein [expr [apsimGet $paddock.[crop].vegetativeN] / \
                             [apsimGet $paddock.[crop].vegetativeWt]* 100.0 * 5.71]
     } else {
       set stover 0.0
       set stoverProtein 0.0
       set grainProtein 0.0
     }
   }

   apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name [crop]"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop [crop]" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.[crop]  harvest  "remove 0.0"
   apsimSendMessage $paddock.[crop]  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {[grazed] &gt; 0} {
      set grazedFrac [expr [grazed] / 100.0]
   }
   set storedFrac 0.0
   if {[stored] &gt; 0} {
      set storedFrac [expr [stored] / 100.0]
      apsimSet [cropname]_residue_store.store [expr [apsimGet [cropname]_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + [removed]) / 100.0]
   if {$removedFrac &gt; 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,[crop],harvest)]} {
     set annual($year,[crop],harvest) [expr $annual($year,[crop],harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,[crop],harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop] \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop]_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],[crop],\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_[cropname] {paddock} {
  return [expr [string equal [apsimGet $paddock.[crop].StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.[crop].plant_status] "dead"]]
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Harvest Sorghum">
        <ui>
          <category type="category" />
          <cropname type="text" description="Enter friendly name of crop: ">Sorghum</cropname>
          <crop type="crop" description="Enter apsim name of crop to harvest when ripe : ">sorghum</crop>
          <cost type="text" description="Cost of Harvesting ($/ha)">0</cost>
          <removed type="text" description="%age of residues removed (0-100)">0</removed>
          <grazed type="text" description="%age of residues grazed in situ (0-100)">0</grazed>
          <stored type="text" description="%age of residues stored for feed (0-100)">0</stored>
          <left type="text" description="%age of residues left for fertility (0-100)">100</left>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
        </ui>
        <script>
          <text>

if {[expr [removed]+[grazed]+[stored]+[left]] != 100} {error "[crop] harvest residue fractions dont add to 100%"}

proc harvest_[cropname] {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator [operator]" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.[crop].yield]/1000.0]
   set biomass [apsimGet $paddock.[crop].biomass]
   if {"[crop]" == "sorghum"} {
     set grainWt [apsimGet $paddock.[crop].graingreenWt]
     if {$grainWt &gt; 0} {
       set grainN [apsimGet $paddock.[crop].graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.[crop].LeafGreenWt] + \
                       [apsimGet $paddock.[crop].LeafSenescedWt] + \
                       [apsimGet $paddock.[crop].StemGreenWt] ) ]
     if {$stover &gt; 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.[crop].LeafGreenN] + \
                                [apsimGet $paddock.[crop].LeafSenescedN] + \
                                [apsimGet $paddock.[crop].StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"[crop]" == "maize"} {
     set grainProtein [apsimGet $paddock.[crop].grain_protein]        ;# (%)
     set stover [apsimGet $paddock.[crop].stover]
     set stoverProtein [expr [apsimGet $paddock.[crop].stover_n] / \
                             [apsimGet $paddock.[crop].stover_wt] * 100.0 * 5.71] ;# (%)
   } else {
     set grainWt [apsimGet $paddock.[crop].grainWt]
     if {$grainWt &gt; 0} {
       set grainProtein [expr [apsimGet $paddock.[crop].grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ($biomass - $yield) ]
     set stoverProtein [expr [apsimGet $paddock.[crop].vegetativeN] / \
                             [apsimGet $paddock.[crop].vegetativeWt]* 100.0 * 5.71]
   }

   apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name [crop]"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop [crop]" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.[crop]  harvest  "remove 0.0"
   apsimSendMessage $paddock.[crop]  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {[grazed] &gt; 0} {
      set grazedFrac [expr [grazed] / 100.0]
   }
   set storedFrac 0.0
   if {[stored] &gt; 0} {
      set storedFrac [expr [stored] / 100.0]
      apsimSet [cropname]_residue_store.store [expr [apsimGet [cropname]_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + [removed]) / 100.0]
   if {$removedFrac &gt; 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,[crop],harvest)]} {
     set annual($year,[crop],harvest) [expr $annual($year,[crop],harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,[crop],harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop] \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop]_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],[crop],\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_[cropname] {paddock} {
  return [expr [string equal [apsimGet $paddock.[crop].StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.[crop].plant_status] "dead"]]
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Harvest Mucuna">
        <ui>
          <category type="category" />
          <cropname type="text" description="Enter friendly name of crop: ">Mucuna</cropname>
          <crop type="crop" description="Enter apsim name of crop to harvest when ripe : ">mucuna</crop>
          <cost type="text" description="Cost of Harvesting ($/ha)">0</cost>
          <removed type="text" description="%age of residues removed (0-100)">0</removed>
          <grazed type="text" description="%age of residues grazed in situ (0-100)">0</grazed>
          <stored type="text" description="%age of residues stored for feed (0-100)">100</stored>
          <left type="text" description="%age of residues left for fertility (0-100)">0</left>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
        </ui>
        <script>
          <text>

if {[expr [removed]+[grazed]+[stored]+[left]] != 100} {error "[crop] harvest residue fractions dont add to 100%"}

proc harvest_[cropname] {paddock} {
   global config daysSinceLastHarvest
   set somWtOld [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]

   operateLabour "operator [operator]" "activity harvesting"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost"

   set yield [expr [apsimGet $paddock.[crop].yield]/1000.0]  ;# tonnes/ha
   set biomass [apsimGet $paddock.[crop].biomass]
   if {"[crop]" == "sorghum"} {
     set grainWt [apsimGet $paddock.[crop].graingreenWt]
     if {$grainWt &gt; 0} {
       set grainN [apsimGet $paddock.[crop].graingreenN]
       set grainProtein [expr $grainN / $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ([apsimGet $paddock.[crop].LeafGreenWt] + \
                       [apsimGet $paddock.[crop].LeafSenescedWt] + \
                       [apsimGet $paddock.[crop].StemGreenWt] ) ]
     if {$stover &gt; 0.0} {
       set stoverProtein [expr ([apsimGet $paddock.[crop].LeafGreenN] + \
                                [apsimGet $paddock.[crop].LeafSenescedN] + \
                                [apsimGet $paddock.[crop].StemGreenN]) / \
                               $stover * 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
     set stover [expr 10 * $stover]
   } elseif {"[crop]" == "maize"} {
     set grainProtein [apsimGet $paddock.[crop].grain_protein]        ;# (%)
     set stover [apsimGet $paddock.[crop].stover]
     set stoverProtein [expr [apsimGet $paddock.[crop].stover_n] / \
                             [apsimGet $paddock.[crop].stover_wt] * 100.0 * 5.71] ;# (%)
   } else {
     set grainWt [apsimGet $paddock.[crop].grainWt]
     if {$grainWt &gt; 0} {
       set grainProtein [expr [apsimGet $paddock.[crop].grainN] / \
                            $grainWt * 100.0 * 5.71] ;# (%)
     } else {
       set grainProtein 0.0
     }
     set stover [expr ($biomass - 1000 * $yield) ]
     if {[apsimGet $paddock.[crop].vegetativeWt] &gt; 0 } {
       set stoverProtein [expr [apsimGet $paddock.[crop].vegetativeN] / \
                               [apsimGet $paddock.[crop].vegetativeWt]* 100.0 * 5.71]
     } else {
       set stoverProtein 0.0
     }
   }

   apsimSendMessage economics expenditure \
                   "cost [expr [cost] * $config($paddock,area)]" \
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "harvesting costs"}

   apsimSendMessage economics income {category cropprice} "name [crop]"  \
                          "yield $yield" \
                          "area $config($paddock,area)" "paddock $paddock" "crop [crop]" \
                          "SW_state [apsimGet $config($paddock,watBal).esw]" \
                          "NO3_state [apsimGet $config($paddock,nModule).no3()]"

   apsimSendMessage $paddock.[crop]  harvest  "remove 0.0"
   apsimSendMessage $paddock.[crop]  end_crop

   set somWtNew [apsimGet "$paddock.SurfaceOrganicMatter.surfaceom_wt"]
   set somAdded [expr $somWtNew - $somWtOld]

   set daysSinceLastHarvest($paddock) 0

   set grazedFrac 0.0
   if {[grazed] &gt; 0} {
      set grazedFrac [expr [grazed] / 100.0]
   }
   set storedFrac 0.0
   if {[stored] &gt; 0} {
      set storedFrac [expr [stored] / 100.0]
      apsimSet [cropname]_residue_store.store [expr [apsimGet [cropname]_residue_store.store] + $storedFrac * $stover * $config($paddock,area)]
   }
   set removedFrac [expr ($storedFrac + [removed]) / 100.0]
   if {$removedFrac &gt; 0} {
      apsimWriteToSummaryFile "Residues: removing [expr $removedFrac] of surface residues in paddock $paddock"
      apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type user_defined} "f_incorp $removedFrac" {tillage_depth 0.0}
   }

   global annual
   set year [apsimGet year]
   set wetYield [expr ($yield * 100.0) / (100.0 - 12.0)] ;# 12% grain moisture
   if {[info exists annual($year,[crop],harvest)]} {
     set annual($year,[crop],harvest) [expr $annual($year,[crop],harvest) + $wetYield * $config($paddock,area)]
   } else {
     set annual($year,[crop],harvest)  [expr $wetYield * $config($paddock,area)]
   }
   global harvest iat
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop] \
      [format %.0f $biomass] [format %.0f [expr 1000.0 * $yield]] [format %.1f $grainProtein]]
   lappend harvest [list [apsimGet dd/mm/yyyy] $config(season) $paddock [crop]_residue \
      [format %.0f $biomass] [format %.0f $stover] [format %.1f $stoverProtein]]
   lappend iat [list [apsimGet dd/mm/yyyy],[crop],\
[format %.0f $biomass],[format %.0f [expr 1000.0 * $yield]],[format %.1f $grainProtein],\
[format %.0f $stover],[format %.1f $stoverProtein]]
}

proc canHarvest_[cropname] {paddock} {
  return [expr [string equal [apsimGet $paddock.[crop].StageName] "harvest_ripe"] || \
               [string equal [apsimGet $paddock.[crop].plant_status] "dead"]]
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Weeds">
        <ui>
          <max_germinations type="text" description="Maximum weed germinations / year">0</max_germinations>
          <daysToGerm type="text" description="Days from tillage to germination">20</daysToGerm>
          <weedDensity type="text" description="Seedling density (plants/m2)">20</weedDensity>
        </ui>
        <script>
          <text>
proc checkWeeds {} {
   global daysSinceLastTillage weeds config
   set rainCrit [apsimGet rain\[4\]]

   foreach paddock $config(paddocks) {
      incr daysSinceLastTillage($paddock)
      set weeds($paddock,status) [apsimGet $paddock.weed.plant_status]
      if {$daysSinceLastTillage($paddock) &gt; [daysToGerm] &amp;&amp;
          $weeds($paddock,status) == "out" &amp;&amp;
          $rainCrit &gt;= 25 &amp;&amp;
          $weeds($paddock,Events) &lt; [max_germinations]} {
           apsimWriteToSummaryFile "Weeds germinating in $paddock"
           apsimSendMessage $paddock.weed sow {crop_class summer_grass} {plants [weedDensity]} {sowing_depth 75} {cultivar early} {row_spacing 750}
           incr weeds($paddock,Events)
      } elseif {$weeds($paddock,status) == "dead" || [apsimGet $paddock.weed.StageName] == "harvest_ripe"} {
           killWeeds $paddock
      }
   }
}

proc killWeeds {paddock} {
   global weeds daysSinceLastTillage annual
   apsimWriteToSummaryFile "Killing weeds in $paddock"
   if {$weeds($paddock,status) != "out"} {
     apsimSendMessage $paddock.weed end_crop
   }
   set weeds($paddock,status) "out"
   set annual($paddock,weedings) [expr $annual($paddock,weedings) + 1.0]
   set daysSinceLastTillage($paddock) 0
}</text>
          <event>init</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
   set weeds($paddock,GermDay) {}
   set weeds($paddock,Events)  0
   set daysSinceLastTillage($paddock)    0
}</text>
          <event>start_simulation</event>
        </script>
        <script>
          <text>
checkWeeds
</text>
          <event>prepare</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
   set weeds($paddock,Events)  0
}</text>
          <event>end_year</event>
        </script>
      </rule>
      <rule name="Fallow Tillage">
        <ui>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <activity type="text" description="The operator activity : ">weeding</activity>
          <category type="category" description="Crop" />
          <dah type="text" description="Days after harvest">40</dah>
          <category type="category" description="Tillage" />
          <tillage_type type="list" listvalues="user_defined, chisel, disc, planter, burn, burn_90, graze, scarifier, rip, blade, tine" description="Tillage type : ">user_defined</tillage_type>
          <tillage_depth type="text" description="User_defined depth of seedbed preparation (mm) : ">100</tillage_depth>
          <tillage_f_incorp type="text" description="User_defined fraction of surface residues to incorporate (0-1): ">0.9</tillage_f_incorp>
        </ui>
        <script>
          <text>

proc doFallowTillage[dah] {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "[tillage_type]" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]} {f_incorp [tillage_f_incorp]} {tillage_depth [tillage_depth]}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]}
   }
   set daysSinceLastTillage($paddock) 0
}

proc doTillageSometime {paddock operator activity routine} {
   global config
   operateLabour "operator $operator" "activity $activity" \
                 "area $config($paddock,area)" "callback [list $routine $paddock]" \
                 "paddock $paddock" "costtype incrop_cost" {comment "Fallow tillage"}

}

proc doTillageNow {paddock routine} {
   $routine $paddock
}
</text>
          <event>init</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
   if {$daysSinceLastHarvest($paddock) == [dah]} {
      doTillageSometime $paddock [operator] [activity] doFallowTillage[dah]
   }
}
</text>
          <event>prepare</event>
        </script>
      </rule>
      <rule name="Incrop Tillage 1">
        <ui>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <activity type="text" description="The operator activity : ">weeding</activity>
          <category type="category" description="Crop" />
          <crop type="text" description="Which crop is tilled">maize</crop>
          <das type="text" description="Days after sowing">21</das>
          <category type="category" description="Tillage" />
          <tillage_type type="list" listvalues="user_defined, chisel, disc, planter, burn, burn_90, graze, scarifier, rip, blade, tine" description="Tillage type : ">user_defined</tillage_type>
          <tillage_depth type="text" description="User_defined depth of seedbed preparation (mm) : ">100</tillage_depth>
          <tillage_f_incorp type="text" description="User_defined fraction of surface residues to incorporate (0-1): ">0.9</tillage_f_incorp>
        </ui>
        <script>
          <text>

proc doIncropTillage[das] {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "[tillage_type]" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]} {f_incorp [tillage_f_incorp]} {tillage_depth [tillage_depth]}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]}
   }
   set daysSinceLastTillage($paddock) 0
}</text>
          <event>init</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
   if {[apsimGetOptional $paddock.[crop].DaysAfterSowing] == [das]} {
      doTillageSometime $paddock [operator] [activity] doIncropTillage[das]
   }
}
</text>
          <event>post</event>
        </script>
      </rule>
      <rule name="Incrop Tillage 2">
        <ui>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <activity type="text" description="The operator activity : ">weeding</activity>
          <category type="category" description="Crop" />
          <crop type="text" description="Which crop is tilled">maize</crop>
          <das type="text" description="Days after sowing">45</das>
          <category type="category" description="Tillage" />
          <tillage_type type="list" listvalues="user_defined, chisel, disc, planter, burn, burn_90, graze, scarifier, rip, blade, tine" description="Tillage type : ">user_defined</tillage_type>
          <tillage_depth type="text" description="User_defined depth of seedbed preparation (mm) : ">100</tillage_depth>
          <tillage_f_incorp type="text" description="User_defined fraction of surface residues to incorporate (0-1): ">0.9</tillage_f_incorp>
        </ui>
        <script>
          <text>

proc doIncropTillage[das] {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "[tillage_type]" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]} {f_incorp [tillage_f_incorp]} {tillage_depth [tillage_depth]}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]}
   }

   set daysSinceLastTillage($paddock) 0
}</text>
          <event>init</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
   if {[apsimGetOptional $paddock.[crop].DaysAfterSowing] == [das]} {
      doTillageSometime $paddock [operator] [activity] doIncropTillage[das]
   }
}</text>
          <event>post</event>
        </script>
      </rule>
      <rule name="Presow Tillage">
        <ui>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <activity type="text" description="The operator activity : ">presow_till</activity>
          <category type="category" description="Tillage" />
          <tillage_type type="list" listvalues="user_defined, chisel, disc, planter, burn, burn_90, graze, scarifier, rip, blade, tine" description="Tillage type : ">user_defined</tillage_type>
          <tillage_depth type="text" description="User_defined depth of seedbed preparation (mm) : ">100</tillage_depth>
          <tillage_f_incorp type="text" description="User_defined fraction of surface residues to incorporate (0-1): ">0.9</tillage_f_incorp>
        </ui>
        <script>
          <text>

proc doPresowTillage {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "[tillage_type]" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]} {f_incorp [tillage_f_incorp]} {tillage_depth [tillage_depth]}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]}
   }

   operateLabour "operator [operator]" "activity [activity]"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "Pre sowing tillage"}
   set daysSinceLastTillage($paddock) 0
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Sowing Tillage">
        <ui>
          <category type="category" description="Labour" />
          <operator type="text" description="The operator : ">male</operator>
          <activity type="text" description="The operator activity : ">sowing</activity>
          <category type="category" description="Tillage" />
          <tillage_type type="list" listvalues="user_defined, chisel, disc, planter, burn, burn_90, graze, scarifier, rip, blade, tine" description="Tillage type : ">user_defined</tillage_type>
          <tillage_depth type="text" description="User_defined depth of seedbed preparation (mm) : ">100</tillage_depth>
          <tillage_f_incorp type="text" description="User_defined fraction of surface residues to incorporate (0-1): ">0.1</tillage_f_incorp>
        </ui>
        <script>
          <text>

proc doSowingTillage {paddock} {
   global config daysSinceLastTillage

   killWeeds $paddock
   if {[string equal "[tillage_type]" "user_defined"]} {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]} {f_incorp [tillage_f_incorp]} {tillage_depth [tillage_depth]}
   } else {
       apsimSendMessage "$paddock.SurfaceOrganicMatter" tillage {type [tillage_type]}
   }

   operateLabour "operator [operator]" "activity [activity]"\
                   "area $config($paddock,area)" \
                   "paddock $paddock" "costtype incrop_cost" {comment "Sowing tillage"}
   set daysSinceLastTillage($paddock) 0
}

</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Farm logic">
        <ui>
          <cat type="category" description="No editable parameters" />
        </ui>
        <script>
          <text>
# Return area (ha) planted to a crop
proc areaOf {crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set sum 0.0
   foreach paddock $config(cropPaddocks) {
      set state [currentState $paddock]
      if {[info exists config($state,alias)]} {set state $config($state,alias)}
      if {"$state" == "$crop"} {
        set sum [expr $sum + $config($paddock,area)]
      }
   }
   return $sum
}

proc areaPlantedOk {crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set f [expr [areaOf $crop] / $config(allCropArea)]

   return [expr $f &lt; $config(maxFract,$crop)]
}

proc historyOk {paddock crop} {
   global config
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   set max $config(maxContinuous,$crop)
   set n [llength $config($paddock,history)]
   for {set i $n} {$i &gt;= $n - $max} {decr i} {
      if {[lindex $config($paddock,history)] != $crop} {return 1}
   }
   return 0
}



########### Support procedures

proc max {a b} { return [expr {($a &gt; $b) ? $a : $b}] }
proc min {a b} { return [expr {($a &gt; $b) ? $b : $a}] }

# Return the current state of the system
proc currentState {paddock} {
   global state
   return $state($paddock)
}

# Gather arguments (eg sowing depth, fert rate etc} from defaults array
# $action: the operation (sow, fert ...
# $what: the module (wheat, sorghum ...
proc gatherArgs {action what} {
   global defaults config

   # 1. "sow,..."
   foreach {index value} [array get defaults $action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 2. override above with any "wheat,sow,..."
   foreach {index value} [array get defaults $what,$action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 3. override above with any "SpringWheat,sow,..."
   if {[info exists config($what,alias)]} {
      foreach {index value} [array get defaults $config($what,alias),$action,*] {
         set args([lindex [split $index ","] end]) $value
      }
   }
   return [array get args]
}

# Mash a list into name/value pairs to pass via the apsim message system
proc mash {list} {
   set result {}
   foreach {name value} $list {lappend result [list $name $value]}
   return $result
}

# Sum a list
proc lsum {list} {
   set result 0.0
   foreach value $list {set result [expr $result + $value]}
   return $result
}

# Linear interpolation
proc linint {x_coords y_coords value} {
   set y  0.0

   if {[llength $x_coords] &lt;= 0 || [llength $y_coords] &lt;= 0 || [llength $x_coords] != [llength $y_coords]} {
      error "bad coordinates in linear_interp_real"
   }

   for {set indx 0} {$indx &lt; [llength $x_coords]} {incr indx} {
      if {$value &lt;= [lindex $x_coords $indx]} {
         if {$indx == 0} {
            set y [lindex $y_coords $indx]
         } else {
            if {abs($value - [lindex $x_coords $indx]) &lt; 1.0E-4} {
               set y [lindex $y_coords $indx]
            } else  {
               set y_part [expr [lindex $y_coords $indx] - [lindex $y_coords [expr $indx-1]] ]
               set x_part [expr [lindex $x_coords $indx] - [lindex $x_coords [expr $indx-1]] ]
               set y [expr ($y_part/$x_part) * ($value - [lindex $x_coords [expr $indx - 1]]) + [lindex $y_coords [expr $indx- 1]] ]
            }
         break;
         }
      } elseif {$indx == [lindex $x_coords $indx]-1} {
         set y  [lindex $y_coords $indx]
      } else {
         set y  0.0
      }
   }
   return $y
}

#############################
############### The decision routine(s).
#############################
# Return the score for planting "what"
proc checkRules {thisPaddock} {
  global config

  uplevel #0 set paddock \"$thisPaddock\"
  set bestScore -1.0; set bestTarget {}; set bestArc {}; set bestGraph {}
  foreach graph $config($thisPaddock,graphNames) {
     foreach arc [$graph arcs -out [currentState $thisPaddock]] {
        set expr {}
        set target [$graph arc target $arc]
        foreach rule [$graph arc get $arc rules] {
           set value [uplevel #0 expr $rule]
           lappend expr $value
           if {$value == 0} {break} ;# no need to continue evaluating subsequent rules
        }
        if {[llength $expr] &gt; 0} {
           set score [expr [join $expr "*"]]
           if {$score &gt; $bestScore} {
              set bestScore  $score
              set bestTarget $target
              set bestArc    $arc
              set bestGraph  $graph
           }
        }
     }
  }
  return [list  $bestScore $bestGraph $bestTarget $bestArc]
}

# A place holder function to monitor state transitions
proc logState {graph paddock state} {
  ###puts "$graph $paddock $state"
}

# Change state to another
proc changeState {paddock graph arc} {
   global state
   uplevel #0 set paddock \"$paddock\"
   puts "$graph - Changing state in paddock $paddock from $state($paddock) to [$graph arc target $arc]"
   if {[$graph arc keyexists $arc actions]} {
      foreach action [$graph arc get $arc actions] {
         puts "      - undertaking action $action"
         uplevel #0 $action
      }
   }
   set state($paddock) [$graph arc target $arc]
   logState $graph $paddock $state($paddock)
}

# Do daily process at top level
proc doProcess {} {
   global date config daysSinceLastHarvest

   set date "[apsimGet day],[apsimGet year]"

   set more 1
   while {$more} {
      set more 0
      # 1. Find out what's possible
      set bestPaddock {}; set bestScore -1.0
      foreach paddock $config(paddocks) {
         foreach {score graph target arc} [checkRules $paddock] {break}
         if {$score &gt; $bestScore} {
            set bestPaddock $paddock; set bestScore $score; set bestGraph $graph; set bestTarget $target; set bestArc $arc
         }
      }
      if {$bestScore &gt; 0.0} {
         changeState $bestPaddock $bestGraph $bestArc
         set more 1
      }
   }

   foreach paddock $config(paddocks) {
      incr daysSinceLastHarvest($paddock)
   }
}

# pass events to various output files
proc reportEvent {from what} {
   foreach {event args} [split $what "-"] {break}
}

puts "Done farm"
</text>
          <event>init</event>
        </script>
        <script>
          <text>
# Housekeeping
if {[catch {doProcess } msg]} {
   puts "$errorInfo"
   error "$msg\n$errorInfo"
}

</text>
          <event>process</event>
        </script>
        <script>
          <text>
          </text>
          <event>end_simulation</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {
  set state($paddock)         $config($paddock,initialState) ;# Should get this from xml
  set history($paddock)       $config($paddock,history)
  set daysSinceLastHarvest($paddock) 60
}

# All our soils are called "Soil.."
foreach paddock $config(paddocks) {
   set config($paddock,watBal)   "$paddock.Soil Water"
   set config($paddock,nModule)  "$paddock.Soil Nitrogen"
}

set config(states) {}

</text>
          <event>start_simulation</event>
        </script>
      </rule>
      <rule name="Crop Management">
        <ui>
          <category type="category" description="Crop Sequence" />
          <sequences type="text" description="sequences">plot1 Maize plot2 Groundnut plot3 Mucuna</sequences>
          <lr_start type="text" description="Start of LR season">15-mar</lr_start>
          <lr_end type="text" description="end of LR season">14-sep</lr_end>
          <sr_start type="text" description="Start of SR season">15-sep</sr_start>
          <sr_end type="text" description="end of SR season">14-mar</sr_end>
          <do_reset type="yesno" description="Reset SW at start of LR">no</do_reset>
        </ui>
        <script>
          <text>
package require struct
foreach {paddock sequence} {[sequences]} {
   ::struct::graph ${paddock}graph
   set states [split $sequence "."]
   for {set istate 0} {$istate &lt; [llength $states]} {incr istate} { ${paddock}graph node insert "F$istate" }
   for {set istate 0} {$istate &lt; [llength $states]} {incr istate} {
     set myState [lindex $states $istate].$istate
     ${paddock}graph node insert $myState
     ${paddock}graph arc insert F$istate $myState "arc$istate"
     if {[lindex $states $istate] == "SR_X" } {
       ${paddock}graph arc lappend "arc$istate" rules "\[dateIs [sr_end]\]"
     } elseif {[lindex $states $istate] == "LR_X"} {
       ${paddock}graph arc lappend "arc$istate" rules "\[dateIs [lr_end]\]"
     } else {
       ${paddock}graph arc lappend "arc$istate" actions "sow_[lindex $states $istate] $paddock"
       ${paddock}graph arc lappend "arc$istate" rules "\[canSow_[lindex $states $istate] $paddock \]"
       ${paddock}graph arc lappend "arc$istate" rules "\$daysAfterHarvest(\$paddock) &gt; 1"
     }
     if {$istate == [llength $states] - 1} {
        ${paddock}graph arc insert $myState F0 "arc${istate}Out"
     } else {
        ${paddock}graph arc insert $myState F[expr $istate+1] "arc${istate}Out"
     }
     if {[lindex $states $istate] == "LR_X" || [lindex $states $istate] == "SR_X"} {
       ${paddock}graph arc lappend "arc${istate}Out" rules "1"
     } else {
       ${paddock}graph arc lappend "arc${istate}Out" actions "harvest_[lindex $states $istate] $paddock"
       ${paddock}graph arc lappend "arc${istate}Out" actions "set daysAfterHarvest(\$paddock) 0"
       ${paddock}graph arc lappend "arc${istate}Out" rules "\[canHarvest_[lindex $states $istate] $paddock \]"
     }
   }
   puts "Paddock $paddock cropping sequence:"
   foreach node [${paddock}graph nodes] {
     puts " Node $node"
     foreach key [${paddock}graph node keys $node *] {
       puts " $key: [${paddock}graph node get $node $key]"
     }
     foreach arc [${paddock}graph arcs -out $node] {
       foreach key [${paddock}graph arc keys $arc *] {
          puts " $arc:$key [${paddock}graph arc get $arc $key]"
       }
     }
   }
}

foreach paddock $config(paddocks) {set daysAfterHarvest($paddock) 30}

</text>
          <event>init</event>
        </script>
        <script>
          <text>
if {[dateIs [lr_start]]} {
   if {"[do_reset]" == "yes"} {
      foreach paddock $config(paddocks) {
         apsimSendMessage $config($paddock,watBal) reset
         apsimSendMessage $config($paddock,nModule) reset
      }
   }
   apsimSendMessage "" lr_start
}
if {[dateIs [lr_end]]} {
  apsimSendMessage "" lr_end
}
</text>
          <event>prepare</event>
        </script>
        <script>
          <text>
foreach paddock $config(paddocks) {incr daysAfterHarvest($paddock)}
          </text>
          <event>post</event>
        </script>
      </rule>
      <rule name="Annual Reports">
        <ui>
          <category type="category" description="No editable paramters" />
        </ui>
        <script>
          <text>
# Utilities
proc lsum {list} {return [expr  [join $list "+"]]}
proc lavg {list} {
  if {[llength $list] &gt; 0} {
    return [expr [lsum $list] / [llength $list]]
  }
  return 0.0
}

# Annual summary of whole farm averages

proc open_annual_stuff {} {
   global annual annualcrop config
   set year [expr [apsimGet year] - 1 ]
   set annual(years) $year
   set annual(accRain) 0.0
   set annual($year,balance) [apsimGetOptional balance]
   set annual($year,income) [apsimGetOptional income]
   set annual($year,expenditure) [apsimGetOptional expenditure]
   foreach {accumulator} { dm_eaten} {
     set annual($year,$accumulator) 0
   }
   foreach {accumulator} {runoff drain soil_loss es weedings} {
     foreach paddock $config(paddocks) {
        set annual($paddock,$accumulator) 0.0
     }
   }
}

proc do_end_year {} {
   global config annual annualcrop

   set year [apsimGet year]

   foreach {accumulator} {runoff drain soil_loss es weedings} {
     foreach paddock $config(paddocks) {
        set annual($year,$paddock,$accumulator) $annual($paddock,$accumulator)
        set annual($paddock,$accumulator) 0.0
     }
   }
   foreach paddock $config(paddocks) {
     set annual($year,$paddock,avg_cover) [apsimGetOptional "$paddock.tracker.avg_cover"]
     if {$annual($year,$paddock,avg_cover) == ""} {set annual($year,$paddock,avg_cover) "*"}

     set annual($year,$paddock,avg_carbon) [apsimGetOptional "$paddock.tracker.avg_carbon"]
     if {$annual($year,$paddock,avg_carbon) == ""} {set annual($year,$paddock,avg_carbon) "*"}
   }
   set annual($year,accRain) $annual(accRain)
   set annual(accRain) 0.0
   set annual($year,balance) [apsimGetOptional balance]
   set annual($year,income) [apsimGetOptional income]
   set annual($year,expenditure) [apsimGetOptional expenditure]
   lappend annual(years) $year
}

proc close_annual_stuff {} {
   global simName config annual annualcrop
   puts "close_annual_stuff called"
   parray annual

   # Heading
   set fp [open $simName.annual.out w]
   puts $fp "Title = $simName"
   puts $fp ""
   puts -nonewline $fp "year "
   foreach {accumulator} {runoff drain soil_loss es avg_cover avg_carbon rain weedings dm_eaten} {
      puts -nonewline $fp " $accumulator"
   }
   foreach id [getLabourers] {
      puts -nonewline $fp " ${id}_labour"
   }
   foreach crop $config(crops) {
      puts -nonewline $fp " ${crop}_harvest"
   }
   puts $fp " income expenditure profit"

   puts -nonewline $fp "() "
   foreach {accumulator} {runoff drain soil_loss es rain } {
      puts -nonewline $fp " (mm)"
   }
   puts -nonewline $fp " ()  ()  () (kg)"
   foreach id [getLabourers] {
      puts -nonewline $fp " (hours)"
   }
   foreach crop $config(crops) {
      puts -nonewline $fp " (tonnes-wet)"
   }
   puts $fp " ($) ($) ($)"

   # Area weighted averages of environmental stuff
   set tfa 0.0
   foreach paddock $config(paddocks) {set tfa [expr $tfa + $config($paddock,area)]}
   if {$tfa &lt;= 0.0} {close $fp; return}

   foreach year [lrange $annual(years) 1 end] {
      puts -nonewline $fp "$year "
      foreach {accumulator} {runoff drain soil_loss es} {
         set s 0.0
         foreach paddock $config(paddocks) {
            set s [expr $s + $annual($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
         }
         puts -nonewline $fp " [format %.2f $s]"
      }
      foreach {accumulator} {avg_cover avg_carbon} {
         set s 0.0
         foreach paddock $config(paddocks) {
            if {![string is double -strict $annual($year,$paddock,$accumulator)]} {
               set s " *"
               break
            } else {
               set s [expr $s + $annual($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
            }
         }
         if {[string is double -strict $s]} {
            puts -nonewline $fp " [format %.2f $s]"
         } else {
            puts -nonewline $fp " *"
         }
      }
      puts -nonewline $fp " [format %.2f $annual($year,accRain)]"
      set s 0.0
      foreach paddock $config(paddocks) {set s [expr $s + $annual($year,$paddock,weedings)] }
      puts -nonewline $fp " [format %.0f $s]"
      if {[info exists annual($year,dm_eaten)]} {
         puts -nonewline $fp " [lsum $annual($year,dm_eaten)]"
      } else {
         puts -nonewline $fp " 0"
      }
      foreach id [getLabourers] {
        if {[info exists annual($year,labourhours)]} {
          puts -nonewline $fp " $annual($year,$id,labourhours)"
        } else {
          puts -nonewline $fp " 0"
        }
      }
      foreach crop $config(crops) {
         if {[info exists annual($year,$crop,harvest)]} {
           puts -nonewline $fp " [format %.3f $annual($year,$crop,harvest)]"
         } else {
           puts -nonewline $fp " *"
         }
      }

      if {[info exists annual($year,income)] &amp;&amp; [string is double -strict $annual($year,income)] } {
         puts -nonewline $fp " [format %.2f $annual($year,income)]"
      } else {
         puts -nonewline $fp " *"
      }
      if {[info exists annual($year,expenditure)] &amp;&amp; [string is double -strict $annual($year,expenditure)]} {
         puts -nonewline $fp " [format %.2f $annual($year,expenditure)]"
      } else {
         puts -nonewline $fp " *"
      }
      # profit = change in bank balance each year
      catch {
         puts -nonewline $fp " [format %.2f [expr $annual($year,balance) - $annual([expr $year-1],balance)]]"
      }
      puts $fp ""
   }
   close $fp
}</text>
          <event>init</event>
        </script>
        <script>
          <text>
catch "file delete $simName.annual.out"

open_annual_stuff</text>
          <event>start_simulation</event>
        </script>
        <script>
          <text>
close_annual_stuff</text>
          <event>end_simulation</event>
        </script>
        <script>
          <text>
   set annual(accRain) [expr $annual(accRain) + [apsimGet rain]]
   foreach {accumulator} {runoff drain es } {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet $config($paddock,watBal).$accumulator]]
         }
      }
   }
   foreach {accumulator} {soil_loss} {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet $paddock.erosion.$accumulator]]
         }
      }
   }
   </text>
          <event>post</event>
        </script>
        <script>
          <text>
do_end_year</text>
          <event>end_year</event>
        </script>
        <script>
          <text>
set cow [apsimGetOptional inputdmOfCows]; if {$cow == ""} {set cow 0}
set shoat [apsimGetOptional inputdmOfShoats]; if {$shoat == ""} {set shoat 0}

set year [apsimGet year]
lappend annual($year,dm_eaten) [expr $cow + $shoat]
</text>
          <event>end_month</event>
        </script>
      </rule>
      <rule name="Harvest Reports">
        <ui>
          <category type="category" description="No editable paramters" />
        </ui>
        <script>
          <text>
# Annual summary of whole farm averages

proc open_harvest_stuff {} {
   global harvest config
   set harvest {}
}


proc close_harvest_stuff {} {
   global simName config harvest
   puts "close_harvest_stuff called"

   # Heading
   set fp [open $simName.harvest.out w]
   puts $fp "Title = $simName"
   puts $fp ""
   puts $fp "Date         season paddock crop biomass  yield   protein"
   puts $fp "(dd/mm/yyyy)     ()      ()   () (kg/ha) (kg/ha)  (%)"

   foreach line $harvest {
      puts $fp $line
   }
   close $fp
}

</text>
          <event>init</event>
        </script>
        <script>
          <text>
catch "file delete $simName.harvest.out"

open_harvest_stuff

</text>
          <event>start_simulation</event>
        </script>
        <script>
          <text>
close_harvest_stuff

</text>
          <event>end_simulation</event>
        </script>
      </rule>
      <rule name="IAT Reports">
        <ui>
          <category type="category" description="No editable paramters" />
        </ui>
        <script>
          <text>
# Annual summary of whole farm averages

proc open_iat_stuff {} {
   global iat config
   set iat {}
}


proc close_iat_stuff {} {
   global simName config iat
   puts "close_iat_stuff called"

   # Heading
   set fp [open $simName.iat.csv w]
   puts $fp "Date,crop,biomass,grain.yield,grain.protein,residue.yield,residue.protein"
   puts $fp "(dd/mm/yyyy),(),(kg/ha),(kg/ha),(%),(kg/ha),(%)"

   foreach line $iat {
      puts $fp $line
   }
   close $fp
}

</text>
          <event>init</event>
        </script>
        <script>
          <text>
catch "file delete $simName.iat.csv"

open_iat_stuff

</text>
          <event>start_simulation</event>
        </script>
        <script>
          <text>
close_iat_stuff

</text>
          <event>end_simulation</event>
        </script>
      </rule>
      <rule name="Labour Initialisation logic">
        <ui>
          <category type="category" description="No editable Parameters" />
        </ui>
        <script>
          <text>
# Apsim Machinery (sub)Module
# Contains Tractors, Implements &amp; Labour.

# Operations:
# bool available(&lt;config&gt;)    ; See if a configuration can be used today (read)
# operate &lt;config&gt; &lt;area&gt;     ; Operate a configuration over an area until finished (event)

########################## Apsim interface code here
source $apsuite/Model/TclLink/CIDataTypes.tcl

# A trace handler for status. This handler is called whenever another module
# asks us whether machinery is available.
#    NB. Careful! Errors in trace routines are not caught!!!
proc machinery:maProc {name1 name2 op} {
   if {$op == "read" } {
      global config $name1
      foreach {junk operator implement} [split $name1 "_"] { break }

      # Check they are known to us
      if {[lsearch $config(operators) $operator] &lt; 0} {
         set msg "operator \"$operator\" is unknown - I only know about $config(operators)"
         error $msg
      }
      if {[lsearch $config(implements) $implement] &lt; 0} {
         set msg "implement \"$implement\" is unknown - I only know about $config(implements)"
         error $msg
      }

      # Now see if they are busy
      set avail 1
      catch {
         global machinery:jobs
         foreach job ${machinery:jobs} {
            foreach {tid iid area paddock costtype} [split $job ","] {break}
            if {"$operator" == "$tid" || "$implement" == "$iid"} {set avail 0}
         }
      } msg
      if {$msg != ""} {apsimWriteToSummaryFile $msg; error $msg}

      # Set the variable - this is what is returned to apsim.
      set $name1 $avail
   }
}

# An event handler.
proc operateLabour {args} {
  foreach arg $args {
     regsub -all "'" [lindex $arg 0] {} _name
     regsub -all "'" [lrange $arg 1 end] {} _value
     if {"$_name" != "callback"} {
        set [string tolower $_name] [string tolower $_value]
     } else {
        set $_name $_value
     }
  }
  if {![info exists operator] || ![info exists activity] || ![info exists area]} {
     error "Must specify a operator, activity, and area to operate over."
  }
  if { ![info exists paddock] } {set paddock {}}
  if { ![info exists costtype] } {set costtype unknown}
  if { ![info exists callback]}  {
    machinery:operate $operator $activity $area $paddock $costtype
  } else {
    machinery:operateLater $operator $activity $area $paddock $costtype $callback
  }
}

# Now register the event handlers.
#apsimSubscribeVariant operate            "machinery:operateHandler"
#apsimSubscribeVariant operate_later      "machinery:operateLaterHandler"
apsimSubscribeNull process            "machinery:process"
apsimSubscribeNull end_financial_year "machinery:end_year"
########################## End apsim interface code

########################## Machinery configuration code
# Read in our configuration
proc machinery:initialise {} {
   global config
   if {![info exists config(operators)]} {set config(operators) {}}
   if {![info exists config(implements)]} {set config(implements) {}}
}

# return the work rate for this combo can cover per hour
proc getCombo {operator implement thing} {
   global config
   if {![info exists config(machinery,$operator,$implement,$thing)]} {
      error "No $thing specified for $operator and $implement"
   }
   return $config(machinery,$operator,$implement,$thing)
}

proc getRate {tid iid} {
   return [getCombo $tid $iid workrate]
}

proc getValue {id thing} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (get)"
   }
   return $config(machinery,$id,$thing)
}

# Return the cost of labour per hour
proc labourCost {} {
   global config
   if {![info exists config(economics,labourCost)]} {
      error "No labourCost specified"
   }
   return $config(economics,labourCost)
}

# return the labour cost this combo uses per hour
proc getLabourCost {tid iid} {
   return [expr [getCombo $tid $iid workrate] * [ labourCost ]]
}

proc getLabourers {} {
   global config
   return $config(operators)
}


# Return the number of hours worked per day
proc getHoursPerDay {tid iid} {
   return [getCombo $tid $iid hoursperday]
}

proc setValue {id thing value} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (set)"
   }
   set config(machinery,$id,$thing) $value
}

##############
# Operate a configuration over an area. Just add it to the job queue
# and let process look after it.
proc machinery:operate {operator implement area paddock costtype} {
   if {![string is double -strict $area]} {
      error "Area should be a number (not $area)"
   }
   global machinery:jobs
   lappend machinery:jobs $operator,$implement,$area,$paddock,$costtype,
   apsimWriteToSummaryFile "Machinery job \"$operator + $implement\" is queued"
}

proc machinery:operateLater {operator implement area paddock costtype command} {
   if {![string is double -strict $area]} {
      error "Area should be a number (not $area)"
   }
   global machinery:jobs
   lappend machinery:jobs $operator,$implement,$area,$paddock,$costtype,$command
   apsimWriteToSummaryFile "Machinery job \"$operator + $implement\" is queued"
}

# The daily process routine. Manages the job queue
proc machinery:process {} {
   global machinery:jobs annual
   set tomorrowsJobs {}
   # Go through each job. If an item is in use in any prior job, we can't do it today.
   for {set ijob 0} {$ijob &lt; [llength ${machinery:jobs}]} {incr ijob} {
      set job [lindex ${machinery:jobs} $ijob]
      foreach {tid iid area paddock costtype command} [split $job ","] {break}
      set inuse 0
      for {set j 0} {$j &lt; $ijob} {incr j} {
         foreach {Ttid Tiid Tarea Tpaddock Tcosttype Tcommand} [split [lindex ${machinery:jobs} $j] ","] {break}
         if {$tid == $Ttid || $iid == $Tiid} {set inuse 1}
      }
      if {!$inuse} {
        # The job is running today. Work out how many hours, and then the costs
        set maxHours [getHoursPerDay $tid $iid]
        set rate [getRate $tid $iid]

        if {$maxHours * $rate &lt;= $area} {
           set hours $maxHours
           set areaToday [expr $maxHours * $rate]
        } else {
           set hours [expr $area / $rate]
           set areaToday [expr $hours * $rate]
        }
        set cost [expr $hours * [getLabourCost $tid $iid]]
        apsimSendMessage "" expenditure [list hours $hours] [list cost $cost] [list comment "operating costs of $tid + $iid"] [list paddock $paddock] [list area $areaToday] [list $costtype {}]
        set year [apsimGet year]
        if {![info exists annual($year,labourhours)]} {
           set annual($year,$tid,labourhours) $hours
        } else {
           set annual($year,$tid,labourhours) [expr $annual($year,labourhours) + $hours]
        }

        set rate [expr $hours * [getRate $tid $iid]]
        set area [expr $area - $rate]

        if {$area &gt; 0} {
           lappend tomorrowsJobs $tid,$iid,$area,$paddock,$costtype,$command
        } else {
           apsimWriteToSummaryFile "Labour job '$tid + $iid' in $paddock has finished"
           if {$command != ""} { apsimWriteToSummaryFile "doing $command"; eval $command }
        }
      } else {
        lappend tomorrowsJobs $job
      }
   }
   set machinery:jobs $tomorrowsJobs
}

# The "end_year" routine. Do loan payments and replacement
proc machinery:end_year {} {
   global annual
   global machinery:jobs

}
</text>
          <event>init</event>
        </script>
        <script>
          <text>

# Finally, load our configuration database and initialise states
machinery:initialise
set machinery:jobs {}

# Now tell apsim we own it, set up the trace variable we use to trigger when the variable is read
foreach tid $config(operators) {
  foreach iid $config(implements) {
     set v available_${tid}_${iid}
     set $v 0
     apsimRegisterGetSet $v
     trace add variable $v read "machinery:maProc"
  }
}

apsimWriteToSummaryFile "Labour:\nOperators=$config(operators)\nImplements=$config(implements)"

</text>
          <event>start_simulation</event>
        </script>
      </rule>
      <rule name="Labour Operators">
        <ui>
          <category type="category" description="Operator" />
          <apsimname type="text" description="Apsim name">male</apsimname>
          <category type="category" description="Implement 1" />
          <implement1name type="text" description="Name">sowing</implement1name>
          <implement1workrate type="text" description="Work Rate (ha/hour)">0.5</implement1workrate>
          <implement1hoursperday type="text" description="Daily Hours (hours)">12</implement1hoursperday>
          <category type="category" description="Implement 2" />
          <implement2name type="text" description="Name">weeding</implement2name>
          <implement2workrate type="text" description="Work Rate (ha/hour)">0.8</implement2workrate>
          <implement2hoursperday type="text" description="Daily Hours (hours)">12</implement2hoursperday>
          <category type="category" description="Implement 3" />
          <implement3name type="text" description="Name">harvesting</implement3name>
          <implement3workrate type="text" description="Work Rate (ha/hour)">0.2</implement3workrate>
          <implement3hoursperday type="text" description="Daily Hours (hours)">8</implement3hoursperday>
          <category type="category" description="Implement 4" />
          <implement4name type="text" description="Name">presow_till</implement4name>
          <implement4workrate type="text" description="Work Rate (ha/hour)">0.1</implement4workrate>
          <implement4hoursperday type="text" description="Daily Hours (hours)">8</implement4hoursperday>
          <category type="category" description="Implement 5" />
          <implement5name type="text" description="Name">spraying</implement5name>
          <implement5workrate type="text" description="Work Rate (ha/hour)">0.1</implement5workrate>
          <implement5hoursperday type="text" description="Daily Hours (hours)">8</implement5hoursperday>
        </ui>
        <script>
          <text>
lappend config(operators) "[apsimname]"
set config(machinery,[apsimname],age) "0"

set config(machinery,[apsimname],[implement1name],workrate) "[implement1workrate]"
set config(machinery,[apsimname],[implement1name],hoursperday) "[implement1hoursperday]"

set config(machinery,[apsimname],[implement2name],workrate) "[implement2workrate]"
set config(machinery,[apsimname],[implement2name],hoursperday) "[implement2hoursperday]"

set config(machinery,[apsimname],[implement3name],workrate) "[implement3workrate]"
set config(machinery,[apsimname],[implement3name],hoursperday) "[implement3hoursperday]"

set config(machinery,[apsimname],[implement4name],workrate) "[implement4workrate]"
set config(machinery,[apsimname],[implement4name],hoursperday) "[implement4hoursperday]"

set config(machinery,[apsimname],[implement5name],workrate) "[implement5workrate]"
set config(machinery,[apsimname],[implement5name],hoursperday) "[implement5hoursperday]"
</text>
          <event>init</event>
        </script>
      </rule>
      <rule name="Costs - Wages">
        <ui>
          <category type="category" description="Costs" />
          <labourCost type="text" description="Cost of labour ($/hr)">0.0</labourCost>
        </ui>
        <script>
          <text>
set config(economics,labourCost) "[labourCost]"
          </text>
          <event>init</event>
        </script>
      </rule>
    </tclmanager>
      <manager2 name="Economics">
        <ui>
          <category type="category" description="Dummy module" />
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [EventHandler] public void OnBuyCows() {Console.WriteLine("Buying a cow");}
   [EventHandler] public void OnSellCows() {Console.WriteLine("Selling a cow");}

   [EventHandler] public void OnBuyShoats() {Console.WriteLine("Buying a goat");}
   [EventHandler] public void OnSellShoats() {Console.WriteLine("Selling a goat");}
}   
       </text>
      </manager2>
    <folder name="Livsim">
      <manager2 name="Cow Herd Management">
        <ui>
          <moduleName type="text" description="Name of animal module">cows</moduleName>
          <herdsize type="text" description="Target number of cows in herd">10</herdsize>
          <maxMale type="text" description="Number of entire male cows">0</maxMale>
          <minAge_sale type="text" description="Age when animals considered for sale (yrs)">2.5</minAge_sale>
          <initialAge type="text" description="Age of Initial herd(y)">1.5</initialAge>
          <initialWeight type="text" description="Weight of initial beasts (kg)">120</initialWeight>
          <maxAge type="text" description="Maximum age of beasts (y)">14</maxAge>
          <genotype type="text" description="Genotype of cows()">mashona</genotype>
          <herdMinFrac type="text" description="Herd replacement threshold - replace when below this fraction">0.25</herdMinFrac>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] string moduleName;
   [Param] int herdsize;
   [Param] int maxMale;   
   [Param] double maxAge;   
   [Param] double initialAge;
   [Param] double initialWeight;
   [Param] string genotype;

   [EventHandler] public void OnStart_Simulation()
   {
      if (herdsize &gt; 0) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale);
         b.sex = "F";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "") 
           b.genotype = genotype;
         Buy(b);
         if (maxMale &gt; 0) {
            b.number = maxMale;
            b.sex = "M";
            Buy(b);
         }
      }
   }
   public void Buy(BuyType b) {
      Sim.Publish(moduleName + ".buy" + moduleName, b);
      Sim.Publish("economics.buy" + moduleName);
   }

   [Param] double minAge_sale;
   [Input] int month;
   [EventHandler] public void OnStart_Month()
   {
      int num = 0;
      string [] sex = new string[500];

      // 1. Remove any males above maturity, keep the youngest as a Billy 
      int numMales = 0;
      do {
         Sim.Get("sex"+moduleName, out sex);
         num = sex.Length;
         if (num &gt; 0) {
           double [] age = new double[num];
           Sim.Get("age"+moduleName, out age);
           numMales = 0;
           int oldestMale = -1;
           double oldestAge = 0.0;
           for (int i = 0; i &lt; num; i++) 
              if (sex[i] == "M" &amp;&amp; age[i] &gt; minAge_sale ) {
                  if (age[i] &gt; oldestAge ) {
                    oldestAge = age[i];
                    oldestMale = i;
                  }  
                  numMales++;
              }
           if (oldestMale &gt;= 0) 
             if (numMales &gt; maxMale || age[oldestMale] &gt; maxAge) {
               SellType s = new SellType();
               s.group = oldestMale+1;  // Index Origin 1 in R
               Sell(s);
             }
         }  
      } while (num &gt; 0 &amp;&amp; numMales &gt; maxMale);

      // 2. If we have more mature females than we need, sell the oldest non-lactating 
      int numFemales = 0;
      int oldestFemale = 0;
      do {
         Sim.Get("sex"+moduleName, out sex);
         num = sex.Length;
         if (num &gt; 0) {
            double [] age = new double[num];
            Sim.Get("age"+moduleName, out age);
            numFemales = 0;
            oldestFemale = -1;
            double oldestAge = 0.0;
            for (int i = 0; i &lt; num; i++) 
               if ((sex[i] == "F" || sex[i] == "FL") &amp;&amp; age[i] &gt; minAge_sale) {
                   if (sex[i] == "F" &amp;&amp; age[i] &gt; oldestAge ) {
                     oldestAge = age[i];
                     oldestFemale = i;
                   }  
                   numFemales++;
               }
            if (oldestFemale &gt;= 0)
             if ( numFemales &gt; herdsize - maxMale || age[oldestFemale] &gt; maxAge) {
               SellType s = new SellType();
               s.group = oldestFemale+1;
               Sell(s);
             }
         }
      } while (num &gt; 0 &amp;&amp; oldestFemale &gt;= 0 &amp;&amp; numFemales &gt; herdsize - maxMale);
   }

   [Param] public double herdMinFrac;
   [EventHandler] public void OnStart_Year()
   {
      string [] sex = new string[500];
      int nMale = 0, nFemale = 0;
      Sim.Get("sex" + moduleName, out sex);
      for (int i = 0; i &lt; sex.Length; i++) 
         if (sex[i] == "M") 
            nMale++;
         else
            nFemale++;
      
      if (nFemale &lt; (herdsize - maxMale) * herdMinFrac) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale - nFemale);
         b.sex = "F";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "") 
            b.genotype = genotype;
         Buy(b);
   
      }
      if ( nMale &lt; maxMale * herdMinFrac) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale - nFemale);
         b.sex = "M";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "") 
            b.genotype = genotype;
         Buy(b);
      }
         
   }
   public void Sell(SellType s) {
      Sim.Publish(moduleName + ".sell" + moduleName, s);
      Sim.Publish("economics.sell" + moduleName);
   }
}
       </text>
      </manager2>
      <manager2 name="Shoat Herd Management">
        <ui>
          <moduleName type="text" description="Name of animal module">shoats</moduleName>
          <herdsize type="text" description="Target number of shoats in herd">14</herdsize>
          <maxMale type="text" description="Number of entire male shoats">0</maxMale>
          <minAge_sale type="text" description="Age when animals considered for sale (yrs)">2.25</minAge_sale>
          <initialAge type="text" description="Age of Initial herd(y)">2.5</initialAge>
          <initialWeight type="text" description="Weight of initial beasts (kg)">60</initialWeight>
          <maxAge type="text" description="Maximum age of beasts (y)">12</maxAge>
          <genotype type="text" description="Genotype of shoats ()">na</genotype>
          <herdMinFrac type="text" description="Herd replacement threshold - replace when below this fraction">0.25</herdMinFrac>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] string moduleName;
   [Param] int herdsize;
   [Param] int maxMale;   
   [Param] double maxAge;   
   [Param] double initialAge;
   [Param] double initialWeight;
   [Param] string genotype;

   [EventHandler] public void OnStart_Simulation()
   {
      if (herdsize &gt; 0) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale);
         b.sex = "F";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "") 
           b.genotype = genotype;
         Buy(b);
         if (maxMale &gt; 0) {
            b.number = maxMale;
            b.sex = "M";
            Buy(b);
         }
      }
   }
   public void Buy(BuyType b) {
      Sim.Publish(moduleName + ".buy" + moduleName, b);
      Sim.Publish("economics.buy" + moduleName);
   }

   [Param] double minAge_sale;
   [EventHandler] public void OnStart_Month()
   {
      int num = 0;
      string [] sex = new string[500];

      // 1. Remove any males above maturity, keep the youngest as a Billy 
      int numMales = 0;
      do {
         Sim.Get("sex"+moduleName, out sex);
         num = sex.Length;
         if (num &gt; 0) {
           double [] age = new double[num];
           Sim.Get("age"+moduleName, out age);
           numMales = 0;
           int oldestMale = -1;
           double oldestAge = 0.0;
           for (int i = 0; i &lt; num; i++) 
              if (sex[i] == "M" &amp;&amp; age[i] &gt; minAge_sale ) {
                  if (age[i] &gt; oldestAge ) {
                    oldestAge = age[i];
                    oldestMale = i;
                  }  
                  numMales++;
              }
           if (oldestMale &gt;= 0) 
             if (numMales &gt; maxMale || age[oldestMale] &gt; maxAge) {
               SellType s = new SellType();
               s.group = oldestMale+1;  // Index Origin 1 in R
               Sell(s);
             }
         }  
      } while (num &gt; 0 &amp;&amp; numMales &gt; maxMale);

      // 2. If we have more mature females than we need, sell the oldest non-lactating 
      int numFemales = 0;
      int oldestFemale = 0;
      do {
         Sim.Get("sex"+moduleName, out sex);
         num = sex.Length;
         if (num &gt; 0) {
            double [] age = new double[num];
            Sim.Get("age"+moduleName, out age);
            numFemales = 0;
            oldestFemale = -1;
            double oldestAge = 0.0;
            for (int i = 0; i &lt; num; i++) 
               if ((sex[i] == "F" || sex[i] == "FL") &amp;&amp; age[i] &gt; minAge_sale) {
                   if (sex[i] == "F" &amp;&amp; age[i] &gt; oldestAge ) {
                     oldestAge = age[i];
                     oldestFemale = i;
                   }  
                   numFemales++;
               }
            if (oldestFemale &gt;= 0)
             if ( numFemales &gt; herdsize - maxMale || age[oldestFemale] &gt; maxAge) {
               SellType s = new SellType();
               s.group = oldestFemale+1;
               Sell(s);
             }
         }
      } while (num &gt; 0 &amp;&amp; oldestFemale &gt;= 0 &amp;&amp; numFemales &gt; herdsize - maxMale);
   }   

   // At the start  of each year, restock if below X% of herd size
   [Param] public double herdMinFrac;
   [EventHandler] public void OnStart_Year()
   {
      string [] sex = new string[500];
      int nMale = 0, nFemale = 0;
      Sim.Get("sex" + moduleName, out sex);
      for (int i = 0; i &lt; sex.Length; i++) 
         if (sex[i] == "M") 
            nMale++;
         else
            nFemale++;
      
      if (nFemale &lt; (herdsize - maxMale) * herdMinFrac) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale - nFemale);
         b.sex = "F";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "na") 
            b.genotype = genotype;
         Buy(b);
   
      }
      if ( nMale &lt; maxMale * herdMinFrac) {
         BuyType b = new BuyType();
         b.number = Math.Max(0, herdsize - maxMale - nFemale);
         b.sex = "M";
         b.age = initialAge;
         b.weight = initialWeight;
         if (genotype != "") 
            b.genotype = genotype;
         Buy(b);
      }
         
   }

   public void Sell(SellType s) {
      Sim.Publish(moduleName + ".sell" + moduleName, s);
      Sim.Publish("economics.sell"+moduleName);
   }
}
       </text>
      </manager2>
      <manager2 name="bransupplement">
        <ui>
          <category type="category" description="Supplement details" />
          <feedClass type="text" description="Name of feed">bran</feedClass>
          <store type="text" description="Initial amount of storage (kg)">100000</store>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] public string feedClass;         // The name of the feed we are storing

   [Param,Output] public double store;             // The amount of stuff we are storing

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = store;
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) 
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [EventHandler]
   public void OnPost()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          store -= eaten.element[i].WeightRemoved;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <manager2 name="Maize_residue_store">
        <ui>
          <category type="category" description="Supplement details" />
          <feedClass type="text" description="Name of feed">maize</feedClass>
          <MyStore type="text" description="Initial amount stored (kg)">500</MyStore>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] public string feedClass;               // The name of the feed we are storing

   [Param] private double MyStore;
   [Output] public double store {            // The amount of stuff we have stored
       get {
          return(MyStore);
       }
       set {
          Console.WriteLine("Setting " + feedClass + "store to "+  value + " kg");
          MyStore = value;
       }
   }

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = Math.Max(MyStore, 0.0);
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) {
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
           MyStore -= Math.Min(MyStore, eaten.element[0].WeightRemoved);
         }  
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <manager2 name="Sorghum_residue_store">
        <ui>
          <category type="category" description="Supplement details" />
          <feedClass type="text" description="Name of feed">sorghum</feedClass>
          <MyStore type="text" description="Initial amount stored (kg)">0</MyStore>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] public string feedClass;               // The name of the feed we are storing

   [Param] private double MyStore;
   [Output] public double store {            // The amount of stuff we have stored
       get {
          return(MyStore);
       }
       set {
          Console.WriteLine("Setting " + feedClass + "store to "+  value + " kg");
          MyStore = value;
       }
   }

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = Math.Max(MyStore, 0.0);
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) {
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
           MyStore -= Math.Min(MyStore, eaten.element[0].WeightRemoved);
         }  
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <manager2 name="Groundnut_residue_store">
        <ui>
          <category type="category" description="Supplement details" />
          <feedClass type="text" description="Name of feed">resd</feedClass>
          <MyStore type="text" description="Initial amount stored (kg)">50</MyStore>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] public string feedClass;               // The name of the feed we are storing

   private double MyStore = 0;
   [Output] public double store {            // The amount of stuff we have stored
       get {
          return(MyStore);
       }
       set {
         Console.WriteLine("Setting " + feedClass + "store to " + value + " kg");
         MyStore = value;
      }
   }

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = Math.Max(MyStore, 0.0);
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) {
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
           MyStore -= Math.Min(MyStore, eaten.element[0].WeightRemoved);
         }  
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <manager2 name="Mucuna_residue_store">
        <ui>
          <category type="category" description="Supplement details" />
          <feedClass type="text" description="Name of feed">mucuna</feedClass>
          <MyStore type="text" description="Initial amount stored (kg)">500</MyStore>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;
   
   [Param] public string feedClass;               // The name of the feed we are storing

   [Param] private double MyStore;
   [Output] public double store {            // The amount of stuff we have stored
       get {
          return(MyStore);
       }
       set {
          Console.WriteLine("Setting " + feedClass + "store to "+  value + " kg");
          MyStore = value;
       }
   }

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = Math.Max(MyStore, 0.0);
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) {
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
           MyStore -= Math.Min(MyStore, eaten.element[0].WeightRemoved);
         }  
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <manager2 name="magic">
        <ui>
          <category type="category" description="An unlimited feed store" />
          <feedClass type="text" description="Name of feed">grass</feedClass>
        </ui>
        <text>
using System;
using ModelFramework;

public class Script 
{      
   [Link] Simulation Sim;

   [Link] Component me;
   
   [Param] public string feedClass;               // The name of the feed we are storing

   // An animal is asking how much we have
   [Output] AvailableToAnimalType AvailableToAnimal {
      get {
        AvailableToAnimalType a = new AvailableToAnimalType();
        a.element = new AvailableToAnimalelementType[1];
        a.element[0] = new AvailableToAnimalelementType();
        a.element[0].CohortID = feedClass;
        a.element[0].AgeID = "green";
        a.element[0].Weight = 50000;
        return(a);
      }
   }

   // An animal has taken some of our store
   private RemovedByAnimalType eaten = null;
   [Output] RemovedByAnimalType RemovedByAnimal {
      set {
         if (eaten != null) 
           for (int i = 0; i &lt; value.element.Length; i++)
             if (value.element[i].CohortID == eaten.element[0].CohortID &amp;&amp;
                 value.element[i].AgeID == eaten.element[0].AgeID )
               eaten.element[0].WeightRemoved += value.element[i].WeightRemoved;
      }
      get { return(eaten); }
   }

   [EventHandler]
   public void OnInit2()
   {
      eaten = new RemovedByAnimalType();
      eaten.element = new RemovedByAnimalelementType[1];
      eaten.element[0] = new RemovedByAnimalelementType();
      eaten.element[0].CohortID = feedClass;
      eaten.element[0].AgeID = "green";
      eaten.element[0].WeightRemoved = 0;
   }

   [EventHandler]
   public void OnPrepare()
   {   
      for (int i = 0; i &lt; eaten.element.Length; i++) {
          eaten.element[i].WeightRemoved = 0;
      }
   }

   [Output] double consumed {
      get {
         if (eaten != null) 
            return(eaten.element[0].WeightRemoved);
         return 0.0;   
      }
   }
}   
       </text>
      </manager2>
      <RLink name="Feed Quality">
        <script>
          <text>
# Feed source ranking - highest ranks are eaten first, lowest last.
FeedRank &lt;-list()

# Feed (ID 4 in mark's spreadsheet)
Qlty&lt;-list()
Qlty[["maize.dm"]] &lt;- 1000.0  ;#(DM content g/kg)
Qlty[["maize.me"]] &lt;-   12.2  ;#(Metab. Energy MJ/kg)
Qlty[["maize.ge"]] &lt;-   19    ;#
Qlty[["maize.fme"]] &lt;-  8.8   ;#(Ferment. Energy MJ/kg)
Qlty[["maize.cp"]] &lt;-   180   ;#(Crude prot. g/kg)
Qlty[["maize.adin"]] &lt;- 0.5   ;#(Acid Digest insol. N g/kg)
Qlty[["maize.dmd"]] &lt;-  0.8   ;#(Dry matter Digest g/kg)
Qlty[["maize.a"]] &lt;-    0.7   ;#(fr)
Qlty[["maize.b"]] &lt;-    0.2   ;#(fr)
Qlty[["maize.c"]] &lt;-    0.1   ;#(fr)
Qlty[["maize.ndf"]] &lt;-  137   ;#()
Qlty[["maize.p"]] &lt;-    0.001 ;#()
Qlty[["maize.k"]] &lt;-    0.009 ;#()
Qlty[["maize.type"]] &lt;- 3     ;# forage legume
FeedRank[["maize"]] &lt;-4

Qlty[["sorghum.dm"]] &lt;- 1000.0  ;#(DM content g/kg)
Qlty[["sorghum.me"]] &lt;-   12.2  ;#(Metab. Energy MJ/kg)
Qlty[["sorghum.ge"]] &lt;-   19    ;#
Qlty[["sorghum.fme"]] &lt;-  8.8   ;#(Ferment. Energy MJ/kg)
Qlty[["sorghum.cp"]] &lt;-   180   ;#(Crude prot. g/kg)
Qlty[["sorghum.adin"]] &lt;- 0.5   ;#(Acid Digest insol. N g/kg)
Qlty[["sorghum.dmd"]] &lt;-  0.8   ;#(Dry matter Digest g/kg)
Qlty[["sorghum.a"]] &lt;-    0.7   ;#(fr)
Qlty[["sorghum.b"]] &lt;-    0.2   ;#(fr)
Qlty[["sorghum.c"]] &lt;-    0.1   ;#(fr)
Qlty[["sorghum.ndf"]] &lt;-  137   ;#()
Qlty[["sorghum.p"]] &lt;-    0.001 ;#()
Qlty[["sorghum.k"]] &lt;-    0.009 ;#()
Qlty[["sorghum.type"]] &lt;- 3     ;# forage legume
FeedRank[["sorghum"]] &lt;-4

# Feed (ID 6 in mark's spreadsheet)
Qlty[["resd.dm"]] &lt;- 1000.0  ;#(DM content g/kg)
Qlty[["resd.me"]] &lt;-   12.3 ;#(Metab. Energy MJ/kg)
Qlty[["resd.ge"]] &lt;-   19    ;#
Qlty[["resd.fme"]] &lt;-  11.4   ;#(Ferment. Energy MJ/kg)
Qlty[["resd.cp"]] &lt;-   190   ;#(Crude prot. g/kg)
Qlty[["resd.adin"]] &lt;- 1.3   ;#(Acid Digest insol. N g/kg)
Qlty[["resd.dmd"]] &lt;-  0.75   ;#(Dry matter Digest g/kg)
Qlty[["resd.a"]] &lt;-    0.23   ;#(fr)
Qlty[["resd.b"]] &lt;-    0.71   ;#(fr)
Qlty[["resd.c"]] &lt;-    0.18   ;#(fr)
Qlty[["resd.ndf"]] &lt;-  137   ;#()
Qlty[["resd.p"]] &lt;-    0.001 ;#()
Qlty[["resd.k"]] &lt;-    0.009 ;#()
Qlty[["resd.type"]] &lt;- 3     ;# 
FeedRank[["resd"]] &lt;-6

# Feed (ID 6 in mark's spreadsheet)
Qlty[["mucuna.dm"]] &lt;- 1000.0  ;#(DM content g/kg)
Qlty[["mucuna.me"]] &lt;-   12.3 ;#(Metab. Energy MJ/kg)
Qlty[["mucuna.ge"]] &lt;-   19    ;#
Qlty[["mucuna.fme"]] &lt;-  11.4   ;#(Ferment. Energy MJ/kg)
Qlty[["mucuna.cp"]] &lt;-   190   ;#(Crude prot. g/kg)
Qlty[["mucuna.adin"]] &lt;- 1.3   ;#(Acid Digest insol. N g/kg)
Qlty[["mucuna.dmd"]] &lt;-  0.75   ;#(Dry matter Digest g/kg)
Qlty[["mucuna.a"]] &lt;-    0.23   ;#(fr)
Qlty[["mucuna.b"]] &lt;-    0.71   ;#(fr)
Qlty[["mucuna.c"]] &lt;-    0.18   ;#(fr)
Qlty[["mucuna.ndf"]] &lt;-  137   ;#()
Qlty[["mucuna.p"]] &lt;-    0.001 ;#()
Qlty[["mucuna.k"]] &lt;-    0.009 ;#()
Qlty[["mucuna.type"]] &lt;- 3     ;# 
FeedRank[["mucuna"]] &lt;- 5

# Feed (ID 5 in mark's spreadsheet)- worst quality
Qlty[["grass.dm"]] &lt;-  1000.0 ;#(DM content g/kg)
Qlty[["grass.me"]] &lt;-  11.4 ;#(Metab. Energy MJ/kg)
Qlty[["grass.ge"]] &lt;-   19    ;#
Qlty[["grass.fme"]] &lt;-  10.6  ;#(Ferment. Energy MJ/kg)
Qlty[["grass.cp"]] &lt;-   180   ;#(Crude prot. g/kg)
Qlty[["grass.adin"]] &lt;- 1.2   ;#(Acid Digest insol. N g/kg)
Qlty[["grass.dmd"]] &lt;-  0.7   ;#(Dry matter Digest g/kg)
Qlty[["grass.a"]] &lt;-    0.4   ;#(fr)
Qlty[["grass.b"]] &lt;-    0.6   ;#(fr)
Qlty[["grass.c"]] &lt;-    0.2   ;#(fr)
Qlty[["grass.ndf"]] &lt;-  137   ;#()
Qlty[["grass.p"]] &lt;-    0.001 ;#()
Qlty[["grass.k"]] &lt;-    0.009 ;#()
Qlty[["grass.type"]] &lt;- 1     ;# 
FeedRank[["grass"]] &lt;-2

# Concentrate (ID 1 in spreadsheet)
Qlty[["bran.dm"]] &lt;- 1000.0   ;#(DM content g/kg)
Qlty[["bran.me"]] &lt;-   12.7  ;#(Metab. Energy MJ/kg)
Qlty[["bran.ge"]] &lt;-   18.8  ;#
Qlty[["bran.fme"]] &lt;-  9.9   ;#(Ferment. Energy MJ/kg)
Qlty[["bran.cp"]] &lt;-   300   ;#(Crude prot. g/kg)
Qlty[["bran.adin"]] &lt;- 1.3   ;#(Acid Digest insol. N g/kg)
Qlty[["bran.dmd"]] &lt;-  0.81  ;#(Dry matter Digest g/kg)
Qlty[["bran.a"]] &lt;-    0.25  ;#(fr)
Qlty[["bran.b"]] &lt;-    0.64  ;#(fr)
Qlty[["bran.c"]] &lt;-    0.12  ;#(fr)
Qlty[["bran.ndf"]] &lt;-  180   ;#()
Qlty[["bran.p"]] &lt;-    0.005 ;#()
Qlty[["bran.k"]] &lt;-    0.008 ;#()
Qlty[["bran.type"]] &lt;- 2     ;# concentrate
FeedRank[["bran"]] &lt;-10

# Helper function to add all the Y parts of structure X
AASum&lt;-function (x, y) {
   s&lt;- 0
   for (e in 1:x$numelement) {
      s &lt;-  s + x[[paste("element.",e,sep="")]][[y]]
   }
   return(s)
}

# Return a list of feeds in a structure
feedNames &lt;- function(x) {
   r &lt;- NULL
   for (e in 1:x$numelement) {
      n&lt;-x[[paste("element.",e,sep="")]][["CohortID"]]
      if (sum(r == n) == 0) {
         r &lt;- c(r, n)
      } 
   }
   return(r)   
}

# return a feed's attribute from the Qlty data
feedAttr  &lt;- function(x, y) {
   q &lt;- Qlty[[paste(x,y,sep=".")]]
   if (length(q) == 12) {
      q &lt;- q[apsim$get("month")]
   } else if (length(q) != 1) {
      stop(paste("Length of",x,y,"should be 1 or 12, is", length(q)))
   }
   return(q)
}


# If it's a rationed feed source, eat that amount (kg/ha). Otherwise, 
# do the leaf/stem selection.
doDietSelection &lt;- function (DMEaten, available) {
   if ("ration" %in% names(available)) {
      return(eatAmount(min(DMEaten, available[["ration"]]), available)) 
   }
   return(doLeafStemSelection(DMEaten, available)) 
}

# Eat an amount (up to DMEaten kg/ha) from a feed source
eatAmount &lt;- function (DMEaten, available) {
   eaten &lt;- 0; i &lt;- 1 
   for(i in 1:available$numelement) {
      if (eaten &lt; DMEaten) {
        amount &lt;- max(0, min(available[[paste("element.",i,sep="")]][["Weight"]], DMEaten))
      } else {
        amount &lt;- 0
      }
      available[[paste("element.",i,sep="")]][["WeightRemoved"]] &lt;- amount 
      eaten &lt;- eaten + amount
   } 
   return(available)
}

## Green&amp;dead x leaf&amp;stem diet selection (from grasp - pasture).
graz_comp_curve &lt;- function(ndx, a) { return ((a * ndx) / (ndx * (a - 1) + 1)) }
doLeafStemSelection &lt;- function (DMEaten, available) {
   n &lt;- 0; green_leaf &lt;- green_stem &lt;- dead_leaf&lt;- dead_stem &lt;- green_pool &lt;- dead_pool &lt;- 0
   for (i in 1:available$numelement) {
      e &lt;- available[[paste("element.",i,sep="")]]
      if (e$Organ == "leaf" &amp;&amp; e$AgeID == "live") {
         green_leaf &lt;- green_leaf + e$Weight
         green_pool &lt;- green_pool + e$Weight
         n &lt;- n + 1 ; igl&lt;- i
      } else if (e$Organ == "leaf" &amp;&amp; e$AgeID == "dead") {
         dead_leaf &lt;- dead_leaf + e$Weight
         dead_pool &lt;- dead_pool + e$Weight
         n &lt;- n + 1; idl &lt;- i
      } else if (e$Organ == "stem" &amp;&amp; e$AgeID == "live") {
         green_stem &lt;- green_stem + e$Weight
         green_pool &lt;- green_pool + e$Weight
         n &lt;- n + 1; igs &lt;- i
      } else if (e$Organ == "stem" &amp;&amp; e$AgeID == "dead") {
         dead_stem &lt;- dead_stem + e$Weight
         dead_pool &lt;- dead_pool + e$Weight
         n &lt;- n + 1; ids &lt;- i
      }
   }
   if (n &lt; 4) {
     stop("Oops! not enough green/dead/leaf/stem pools")
   }
   
   if (green_pool &gt; 0) { green_prop_leaf &lt;- green_leaf / green_pool } else {green_prop_leaf &lt;- 0.0}
   if (dead_pool &gt; 0) { dead_prop_leaf&lt;- dead_leaf / dead_pool } else {dead_prop_leaf &lt;- 0.0}

   green_prop &lt;- green_pool / (green_pool + dead_pool)
   if (is.nan(green_prop)) {green_prop &lt;- 0.0}

   mod_green_prop &lt;-  min(1.0, max( (green_prop - 0.10) / 0.90, 0.0))
   # If green is less than 10%, no active selection for green by stock
   if (mod_green_prop &gt; 0.0) {
      green_diet &lt;- graz_comp_curve(mod_green_prop, 19.0)
   } else {
      green_diet &lt;- green_prop
   }

   leaf_diet &lt;- 0.85
   curve_factor &lt;- (0.5 * leaf_diet - leaf_diet) / (0.5 * leaf_diet - 0.5) 

   total_eaten &lt;- min(DMEaten, green_pool + dead_pool)
   green_eaten &lt;- green_diet * DMEaten
   green_eaten &lt;- min(green_pool, green_eaten)
   dead_eaten &lt;- (1.0 - green_diet) * DMEaten
   dead_eaten &lt;- min(dead_pool, dead_eaten)

   green_leaf_eaten &lt;- green_eaten * graz_comp_curve(green_prop_leaf, curve_factor)
   green_leaf_eaten &lt;- max(min(green_leaf, green_leaf_eaten), 0.0)

   dead_leaf_eaten &lt;- dead_eaten * graz_comp_curve(dead_prop_leaf, curve_factor)
   dead_leaf_eaten &lt;- max(min(dead_leaf, dead_leaf_eaten), 0.0)

   green_stem_eaten &lt;- green_eaten - green_leaf_eaten
   green_stem_eaten &lt;- max(min(green_stem, green_stem_eaten), 0.0)

   dead_stem_eaten &lt;- dead_eaten - dead_leaf_eaten
   dead_stem_eaten &lt;- max(min(dead_stem, dead_stem_eaten), 0.0)

   # Trampling????
   #prop_can_eat &lt;- 1.0
   #trampled &lt;- DMEaten * (( 1.0 / prop_can_eat) - 1.0)

   eaten &lt;- available
   stopifnot (green_leaf_eaten &lt;= eaten[[paste("element.",igl,sep="")]][["Weight"]]) 
   eaten[[paste("element.",igl,sep="")]][["WeightRemoved"]] &lt;-green_leaf_eaten
   stopifnot (dead_leaf_eaten &lt;= eaten[[paste("element.",idl,sep="")]][["Weight"]]) 
   eaten[[paste("element.",idl,sep="")]][["WeightRemoved"]] &lt;-dead_leaf_eaten
   stopifnot (green_stem_eaten &lt;= eaten[[paste("element.",igs,sep="")]][["Weight"]]) 
   eaten[[paste("element.",igs,sep="")]][["WeightRemoved"]] &lt;-green_stem_eaten
   stopifnot (dead_stem_eaten &lt;= eaten[[paste("element.",ids,sep="")]][["Weight"]]) 
   eaten[[paste("element.",ids,sep="")]][["WeightRemoved"]] &lt;-dead_stem_eaten
   return(eaten)
}
 
# Animal classes (column 1)
#Weaners (3-12 months) 1
#Juveniles (1-3 yrs)   2
#Dry (M+F)             3
#Lactating             6
#Kids (0-3 months)     7

# Feed type      (column 2)
# Concentrate          2
# Forage legumes       1
# Pasture              3
                       
# Gather the structures that hold available feed from apsim.
# These same structures are returned with eaten amounts later.
getFeedFromAPSIM &lt;- function (sources) {
   AvailableToAnimal &lt;- list()
   for (source in sources) {
      available &lt;-apsim$get(paste(source, "AvailableToAnimal", sep="."))
      slist&lt;-unlist(strsplit(source,".", fixed=T))
      paddock&lt;-slist[1]
      if (length(slist) &lt;= 1) {
        available$area &lt;- 1.0
      } else {
        available$area &lt;- apsim$get(paste(paddock,"_area",sep=""))
      } 
      AvailableToAnimal[[source]] &lt;- available
   }
   return(AvailableToAnimal)
}

# Define the diet (kg/hd/month) for one beast.
# Forages are equally presented, 
define_dietOLD &lt;- function(AvailableToAnimal, ConcentrateAmount, herdsize, numSupplemented) {
   #Amount of concentrates according to age class and milk production
   numForage&lt;-numConc &lt;-0
   for (source in names(AvailableToAnimal)) {
      if (feedAttr(feedNames(AvailableToAnimal[[source]] )[1],"type") == 2) {
         numConc &lt;- numConc + 1
      } else {
         numForage&lt;- numForage + 1
      }   
   }
   Forage_Quant &lt;-matrix(nrow=numForage, ncol=2)
   Conc_Quant &lt;-matrix(nrow=numConc, ncol=2)
   isource&lt;-iconc  &lt;- iforage &lt;- 1
   for (source in names(AvailableToAnimal)) {
      available &lt;- AvailableToAnimal[[source]] 
      kg &lt;- AASum(available, "Weight") * available$area ;# kg/ha -&gt; kg
      if ("ration" %in% names(available)) {kg &lt;- min(kg, available[["ration"]]) } 
      feedName &lt;- feedNames(available)[1]
      feedType &lt;- feedAttr(feedNames(available)[1],"type")

      if (feedType != 2) {
          kg.hd &lt;- kg / herdsize
          Forage_Quant[iforage,1] &lt;- isource
          Forage_Quant[iforage,2] &lt;-  kg.hd
          iforage &lt;- iforage + 1
      } else {
          kg.hd &lt;- kg / numSupplemented
          Conc_Quant[iconc,1] &lt;- isource
          if (ConcentrateAmount &gt; 0) {
            Conc_Quant[iconc,2] &lt;-  max(0, min(kg.hd, ConcentrateAmount))
          } else {
            Conc_Quant[iconc,2] &lt;-  0.0
          }  
          iconc &lt;- iconc + 1
      }
      isource &lt;- isource + 1
   }

   # Determine quality
   ForageQuality &lt;- matrix(ncol=14,nrow=numForage)
   ConcentrateQuality &lt;- matrix(ncol=14,nrow=numConc)
   isource&lt;- iconc &lt;- iforage &lt;- 1
   for (source in names(AvailableToAnimal)) {
      available &lt;- AvailableToAnimal[[source]]
      name &lt;- feedNames(available)[1]
      feedAttr &lt;- feedAttr(name,"type")
      qualities &lt;- c("dm","me","ge","fme","cp","adin","dmd","a","b","c","ndf","p","k")
      for (iq in 1:length(qualities)) {
         if (feedAttr == 1 || feedAttr == 3) {
            ForageQuality[iforage,iq+1] &lt;- feedAttr(name,qualities[iq])
         } else if (feedAttr == 2) {
            ConcentrateQuality[iconc,iq+1] &lt;- feedAttr(name,qualities[iq])
         }
      }
      if (feedAttr == 1 || feedAttr == 3) {
         ForageQuality[iforage,1] &lt;- isource
         iforage &lt;- iforage + 1
      } else if (feedAttr == 2) {
         ConcentrateQuality[iconc,1] &lt;- isource
         iconc &lt;- iconc + 1
      }
      isource &lt;- isource + 1
   }

   Diet &lt;-list(concentratequantity=Conc_Quant,
               concentratequality=ConcentrateQuality,
               foragequantity=Forage_Quant,
               foragequality=ForageQuality)
   return(Diet)
}

# Define the diet (kg/hd/month) for one beast.
# Forages are equally presented, offers 
define_diet &lt;- function(AvailableToAnimal, ConcentrateAmount, pot_intake, herdsize, numSupplemented) {
   #Amount of concentrates according to age class and milk production
   numForage&lt;-numConc &lt;-0
   for (source in names(AvailableToAnimal)) {
      if (feedAttr(feedNames(AvailableToAnimal[[source]] )[1],"type") == 2) {
         numConc &lt;- numConc + 1
      } else {
         numForage&lt;- numForage + 1
      }   
   }
   Forage_Quant &lt;-matrix(nrow=numForage, ncol=2)
   Conc_Quant &lt;-matrix(nrow=numConc, ncol=2)
   isource &lt;- iconc &lt;- iforage &lt;- 1

   done &lt;- vector()
   # Take the highest ranking feeds first
   allocated &lt;- 0
   while (length(done) &lt; length(names(AvailableToAnimal))) {
      best &lt;- 0; bestclass &lt;- bestsource &lt;- ""
      for (source in names(AvailableToAnimal)) { 
         class &lt;-AvailableToAnimal[[source]]$element.1$CohortID
         if (!source %in% done &amp;&amp; FeedRank[[class]] &gt; best) {
            best &lt;- FeedRank[[class]]
            bestclass&lt;-class
            bestsource&lt;-source
         }
      }
      if (bestsource != "") {

        available &lt;- AvailableToAnimal[[bestsource]] 
        kg &lt;- max(0.0, AASum(available, "Weight") * available$area) ;# kg/ha -&gt; kg
        if ("ration" %in% names(available)) {
           kg &lt;- min(kg, available[["ration"]]) 
        } 
        feedType &lt;- feedAttr(feedNames(available)[1],"type")

        if (feedType != 2) {
           kg.hd &lt;- kg / herdsize
           kg.hd &lt;- min(pot_intake, kg.hd)
           Forage_Quant[iforage,1] &lt;- isource
           Forage_Quant[iforage,2] &lt;-  kg.hd
           iforage &lt;- iforage + 1
        } else {
           kg &lt;- min(kg, ConcentrateAmount)
           kg.hd &lt;- ifelse(numSupplemented &gt; 0, kg / numSupplemented, 0)
           Conc_Quant[iconc,1] &lt;- isource
           if (ConcentrateAmount &gt; 0) {
             Conc_Quant[iconc,2] &lt;-  max(0, min(kg.hd, ConcentrateAmount))
           } else {
             Conc_Quant[iconc,2] &lt;-  0.0
           }  
           iconc &lt;- iconc + 1
        }
        pot_intake &lt;- max(pot_intake - kg.hd, 0.0)
        cat (" offering", round(kg.hd,1), "kg from", AASum(available,"Weight") * available$area,"kg of", bestsource, "\n")
        done&lt;-c(done,bestsource)  
        isource &lt;- isource + 1
      } 
   } # while ...

   # Determine quality
   ForageQuality &lt;- matrix(ncol=14,nrow=numForage)
   ConcentrateQuality &lt;- matrix(ncol=14,nrow=numConc)
   isource&lt;- iconc &lt;- iforage &lt;- 1
   for (source in names(AvailableToAnimal)) {
      available &lt;- AvailableToAnimal[[source]]
      name &lt;- feedNames(available)[1]
      feedAttr &lt;- feedAttr(name,"type")
      qualities &lt;- c("dm","me","ge","fme","cp","adin","dmd","a","b","c","ndf","p","k")
      for (iq in 1:length(qualities)) {
         if (feedAttr == 1 || feedAttr == 3) {
            ForageQuality[iforage,iq+1] &lt;- feedAttr(name,qualities[iq])
         } else if (feedAttr == 2) {
            ConcentrateQuality[iconc,iq+1] &lt;- feedAttr(name,qualities[iq])
         }
      }
      if (feedAttr == 1 || feedAttr == 3) {
         ForageQuality[iforage,1] &lt;- isource
         iforage &lt;- iforage + 1
      } else if (feedAttr == 2) {
         ConcentrateQuality[iconc,1] &lt;- isource
         iconc &lt;- iconc + 1
      }
      isource &lt;- isource + 1
   }

   Diet &lt;-list(concentratequantity=Conc_Quant,
               concentratequality=ConcentrateQuality,
               foragequantity=Forage_Quant,
               foragequality=ForageQuality)
   return(Diet)
}

</text>
          <event>init</event>
        </script>
        <script>
          <text>    # register accumulators in the system for reporting
    for (source in names(FeedRank)) {
       name &lt;- paste(source, "_eaten", sep="")
       assign(name, 0.0)
       apsim$expose(name, "", get(name))
    }
</text>
          <event>start_simulation</event>
        </script>
        <script>
          <text>    for (source in names(FeedRank)) {
       name &lt;- paste(source, "_eaten", sep="")
       assign(name, 0.0)
    }
</text>
          <event>prepare</event>
        </script>
      </RLink>
      <RLink name="shoats">
        <ui>
          <category type="category" description="Manure handling" />
          <manureRecoveryFract type="text" description="Manure Recovery fraction (0-1)">0.0</manureRecoveryFract>
          <initialManureStore type="text" description="Initial amount of stored manure (kg)">0.0</initialManureStore>
          <uncollectedManureDest type="text" description="Destination of Uncollected Manure (paddock name)">verges</uncollectedManureDest>
          <collectedManureDest type="text" description="Destination of Stored Manure (paddock name)">plot1</collectedManureDest>
          <category type="category" description="Feeding" />
          <InitialFeedSources type="text" description="Initial feed source (module names)">bransupplement Groundnut_residue_store Sorghum_residue_store Mucuna_residue_store maize_residue_store verges.grasp magic</InitialFeedSources>
          <Concentrates type="text" description="Concentrate (feed name)">bran</Concentrates>
          <ConcentrateAmountFemale type="text" description="Amount of concentrate fed to productive females (kg/hd/month)">15</ConcentrateAmountFemale>
          <ConcentrateAmountAllElse type="text" description="Amount of concentrate fed to dry beasts (kg/hd/month)">0</ConcentrateAmountAllElse>
          <MaizeAmount type="text" description="Amount of maize residue fed (if available) (kg/hd/month)">30</MaizeAmount>
          <GroundnutAmount type="text" description="Amount of groundnut residue fed (if available) (kg/hd/month)">15</GroundnutAmount>
          <MucunaAmount type="text" description="Amount of mucuna residue fed (if available) (kg/hd/month)">30</MucunaAmount>
          <SorghumAmount type="text" description="Amount of sorghum residue fed (if available) (kg/hd/month)">30</SorghumAmount>
          <category type="category" description="Misc" />
          <doOutput type="text" description="Do output at endof timestep (T/F)">F</doOutput>
        </ui>
        <script>
          <text># Variables exported (rw) to apsim
age[name]                # age of each cow in herd
bw[name]                 # BW of each cow
sex[name]                # Sex of each cow
milk[name]
inputdmOf[name]          # Total DM eaten by herd
faecdmOf[name]           # Total manure produced by herd
faecnOf[name]            # Total N in manure produced by herd
milkOf[name]             # Total milk produced by herd
manurestore              # Size of manure store
FeedSources[name]        # The module name we ask for feed from
ConcentrateAmountFemale[name]  # How much concentrate to feed female goats
manureCollected[name] </text>
          <event>my variables</event>
        </script>
        <script>
          <text>
# Initialisation 
require( Rcpp )
library(abind)

# see if we've got the livsim code
if (!file.exists("LIVSIM_shoat/livsim_shoat.r")) {
  msg&lt;-"You need to obtain the LIVSIM source code from Mark.vanWijk@wur.nl\n"
  for (i in 1:10) {cat(msg)} ; flush(stdout());
  apsimFatal(msg)
}

# Manure handling
manurepaddock &lt;- "[collectedManureDest]"
apsim$expose("manurepaddock", "", manurepaddock )
manurestore &lt;- [initialManureStore]
manureNstore &lt;- manurestore * 0.1

# Feed sources &amp; quality
FeedSources[name] &lt;- unlist(strsplit("[InitialFeedSources]", " "))
FeedConcentrates &lt;-unlist(strsplit("[Concentrates]", " "))
ConcentrateAmountFemale[name] &lt;- [ConcentrateAmountFemale]
ConcentrateAmountAllElse[name] &lt;- [ConcentrateAmountAllElse]

# Buy &amp; sell routines. Called by something else in apsim
onBuyShoat &lt;- function (args) {
  cat("Buying ",args[["number"]], "x", args[["weight"]], "kg ",args$genotype, "shoat(s)\n"); flush.console()

  for (i in 1:args[["number"]]) {
     # Add a shoat to the herd.
     if (length(Goats) &gt; 0) {
       Goats &lt;&lt;- cbind(Goats, Initial_Goats[,1])
     } else {
       Goats &lt;&lt;- as.matrix(Initial_Goats[,1])
     }
     Goats[,ncol(Goats)]$sys$id &lt;&lt;- nb[name]
     Goats[,ncol(Goats)]$sys$damid &lt;&lt;- -1000 - Goats[,ncol(Goats)]$sys$id
     Goats[,ncol(Goats)]$char$age &lt;&lt;- args[["age"]]
     Goats[,ncol(Goats)]$char$lactind &lt;&lt;- 0
     Goats[,ncol(Goats)]$char$pregind &lt;&lt;- 0
     if (args[["sex"]] == "m" || args[["sex"]] == "M") {
       Goats[,ncol(Goats)]$char$sex &lt;&lt;- 0
     } else if (args[["sex"]] == "f" || args[["sex"]] == "F") {
       Goats[,ncol(Goats)]$char$sex &lt;&lt;- 1
     } else {
       error(paste("cant determine sex of ", args[["sex"]]))
     }
     Goats[,ncol(Goats)]$char$bw &lt;&lt;- args[["weight"]]
     #breed &lt;- ShoatBreed[[ args$genotype ]]
     #for (pname in names(breed)) {
     #   ShoatParam[[ pname ]] &lt;&lt;- breed[[ pname ]]
     #}
     ShoatParam$sys$nbgoats &lt;&lt;- ShoatParam$sys$nbgoats +1
     nb[name] &lt;&lt;- nb[name]+1
     numShoatsBrought &lt;&lt;- numShoatsBrought + 1
  }
  updateShoatVars()
}
apsim$subscribe("buy[name]", "Buy", "onBuyShoat")

onSellShoat &lt;- function (args) {
  Goat&lt;-Goats[,args$group]
  cat("Selling goat ", args$group, "sex=", ifelse(Goat$char$sex &lt; 0.5, "M", "F"), "age=", round(Goat$char$age,1), "bw=", Goat$char$bw, "\n")

  numShoatsSold &lt;&lt;- numShoatsSold + 1
  weightShoatsSold &lt;&lt;- weightShoatsSold + Goats[,args$group]$char$bw

  Goats &lt;&lt;- as.matrix(Goats[,-args$group])
  ShoatParam$sys$nbgoats &lt;&lt;- ShoatParam$sys$nbgoats - 1
  updateShoatVars()
}
apsim$subscribe("sell[name]", "Sell", "onSellShoat")

# Update the variables that are exposed to apsim
updateShoatVars &lt;- function () {
  inputdmOf[name] &lt;&lt;- 0; faecdmOf[name]&lt;&lt;- 0; faecnOf[name]&lt;&lt;- 0
  bw[name]&lt;&lt;-rep(0, ncol(Goats))
  age[name]&lt;&lt;-rep(0, ncol(Goats))
  sex[name]&lt;&lt;-rep("", ncol(Goats))
  inputdm[name] &lt;&lt;- rep(0, ncol(Goats))
  faecdm[name] &lt;&lt;- rep(0, ncol(Goats))
  faecn[name] &lt;&lt;- rep(0, ncol(Goats))
  herdsize_[name] &lt;&lt;- 0
  if (length(Goats) &gt; 0 ) {
    goat &lt;- 1
    for(goatnr in 1:ncol(Goats)) {
      if (Goats[,goatnr]$char$death == 0) {
        bw[name][goat] &lt;&lt;- Goats[,goatnr]$char$bw
        age[name][goat] &lt;&lt;- Goats[,goatnr]$char$age
        if (Goats[,goatnr]$char$sex &lt; 0.5) {
           sex[name][goat] &lt;&lt;- "M"
        } else {
           if (Goats[,goatnr]$char$calvind &gt; 0 &amp;&amp; Goats[,goatnr]$char$calvind&lt;=ShoatParam$lact$laclen &amp;&amp; 
              Goats[,goatnr]$char$feeddeficit==0 &amp;&amp; Goats[,goatnr]$char$lactind&gt;=0.01) {              
             sex[name][goat] &lt;&lt;- "FL"
           } else {
             sex[name][goat] &lt;&lt;- "F"
           }
        }
        inputdm[name][goat] &lt;&lt;- Goats[,goatnr]$input$dm
        faecdm[name][goat] &lt;&lt;- Goats[,goatnr]$out$faecdm
        faecn[name][goat] &lt;- Goats[,goatnr]$out$faecn
        milk[name][goat] &lt;- Goats[,goatnr]$out$milk
        goat&lt;-goat+1
      }
    }
    inputdmOf[name] &lt;&lt;- sum(inputdm[name])
    faecdmOf[name] &lt;&lt;- sum(faecdm[name])
    faecnOf[name] &lt;&lt;- sum(faecn[name])
    milkOf[name] &lt;&lt;- sum(milk[name])
    herdsize_[name] &lt;&lt;- ncol(Goats)
  }
}

bw[name] &lt;- vector()
age[name] &lt;- vector()
sex[name] &lt;- vector()
inputdm[name] &lt;- vector()
faecdm[name] &lt;- vector()
faecn[name] &lt;- vector()
milk[name] &lt;- vector()
inputdmOf[name] &lt;- 0
faecdmOf[name] &lt;- 0
faecnOf[name] &lt;- 0
milkOf[name] &lt;- 0


## APSIM specific routines                 
dumpit &lt;- function(list) {  if (class(list) == "list") {dumpit2("", list)} else {
 if (length(dim(list) &gt; 1)) {
   for (i in 1:nrow(list)) {cat (list[i,],"\n")}
 }else{  
  cat(list,"\n")
 } 
}}

dumpit2 &lt;- function(prefix, list) {
  for (x in names(list)) {
    if (class(list[[x]]) == "list") {
      dumpit2(paste(prefix,"$",x), list[[x]])
    } else if (length(dim(list[[x]]) &gt; 1)) {
      cat(prefix, "$", x, "=", nrow(list[[x]]),"x",ncol(list[[x]]), ":\n")
       for (i in 1:nrow(list[[x]])) {cat ( list[[x]][i,],"\n")}
    } else {
      cat(prefix, "$", x, "=", list[[x]], "\n")
    }
  }
}


isSupplemented[name] &lt;- function (Goat) {
  return ((Goat$char$age&gt;=0 &amp;&amp; Goat$char$age&lt;=0.25) ||
           (Goat$char$age&gt;3 &amp;&amp; Goat$out$milk&gt;0.001))
}

# Deal with manure production. Some may be stored for later application to a cropping paddock
manureCollected[name] &lt;- 0.0
doManure[name] &lt;- function (recoveryFract, uncollectedDest) { 
   manureCollected[name] &lt;&lt;- faecdmOf[name] * recoveryFract
   manureNCollected &lt;- faecnOf[name] * recoveryFract

   cat ("Collected manure (stored) = " , round(manureCollected[name],0) , " kg,", round(manureNCollected,1), "kg N \n");
   manurestore &lt;&lt;- manurestore + manureCollected[name]
   manureNstore &lt;&lt;- manureNstore + manureNCollected

   area&lt;-as.numeric(apsim$get(paste(uncollectedDest, "_area",sep="")))
   manureUnCollectedKgHa &lt;- faecdmOf[name] *
           (1.0 - recoveryFract) / area

   manureNUnCollectedKgHa &lt;- faecnOf[name] *
           (1.0 - recoveryFract) / area

   cat ("UnCollected manure (added to", uncollectedDest, "SOM pool) = " , 
          round(manureUnCollectedKgHa,0) , " kg/ha,", round(manureNUnCollectedKgHa,1), "kg/ha N \n")

   apsim$publish(paste(uncollectedDest,".SurfaceOrganicMatter.AddFaeces",sep=""),
                 "AddFaeces", list(OMWeight=manureUnCollectedKgHa, OMN=manureNUnCollectedKgHa, OMP=0))
}

# Apply any stored manure to nominated paddock when asked to
onApplyStoredManureXX &lt;- function (args) {
  manurearea &lt;- as.numeric(apsim$get(paste(manurepaddock,"_area",sep="")))

  cat ("Applying", manurestore, "kg manure to", manurepaddock, "SOM pool over", manurearea, "ha\n")

  manureAppliedKgHa &lt;- manurestore / manurearea
  manureNAppliedKgHa &lt;- manureNstore / manurearea

  if (manureAppliedKgHa  &gt; 0) {
    cat ("manure = " , manureAppliedKgHa , " kg/ha, ", manureNAppliedKgHa, "kg/ha N\n")
    apsim$publish(paste (manurepaddock,".SurfaceOrganicMatter.AddFaeces", sep=""),
                "AddFaeces", list(OMWeight=manureAppliedKgHa , OMN=manureNAppliedKgHa , OMP=0))
  }
  manurestore &lt;&lt;- 0.0
  manureNstore&lt;&lt;- 0.0
}

estimate_pot_intake_[name]&lt;-function(Goat)
  {
  min_dmd&lt;-0.7
  if (Goat$char$sex &gt; 0.5) {
     coefIntake&lt;- 1 ; #??approx(CowParam$lact$milkfatlp,CowParam$bw$intlact,Cow$char$lactind)
  } else {
     coefIntake&lt;-1
  }
  ## FIXME should be: Intake_forages = (130.9*(Feed$me_av/Feed$ge_av)+0.384*Goat$char$bw-18.75)*Goat$char$bw^0.75/1000*Param$sys$tfactor
  Intake_forages&lt;-(0.0107 * Goat$char$bw / (1 - min_dmd)) * 30.4 * coefIntake
  Intake_forages&lt;-max(Intake_forages, 1.5 * Goat$char$bw)

  return(Intake_forages)
}

apsim$subscribe("ApplyStoredManure", "NULL", "onApplyStoredManure")

title &lt;- apsim$get("title")

#-------------------LivSim-------------------
# Step 1: Initialise
#-------------------Reading input for LivSim-------------------
source("LIVSIM_shoat/input/input_livsim_shoat.r")
tmp &lt;-input_livsim_shoat()
Initial_Goats &lt;-tmp[[1]]
ShoatBreed  &lt;-tmp[[2]]
ShoatParam	&lt;-tmp[[3]]
ShoatMgmt	   &lt;-tmp[[4]]
#ForageQuality	&lt;-tmp[[5]]
#ConcentrateQuality &lt;-tmp[[6]]
rm(tmp)

#--------------------------------Setting auxiliary variables-------------------------
ShoatParam$sys$ylen 		 	   &lt;- 365
ShoatParam$sys$timestep 	 	 &lt;- ShoatParam$sys$tfactor / ShoatParam$sys$ylen
ShoatParam$sys$simulationstep &lt;- 12
ShoatParam$sys$monthstep      &lt;- ShoatParam$sys$ylen / 12 / ShoatParam$sys$ylen
ShoatParam$sys$simulationtime &lt;- 24
ShoatParam$sys$nbgoats 		   &lt;- 0
ShoatParam$milk_allowance 	 &lt;- 0.60   # Fraction of the produced milk that is given to the calf.
ShoatParam$max_conc        	 &lt;- 0.40   # Maximum contribution of concentrate to diet of cows as a fraction of the roughage dry matter intake
ShoatParam$calving_rate   	 &lt;- 0.95   # Calving rate (per year)
counter              	 &lt;- 1      # Internal variable

source("LIVSIM_shoat/check_shoat.r")

# Initial conditions - an empty herd.
nb[name]    &lt;-ShoatParam$sys$nbgoats
count_dead &lt;-0
Goats &lt;- define_shoat(0)

# Some modules are fussy over data type (eg string vs int) - register them here after declaration
herdsize_[name] &lt;- 0.0
apsim$expose("herdsize_[name]", "", herdsize_[name])

source("LIVSIM_shoat/livsim_shoat.r")
source("LIVSIM_shoat/potential_intake_shoat.r")
source("LIVSIM_shoat/mortality_shoat.r")
source("LIVSIM_shoat/updategoat_shoat.r")
source("LIVSIM_shoat/potential_growth_shoat.r")
source("LIVSIM_shoat/conception_shoat.r")
source("LIVSIM_shoat/walking_shoat.r")
source("LIVSIM_shoat/nutritive_requirements_shoat.r")
source("LIVSIM_shoat/gestation_shoat.r")
source("LIVSIM_shoat/lactation_shoat.r")
source("LIVSIM_shoat/actual_intake_shoat.r")
source("LIVSIM_shoat/manure_shoat.r")
source("LIVSIM_shoat/balance_check_shoat.r")
source("LIVSIM_shoat/urine_shoat.r")
source("LIVSIM_shoat/define_new_shoat.r")
source("LIVSIM_shoat/shoat_dead.r")
source("LIVSIM_shoat/shoat_replaced.r")

source("LIVSIM_shoat/feed_translation_shoat.r")
</text>
          <event>init</event>
        </script>
        <script>
          <text>
ConcentrateQuality &lt;-ForageQuality &lt;- FeedInput &lt;- AvailableToAnimal &lt;- list()

if (apsim$get("end_month")) {
   cat("[name]: ", ncol(Goats), " in herd\n")
  
   if (length(Goats) &gt; 0) {
    AvailableToAnimal &lt;- getFeedFromAPSIM(FeedSources[name])
    if ([MaizeAmount] &gt; 0 &amp;&amp; "maize_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["maize_residue_store"]]$ration &lt;- [MaizeAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["maize_residue_store"]]$ration &lt;- 0
    }
    if ([SorghumAmount] &gt; 0 &amp;&amp; "Sorghum_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Sorghum_residue_store"]]$ration &lt;- [SorghumAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Sorghum_residue_store"]]$ration &lt;- 0
    }
    if ([GroundnutAmount] &gt; 0 &amp;&amp; "Groundnut_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Groundnut_residue_store"]]$ration &lt;- [GroundnutAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Groundnut_residue_store"]]$ration &lt;- 0
    }
    if ([MucunaAmount] &gt; 0 &amp;&amp; "Mucuna_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Mucuna_residue_store"]]$ration &lt;- [MucunaAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Mucuna_residue_store"]]$ration &lt;- 0
    }
    AvailableToAnimal[["magic"]]$ration &lt;- 100000
    numSupplemented &lt;- 0
    for(cownr in 1:ncol(Goats)) {
       if (isSupplemented[name](Goats[,cownr])) {numSupplemented &lt;- numSupplemented + 1}
    }
    nbeforeKids&lt;-ncol(Goats)
    for(cownr in 1:nbeforeKids) {
      New_goat&lt;-matrix()
      Goat&lt;-Goats[,cownr]
      cat("Goat ", cownr, "sex=", ifelse(Goat$char$sex &lt; 0.5, "M", "F"), "age=", round(Goat$char$age,1), "bw=", Goat$char$bw, "\n")
      if(Goat$char$death==0 &amp;&amp; Goat$char$replaced==0) {
         ConcentrateAmount &lt;- ifelse(isSupplemented[name](Goat), ConcentrateAmountFemale[name], ConcentrateAmountAllElse[name])
         #for (conc in FeedConcentrates) { AvailableToAnimal[[conc]]$ration &lt;- ConcentrateAmount }
         Diet &lt;- define_diet(AvailableToAnimal, ConcentrateAmount, estimate_pot_intake_[name](Goat), nbeforeKids, numSupplemented)
         source("LIVSIM_shoat/livsim_shoat.r")
         tmp 	&lt;-livsim_shoat(Goat,Goats,ShoatParam,ShoatMgmt,ShoatBreed,Diet,nb[name])
         Goat_new   &lt;-tmp[[1]]
         New_goat   &lt;-tmp[[2]]
         nb[name]   &lt;-tmp[[3]]
         Feed       &lt;-tmp[[4]]
         ShoatParam &lt;-tmp[[5]]
         Kids       &lt;-tmp[[6]]
         rm(tmp)
      } else if(Goat$char$death==1) {
         cat("Shoat has died ", cownr, "bw=", Goat$char$bw, "\n")
         source("LIVSIM_shoat/define_new_shoat.r")
         Goat_new &lt;-define_new_shoat()
         source("LIVSIM_shoat/shoat_dead.r")
         Goat_new	 &lt;- shoat_dead(Goat,Goat_new)
         count_dead &lt;- count_dead+1
      } else if(Goat$char$replaced==1) {
         source("LIVSIM_shoat/define_new_shoat.r")
         Goat_new &lt;-define_new_shoat()
         source("LIVSIM_shoat/shoat_replaced.r")
         Goat_new		   &lt;- shoat_replaced(Goat,Goat_new)
         count_replaced &lt;- count_replaced+1
      } else {
         Goat_new &lt;- Goat
      }
      Goats[,cownr] &lt;- Goat_new
      if(!is.na(New_goat[[1]][2])) {
         Goats&lt;-cbind(Goats,New_goat,deparse.level=0)
      }
    }

    # prune off any fully dead animals 
    deadInHerd &lt;- TRUE
    while (deadInHerd &amp;&amp; length(Goats) &gt; 0) {
      deadInHerd &lt;- FALSE
      for(cownr in 1:ncol(Goats)) {
        if(Goats[,cownr]$char$death==2) {
          cat ("Removing dead shoat\n")
          Goats&lt;- as.matrix(Goats[,-cownr])
          deadInHerd &lt;- TRUE
          break
        }
      }
    }
   }

   updateShoatVars()
 
   if (inputdmOf[name] &gt; 0) {
     remaining &lt;- inputdmOf[name]
     done &lt;- vector()
     # Take the highest ranking feeds first
     cat ("[name] eating", round(inputdmOf[name],1), "kg\n")
     while (length(done) &lt; length(names(AvailableToAnimal))) {
        best &lt;- 0; bestclass &lt;- bestsource &lt;- ""
        for (source in names(AvailableToAnimal)) { 
           class &lt;-AvailableToAnimal[[source]]$element.1$CohortID
           if (!source %in% done &amp;&amp; FeedRank[[class]] &gt; best) {
              best &lt;- FeedRank[[class]]
              bestclass&lt;-class
              bestsource&lt;-source
           }
        }
        if (bestsource != "") {
          if (feedAttr(bestclass, "type") == 2) {
            # work out the ration fed to entire herd
            amount_kg &lt;-ConcentrateAmountFemale[name] * numSupplemented + ConcentrateAmountAllElse[name] * (herdsize_[name] - numSupplemented)
            amount_kg &lt;- min(remaining, amount_kg)
            AvailableToAnimal[[bestsource]]$ration &lt;- amount_kg 
            eaten &lt;- doDietSelection(amount_kg / AvailableToAnimal[[bestsource]]$area, 
                                  AvailableToAnimal[[bestsource]])
          } else {
            eaten &lt;- doDietSelection(remaining / AvailableToAnimal[[bestsource]]$area, 
                                        AvailableToAnimal[[bestsource]])
          }                            
          removed_kg &lt;- AASum(eaten,"WeightRemoved") * eaten$area
          remaining &lt;- remaining - removed_kg
          cat ("[name] eating", round(removed_kg,1), "kg from", AASum(eaten,"Weight") * eaten$area,"kg of", bestsource, "\n")
          apsim$set(paste(bestsource,"RemovedByAnimal",sep="."), list("RemovedByAnimal", eaten))

          accumName &lt;- paste(bestclass, "_eaten", sep="")
          assign(accumName, removed_kg + get(accumName), envir = .GlobalEnv)
        }
        done&lt;-c(done,bestsource)  
     }
     if (remaining &gt; 0) {
        cat("WARNING - [name] eating more feed (", remaining, " kg) than available!!\n")
     }
   }
   manureCollected[name] &lt;- 0.0
   if (faecdmOf[name] &gt; 0) {
     cat ("Total manure production = " , round(faecdmOf[name],1) , " kg\n");
     doManure[name]([manureRecoveryFract], "[uncollectedManureDest]")
   }
   if ([doOutput]) {
     apsim$publish("livsimoutput.do_output", "Null", list())
   }
}</text>
          <event>do_stock</event>
        </script>
      </RLink>
      <RLink name="cows">
        <ui>
          <category type="category" description="Manure handling" />
          <manureRecoveryFract type="text" description="Manure Recovery fraction (0-1)">0.3</manureRecoveryFract>
          <initialManureStore type="text" description="Initial amount of stored manure (kg)">200.0</initialManureStore>
          <uncollectedManureDest type="text" description="Destination of Uncollected Manure (paddock name)">verges</uncollectedManureDest>
          <collectedManureDest type="text" description="Destination of Stored Manure (paddock name)">plot1</collectedManureDest>
          <category type="category" description="Feeding" />
          <InitialFeedSources type="text" description="Initial feed source (module names)">bransupplement Groundnut_residue_store Mucuna_residue_store Sorghum_residue_store maize_residue_store verges.grasp magic</InitialFeedSources>
          <Concentrates type="text" description="Concentrate (feed name)">bran</Concentrates>
          <ConcentrateAmountFemale type="text" description="Amount of concentrate fed to productive females (kg/hd/month)">30</ConcentrateAmountFemale>
          <ConcentrateAmountAllElse type="text" description="Amount of concentrate fed to dry beasts (kg/hd/month)">0</ConcentrateAmountAllElse>
          <MaizeAmount type="text" description="Amount of maize residue fed (if available) (kg/hd/month)">45</MaizeAmount>
          <GroundnutAmount type="text" description="Amount of groundnut residue fed (if available) (kg/hd/month)">0</GroundnutAmount>
          <MucunaAmount type="text" description="Amount of mucuna residue fed (if available) (kg/hd/month)">0</MucunaAmount>
          <SorghumAmount type="text" description="Amount of sorghum residue fed (if available) (kg/hd/month)">0</SorghumAmount>
          <category type="category" description="Misc" />
          <doOutput type="text" description="Do output at end of timestep (T/F)">T</doOutput>
        </ui>
        <script>
          <text># Variables exported (rw) to apsim
age[name]                # age of each cow in herd
bw[name]                 # BW of each cow
sex[name]                # Sex of each cow
milk[name]               # Milk of each cow
inputdmOf[name]          # Total DM eaten by herd
faecdmOf[name]           # Total manure produced by herd
faecnOf[name]            # Total N in manure produced by herd
milkOf[name]             # Total milk produced by herd
manurestore              # Size of manure store
FeedSources[name]        # The module name we ask for feed from
ConcentrateAmountFemale[name]  # How much concentrate to feed female cows
manureCollected[name] </text>
          <event>my variables</event>
        </script>
        <script>
          <text>

# Initialisation 
require( Rcpp )
library(abind)

# see if we've got the livsim code
if (!file.exists("LIVSIM/livsim.r")) {
  msg&lt;-"You need to obtain the LIVSIM source code from Mark.vanWijk@wur.nl\n"
  for (i in 1:10) {cat(msg)} ; flush(stdout());
  apsimFatal(msg)
}

# Manure handling
manurepaddock &lt;- "[collectedManureDest]"
apsim$expose("manurepaddock", "", manurepaddock )

manurestore &lt;- [initialManureStore]
manureNstore &lt;- manurestore * 0.1

# Feed sources &amp; quality
FeedSources[name] &lt;- unlist(strsplit("[InitialFeedSources]", " "))
FeedConcentrates &lt;-unlist(strsplit("[Concentrates]", " "))
ConcentrateAmountFemale[name] &lt;- [ConcentrateAmountFemale]
ConcentrateAmountAllElse[name] &lt;- [ConcentrateAmountAllElse]

# Buy &amp; sell routines. Called by something else in apsim
onBuyCow &lt;- function (args) {
  cat("Buying ",args[["number"]], "x", args[["weight"]], "kg ",args$genotype, "cow(s)\n"); flush.console()

  for (i in 1:args[["number"]]) {
     # Add a shoat to the herd.
     if (length(Cows) &gt; 0) {
       Cows &lt;&lt;- cbind(Cows, Initial_Cows[,1])
     } else {
       Cows &lt;&lt;- as.matrix(Initial_Cows[,1])
     }
     Cows[,ncol(Cows)]$sys$id &lt;&lt;- nb[name]
     Cows[,ncol(Cows)]$sys$damid &lt;&lt;- -1000 - Cows[,ncol(Cows)]$sys$id
     Cows[,ncol(Cows)]$char$age &lt;&lt;- args[["age"]]
     Cows[,ncol(Cows)]$char$lactind &lt;&lt;- 0
     Cows[,ncol(Cows)]$char$pregind &lt;&lt;- 0
     Cows[,ncol(Cows)]$char$death &lt;&lt;-0
     Cows[,ncol(Cows)]$char$feeddeficit &lt;&lt;- 0 
     Cows[,ncol(Cows)]$char$calvind &lt;&lt;- 0 

     if (args[["sex"]] == "m" || args[["sex"]] == "M") {
       Cows[,ncol(Cows)]$char$sex &lt;&lt;- 0
     } else if (args[["sex"]] == "f" || args[["sex"]] == "F") {
       Cows[,ncol(Cows)]$char$sex &lt;&lt;- 1
     } else {
       error(paste("cant determine sex of ", args[["sex"]]))
     }
     Cows[,ncol(Cows)]$char$bw &lt;&lt;- args[["weight"]]
     breed &lt;- CowBreed[[ args$genotype ]]
     for (pname in names(breed)) {
        CowParam[[ pname ]] &lt;&lt;- breed[[ pname ]]
     }
     CowParam$sys$nbCows &lt;&lt;- CowParam$sys$nbCows +1
     nb[name] &lt;&lt;- nb[name]+1
     numCowsBrought &lt;&lt;- numCowsBrought + 1
  }
  updateCowVars()
}
apsim$subscribe("buy[name]", "Buy", "onBuyCow")

onSellCow &lt;- function (args) {
  Cow&lt;-Cows[,args$group]
  cat("Selling Cow", args$group, "sex=", ifelse(Cow$char$sex &lt; 0.5, "M", "F"), "age=", round(Cow$char$age,1), "bw=", Cow$char$bw, "\n")

  numCowsSold &lt;&lt;- numCowsSold + 1
  weightCowsSold &lt;&lt;- weightCowsSold + Cows[,args$group]$char$bw

  Cows &lt;&lt;- as.matrix(Cows[,-args$group])
  CowParam$sys$nbcows &lt;&lt;- CowParam$sys$nbcows - 1
  updateCowVars()
}
apsim$subscribe("sell[name]", "Sell", "onSellCow")

# Update the variables that are exposed to apsim
updateCowVars &lt;- function () {
  inputdmOf[name] &lt;&lt;- 0; faecdmOf[name]&lt;&lt;- 0; faecnOf[name]&lt;&lt;- 0
  bw[name]&lt;&lt;-rep(0, ncol(Cows))
  age[name]&lt;&lt;-rep(0, ncol(Cows))
  sex[name]&lt;&lt;-rep("", ncol(Cows))
  inputdm[name] &lt;&lt;- rep(0, ncol(Cows))
  faecdm[name] &lt;&lt;- rep(0, ncol(Cows))
  faecn[name] &lt;&lt;- rep(0, ncol(Cows))
  milk[name] &lt;&lt;- rep(0, ncol(Cows))
  herdsize_[name] &lt;&lt;- 0
  if (length(Cows) &gt; 0 ) {
    cow &lt;- 1
    for(cownr in 1:ncol(Cows)) {
      if (Cows[,cownr]$char$death == 0) {
        bw[name][cow] &lt;&lt;- Cows[,cownr]$char$bw
        age[name][cow] &lt;&lt;- Cows[,cownr]$char$age
        if (Cows[,cownr]$char$sex &lt; 0.5) {
           sex[name][cow] &lt;&lt;- "M"
        } else {
           if (Cows[,cownr]$char$calvind &gt; 0 &amp;&amp; Cows[,cownr]$char$calvind&lt;= CowParam$lact$maxlength * CowParam$sys$monthstep &amp;&amp; 
              Cows[,cownr]$char$feeddeficit==0 &amp;&amp; Cows[,cownr]$char$lactind&gt;=0.01) {              
             sex[name][cow] &lt;&lt;- "FL"
           } else {
             sex[name][cow] &lt;&lt;- "F"
           }
        }
        inputdm[name][cow] &lt;&lt;- Cows[,cownr]$input$dm
        faecdm[name][cow] &lt;&lt;- Cows[,cownr]$out$faecdm
        faecn[name][cow] &lt;- Cows[,cownr]$out$faecn
        milk[name][cow] &lt;- Cows[,cownr]$out$milk
        cow&lt;-cow+1
      }
    }
    inputdmOf[name] &lt;&lt;- sum(inputdm[name])
    faecdmOf[name] &lt;&lt;- sum(faecdm[name])
    faecnOf[name] &lt;&lt;- sum(faecn[name])
    milkOf[name] &lt;&lt;- sum(milk[name])
    herdsize_[name] &lt;&lt;- ncol(Cows)
  }
}

bw[name] &lt;- vector()
age[name] &lt;- vector()
sex[name] &lt;- vector()
inputdm[name] &lt;- vector()
faecdm[name] &lt;- vector()
faecn[name] &lt;- vector()
milk[name] &lt;- vector()
inputdmOf[name] &lt;- 0
faecdmOf[name] &lt;- 0
faecnOf[name] &lt;- 0
milkOf[name] &lt;- 0
manurearea &lt;- 0

## APSIM specific routines                 
dumpit &lt;- function(list) {  if (class(list) == "list") {dumpit2("", list)} else {
 if (length(dim(list) &gt; 1)) {
   for (i in 1:nrow(list)) {cat (list[i,],"\n")}
 }else{  
  cat(list,"\n")
 } 
}}

dumpit2 &lt;- function(prefix, list) {
  for (x in names(list)) {
    if (class(list[[x]]) == "list") {
      dumpit2(paste(prefix,"$",x), list[[x]])
    } else if (length(dim(list[[x]]) &gt; 1)) {
      cat(prefix, "$", x, "=", nrow(list[[x]]),"x",ncol(list[[x]]), ":\n")
       for (i in 1:nrow(list[[x]])) {cat ( list[[x]][i,],"\n")}
    } else {
      cat(prefix, "$", x, "=", list[[x]], "\n")
    }
  }
}

# FIXME!
isSupplemented[name] &lt;- function (cow) {
  return ((cow$char$age&gt;=0 &amp;&amp; cow$char$age&lt;=0.25) ||
           (cow$char$age&gt;3 &amp;&amp; cow$out$milk&gt;0.001))
}

# Deal with manure production. Some may be stored for later application to a cropping paddock
manureCollected[name] &lt;- 0.0
doManure[name] &lt;- function (recoveryFract, uncollectedDest) { 
   manureCollected[name] &lt;&lt;- faecdmOf[name] * recoveryFract
   manureNCollected &lt;- faecnOf[name] * recoveryFract

   cat ("Collected manure (stored) = " , round(manureCollected[name],0) , " kg,", round(manureNCollected,1), "kg N \n");
   manurestore &lt;&lt;- manurestore + manureCollected[name]
   manureNstore &lt;&lt;- manureNstore + manureNCollected

   area&lt;-as.numeric(apsim$get(paste(uncollectedDest, "_area",sep="")))
   manureUnCollectedKgHa &lt;- faecdmOf[name] *
           (1.0 - recoveryFract) / area

   manureNUnCollectedKgHa &lt;- faecnOf[name] *
           (1.0 - recoveryFract) / area

   cat ("UnCollected manure (added to", uncollectedDest, "SOM pool) = " , 
          round(manureUnCollectedKgHa,0) , " kg/ha,", round(manureNUnCollectedKgHa,1), "kg/ha N \n")

   apsim$publish(paste(uncollectedDest,".SurfaceOrganicMatter.AddFaeces",sep=""),
                 "AddFaeces", list(OMWeight=manureUnCollectedKgHa, OMN=manureNUnCollectedKgHa, OMP=0))
   manurearea  &lt;&lt;- as.numeric(apsim$get(paste("area.", manurepaddock, "_area",sep="")))
}

# Apply any stored manure to nominated paddock when asked to
onApplyStoredManure &lt;- function () {
  manurearea  &lt;- as.numeric(apsim$get(paste( manurepaddock, "_area",sep=""))) 
  if (manurearea &gt; 0 &amp;&amp; manurestore &gt; 0) {
    cat ("Applying", manurestore, "kg manure to", manurepaddock, "SOM pool over", manurearea, "ha\n")

    manureAppliedKgHa &lt;- manurestore / manurearea
    manureNAppliedKgHa &lt;- manureNstore / manurearea

    if (manureAppliedKgHa  &gt; 0) {
      apsim$publish(paste (manurepaddock,".SurfaceOrganicMatter.AddFaeces", sep=""),
                   "AddFaeces", list(OMWeight=manureAppliedKgHa , OMN=manureNAppliedKgHa , OMP=0))
    }
  }
  manurestore &lt;&lt;- 0.0
  manureNstore&lt;&lt;- 0.0
}
apsim$subscribe("ApplyStoredManure", "NULL", "onApplyStoredManure")

title &lt;- apsim$get("title")

estimate_pot_intake_[name]&lt;-function(Cow)
  {
  min_dmd&lt;-0.7
  if (Cow$char$sex==1) {
     coefIntake&lt;- 1 ; #??approx(CowParam$lact$milkfatlp,CowParam$bw$intlact,Cow$char$lactind)
  } else {
     coefIntake&lt;-1
  }
  Intake_forages&lt;-(0.0107 * Cow$char$bw / (1 - min_dmd)) * 30.4 * coefIntake
  return(Intake_forages)
}

#-------------------LivSim-------------------
# Step 1: Initialise
#-------------------Reading input for LivSim-------------------
source("LIVSIM/input/input_livsim.r")
tmp &lt;-input_livsim()
Initial_Cows &lt;-tmp[[1]]
CowBreed  &lt;-tmp[[2]]
CowParam	&lt;-tmp[[3]]
CowMgmt	   &lt;-tmp[[4]]
rm(tmp)

#--------------------------------Setting auxiliary variables-------------------------
CowParam$sys$ylen 		 	   &lt;- 365
CowParam$sys$timestep 	 	 &lt;- CowParam$sys$tfactor / CowParam$sys$ylen
CowParam$sys$simulationstep &lt;- 12
CowParam$sys$monthstep      &lt;- CowParam$sys$ylen / 12 / CowParam$sys$ylen
CowParam$sys$simulationtime &lt;- 24
CowParam$sys$nbcows 		   &lt;- 0
CowParam$milk_allowance 	 &lt;- 0.60   # Fraction of the produced milk that is given to the calf.
CowParam$max_conc        	 &lt;- 0.40   # Maximum contribution of concentrate to diet of cows as a fraction of the roughage dry matter intake
CowParam$calving_rate   	 &lt;- 0.95   # Calving rate (per year)
counter              	 &lt;- 1      # Internal variable

source("LIVSIM/check.r")

# Initial conditions - an empty herd.
nb[name]    &lt;-CowParam$sys$nbcows
count_dead &lt;-0

source("LIVSIM/input/define_cows.r")
Cows &lt;- define_cows(0)

# Some modules are fussy over data type (eg string vs int) - register them here after declaration
herdsize_[name] &lt;- 0.0
apsim$expose("herdsize_[name]", "", herdsize_[name])

source("LIVSIM/livsim.r")
source("LIVSIM/feed_translation.r")
source("LIVSIM/parameters.r")
source("LIVSIM/potential_intake.r")
source("LIVSIM/mortality.r")
source("LIVSIM/updatecow.r")
source("LIVSIM/potential_growth.r")
source("LIVSIM/calving.r")
source("LIVSIM/conception.r")
source("LIVSIM/walking.r")
source("LIVSIM/nutritive_requirements.r")
source("LIVSIM/gestation.r")
source("LIVSIM/lactation.r")
source("LIVSIM/actual_intake.r")
source("LIVSIM/manure.r")
source("LIVSIM/balance_check.r")
source("LIVSIM/urine.r")
source("LIVSIM/define_Cow_new.r")
source("LIVSIM/cow_dead.r")
source("LIVSIM/cow_replaced.r")
</text>
          <event>init</event>
        </script>
        <script>
          <text>

ConcentrateQuality &lt;-ForageQuality &lt;- FeedInput &lt;- AvailableToAnimal &lt;- list()

if (apsim$get("end_month")) {
   cat("[name]: ", ncol(Cows), " in herd\n")
  
   if (length(Cows) &gt; 0) {
    AvailableToAnimal &lt;- getFeedFromAPSIM(FeedSources[name])
    if ([MaizeAmount] &gt; 0 &amp;&amp; "maize_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["maize_residue_store"]]$ration &lt;- [MaizeAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["maize_residue_store"]]$ration &lt;- 0
    }
    if ([SorghumAmount] &gt; 0 &amp;&amp; "Sorghum_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Sorghum_residue_store"]]$ration &lt;- [SorghumAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Sorghum_residue_store"]]$ration &lt;- 0
    }
    if ([GroundnutAmount] &gt; 0 &amp;&amp; "Groundnut_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Groundnut_residue_store"]]$ration &lt;- [GroundnutAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Groundnut_residue_store"]]$ration &lt;- 0
    }
    if ([MucunaAmount] &gt; 0 &amp;&amp; "Mucuna_residue_store" %in% FeedSources[name]) {
      AvailableToAnimal[["Mucuna_residue_store"]]$ration &lt;- [MucunaAmount] * herdsize_[name]
    } else {
      AvailableToAnimal[["Mucuna_residue_store"]]$ration &lt;- 0
    }
    AvailableToAnimal[["magic"]]$ration &lt;- 100000
    numSupplemented &lt;- 0
    for(cownr in 1:ncol(Cows)) {
       if (isSupplemented[name](Cows[,cownr])) {numSupplemented &lt;- numSupplemented + 1}
    }
    nbeforeCalves&lt;-ncol(Cows)
    for(cownr in 1:nbeforeCalves) {
      New_cow&lt;-matrix()
      cow&lt;-Cows[,cownr]
      cat("cow ", cownr, "sex=", ifelse(cow$char$sex &lt; 0.5, "M", "F"), "age=", round(cow$char$age,1), "bw=", cow$char$bw, "\n")
      if(cow$char$death==0 &amp;&amp; cow$char$replaced==0) {
         ConcentrateAmount &lt;- ifelse(isSupplemented[name](cow), ConcentrateAmountFemale[name], ConcentrateAmountAllElse[name])
         #for (conc in FeedConcentrates) { AvailableToAnimal[[conc]]$ration &lt;- ConcentrateAmount }
         Diet &lt;- define_diet(AvailableToAnimal, ConcentrateAmount, estimate_pot_intake_[name](cow), nbeforeCalves, numSupplemented)
         source("LIVSIM/livsim.r")
         tmp 	&lt;-livsim(cow,Cows,CowParam,CowMgmt,CowBreed,Diet,nb[name])
         cow_new   &lt;-tmp[[1]]
         New_cow   &lt;-tmp[[2]]
         nb[name]    &lt;-tmp[[3]]
         Feed       &lt;-tmp[[4]]
         CowParam &lt;-tmp[[5]]
         Calves     &lt;-tmp[[6]]
         rm(tmp)
      } else if(cow$char$death==1) {
         cat("Cow has died ", cownr, "bw=", cow$char$bw, "\n")
         source("LIVSIM/define_Cow_new.r")
         cow_new &lt;-define_Cow_new()
         source("LIVSIM/cow_dead.r")
         cow_new	 &lt;- cow_dead(cow,cow_new)
         count_dead &lt;- count_dead+1
      } else if(cow$char$replaced==1) {
         source("LIVSIM/define_Cow_new.r")
         cow_new &lt;-define_Cow_new()
         source("LIVSIM/cow_replaced.r")
         cow_new		   &lt;- cow_replaced(cow,cow_new)
         count_replaced &lt;- count_replaced+1
      } else {
         cow_new &lt;- cow
      }
      Cows[,cownr] &lt;- cow_new
      if(!is.na(New_cow[[1]][2])) {
         Cows&lt;-cbind(Cows,New_cow,deparse.level=0)
      }
    }

    # prune off any fully dead animals 
    deadInHerd &lt;- TRUE
    while (deadInHerd &amp;&amp; length(Cows) &gt; 0) {
      deadInHerd &lt;- FALSE
      for(cownr in 1:ncol(Cows)) {
        if(Cows[,cownr]$char$death==2) {
          cat ("Removing dead cow\n")
          Cows&lt;- as.matrix(Cows[,-cownr])
          deadInHerd &lt;- TRUE
          break
        }
      }
    }
   }

   updateCowVars()
 
   if (inputdmOf[name] &gt; 0) {
     remaining &lt;- inputdmOf[name]
     done &lt;- vector()
     # Take the highest ranking feeds first
     cat ("[name] eating", round(inputdmOf[name],1), "kg\n")
     while (length(done) &lt; length(names(AvailableToAnimal))) {
        best &lt;- 0; bestclass &lt;- bestsource &lt;- ""
        for (source in names(AvailableToAnimal)) { 
           class &lt;-AvailableToAnimal[[source]]$element.1$CohortID
           if (!source %in% done &amp;&amp; FeedRank[[class]] &gt; best) {
              best &lt;- FeedRank[[class]]
              bestclass&lt;-class
              bestsource&lt;-source
           }
        }
        if (bestsource != "") {
          if (feedAttr(bestclass, "type") == 2) {
            amount_kg &lt;-ConcentrateAmountFemale[name] * numSupplemented + ConcentrateAmountAllElse[name] * (herdsize_[name] - numSupplemented)
            amount_kg &lt;- min(remaining, amount_kg)  
            AvailableToAnimal[[bestsource]]$ration &lt;- amount_kg
            eaten &lt;- doDietSelection(amount_kg / AvailableToAnimal[[bestsource]]$area, 
                                  AvailableToAnimal[[bestsource]])
          } else {
            eaten &lt;- doDietSelection(remaining / AvailableToAnimal[[bestsource]]$area, 
                                        AvailableToAnimal[[bestsource]])
          }                            
          removed_kg &lt;- AASum(eaten,"WeightRemoved") * eaten$area
          remaining &lt;- remaining - removed_kg
          cat ("[name] eating", round(removed_kg,1), "kg from", AASum(eaten,"Weight") * eaten$area,"kg of", bestsource, "\n")
          apsim$set(paste(bestsource,"RemovedByAnimal",sep="."), list("RemovedByAnimal", eaten))

          accumName &lt;- paste(bestclass, "_eaten", sep="")
          assign(accumName, removed_kg + get(accumName), envir = .GlobalEnv)
        }
        done&lt;-c(done,bestsource)  
     }
     if (remaining &gt; 0) {
        cat("WARNING - [name] eating more feed (", remaining, " kg) than available!!\n")
     }
   }

   manureCollected[name] &lt;- 0.0
   if (faecdmOf[name] &gt; 0) {
     cat ("Total manure production = " , round(faecdmOf[name],1) , " kg\n")
     doManure[name]([manureRecoveryFract], "[uncollectedManureDest]")
   }
   if ([doOutput]) {
     apsim$publish("livsimoutput.do_output", "Null", list())
   }
}</text>
          <event>do_stock</event>
        </script>
      </RLink>
      <RLink name="Ind Tracker">
        <script>
          <text>#Save a file of each individual animal's growth curve. Used for custom chart

indivCows&lt;-NULL
indivGoats&lt;-NULL</text>
          <event>init</event>
        </script>
        <script>
          <text>
if (apsim$get("end_month")) {
  today&lt;-paste(apsim$get("dd_mmm"), apsim$get("year"), sep="_") 
  if (length(Cows) &gt; 0) {
    for(cownr in 1:ncol(Cows)) {
      indivCows &lt;- rbind(indivCows,  c(today, Cows[,cownr]$sys$id, Cows[,cownr]$char$bw))
    }
  }
  if (length(Goats) &gt; 0) {
    for(cownr in 1:ncol(Goats)) {
      indivGoats &lt;- rbind(indivGoats,  c(today, Goats[,cownr]$sys$id, Goats[,cownr]$char$bw))
    }
  }
}</text>
          <event>do_stock</event>
        </script>
        <script>
          <text>
if (length(indivCows) &gt; 0) {
  indivCows &lt;- as.data.frame(indivCows)
  names(indivCows) &lt;- c("date","id", "Weight")
  indivCows$date &lt;- as.Date(indivCows$date, "%d_%b_%Y")
  indivCows$id&lt;-as.numeric(as.character(indivCows$id))
  indivCows$Weight&lt;-as.numeric(as.character(indivCows$Weight))
  write.csv(indivCows , file=paste(apsim$get("title"),"individual Cows.csv"),row.names=F)
}
 
if (length(indivGoats) &gt; 0) {
  indivGoats &lt;- as.data.frame(indivGoats)
  names(indivGoats) &lt;- c("date","id", "Weight")
  indivGoats$date &lt;- as.Date(indivGoats$date, "%d_%b_%Y")
  indivGoats$id&lt;-as.numeric(as.character(indivGoats$id))
  indivGoats$Weight&lt;-as.numeric(as.character(indivGoats$Weight))
  write.csv(indivGoats , file=paste(apsim$get("title"),"individual Goats.csv"),row.names=F)
}</text>
          <event>end_simulation</event>
        </script>
      </RLink>
      <RLink name="Run Summary">
        <script>
          <text>
# Run summary

# number of kids/cows sold
numCowsSold &lt;- 0
numShoatsSold &lt;- 0
numCowsBrought &lt;- 0
numShoatsBrought &lt;- 0
# weight of kids/cows sold
weightCowsSold &lt;- 0
weightShoatsSold &lt;- 0
# milk of kids/cows sold
milkCowsProduced &lt;- 0
milkShoatsProduced &lt;- 0
# manure 
manureCollectedTotal &lt;- 0
</text>
          <event>init</event>
        </script>
        <script>
          <text>
if (apsim$get("end_month")) {
  if (length(Cows) &gt; 0) {
    for(cownr in 1:ncol(Cows)) {
       milkCowsProduced  &lt;- milkCowsProduced  + Cows[,cownr]$out$milk
    }
  }
  if (length(Goats) &gt; 0) {
    for(cownr in 1:ncol(Goats)) {
       milkShoatsProduced  &lt;- milkShoatsProduced  + Goats[,cownr]$out$milk
    }
  }
  manureCollectedTotal &lt;- manureCollectedTotal + manureCollectedcows + manureCollectedshoats
}
</text>
          <event>do_stock</event>
        </script>
        <script>
          <text>
cat("\"numCowsBrought\",\"numCowsSold\",\"numShoatsBrought\",\"numShoatsSold\",\"weightCowsSold\",\"weightShoatsSold\",\"milkCowsProduced\",\"milkShoatsProduced\",\"manureCollectedTotal\"\n",
  numCowsBrought, ",",numCowsSold, ",", numShoatsBrought, ",",numShoatsSold, ",",weightCowsSold, ",",weightShoatsSold,",",milkCowsProduced,",",milkShoatsProduced,",",manureCollectedTotal,"\n", 
  file=paste(apsim$get("title"),"run summary.csv") )</text>
          <event>end_simulation</event>
        </script>
      </RLink>
    </folder>
    <area name="plot1">
      <surfaceom name="SurfaceOrganicMatter">
        <PoolName type="text" description="Organic Matter pool name">maize_stubble</PoolName>
        <type type="list" listvalues="bambatsi,barley,base_type,broccoli,camaldulensis,canola,centro,chickpea,chikenmanure_base,cm,cmA,cmB,constants,cotton,cowpea,danthonia,navybean,fieldpea,fym,gbean,globulus,goatmanure,grandis,grass,horsegram,inert,lablab,lentil,lucerne,lupin,maize,manB,manure,medic,millet,mucuna,nativepasture,navybean,oats,orobanche,peanut,pigeonpea,potato,rice,sorghum,soybean,stylo,sugar,sunflower,sweetcorn,sweetsorghum,tillage,tithonia,vetch,weed,WF_Millet,wheat" description="Organic Matter type">maize</type>
        <mass type="text" description="Initial surface residue (kg/ha)">100.</mass>
        <cnr type="text" description="C:N ratio of initial residue">80.0</cnr>
        <cpr type="text" description="C:P ratio of initial residue (optional)" />
        <standing_fraction type="text" description="Fraction of residue standing">0.0</standing_fraction>
      </surfaceom>
      <fertiliser name="Fertiliser" />
      <maize />
      <sorghum />
      <peanut />
      <mucuna />
      <weed />
      <canopy>
        <intercrop type="text" description="Enter crop names to intercrop">maize sorghum peanut mucuna weed</intercrop>
      </canopy>
      <erosion name="Erosion">
        <model description="Model Name">freebairn</model>
        <slope description="Slope of plot in percent (%)">0.5</slope>
        <slope_length description="Length of plot (m)">60.0</slope_length>
        <k_factor description="Soil erodibility factor (t/ha/EI 30 )">0.4</k_factor>
        <p_factor description="Supporting practise factor (unitless)">1.0</p_factor>
        <bed_depth description="Depth to bedrock (mm)">1900</bed_depth>
        <profile_reduction type="list" listvalues="off,on" description="Profile Reduction">off</profile_reduction>
        <profile_layer_merge description="Fraction of original size in which the lowest layer is merged into the layer above (0-1)">0.05</profile_layer_merge>
        <minimum_depth description="If the profile erodes to this depth, the simulation is stopped (mm)">100.0</minimum_depth>
      </erosion>
      <Soil>
        <RecordNumber>0</RecordNumber>
        <Latitude>0</Latitude>
        <Longitude>0</Longitude>
        <DataSource>Dr Merv E Probert, CSIRO Sustainable Ecosystems, St. Lucia, Qld, Australia
Merv.Probert@csiro.au
</DataSource>
        <Water>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <BD>
            <double>1.1</double>
            <double>1.22</double>
            <double>1.31</double>
            <double>1.23</double>
            <double>1.19</double>
          </BD>
          <AirDry>
            <double>0.14</double>
            <double>0.2</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </AirDry>
          <LL15>
            <double>0.22</double>
            <double>0.24</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </LL15>
          <DUL>
            <double>0.35</double>
            <double>0.38</double>
            <double>0.4</double>
            <double>0.37</double>
            <double>0.36</double>
          </DUL>
          <SAT>
            <double>0.5</double>
            <double>0.49</double>
            <double>0.46</double>
            <double>0.48</double>
            <double>0.5</double>
          </SAT>
          <SoilCrop name="maize">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="millet">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="weed">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="peanut">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="pigeonpea">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="mucuna">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="sorghum">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
        </Water>
        <SoilWater>
          <SummerCona type="text" description="SummerCona">6</SummerCona>
          <SummerU type="text" description="SummerU">1.5</SummerU>
          <SummerDate type="text" description="SummerDate">1-Nov</SummerDate>
          <WinterCona type="text" description="WinterCona">6</WinterCona>
          <WinterU type="text" description="WinterU">1.5</WinterU>
          <WinterDate type="text" description="WinterDate">1-Apr</WinterDate>
          <DiffusConst type="text" description="DiffusConst">88</DiffusConst>
          <DiffusSlope type="text" description="DiffusSlope">35</DiffusSlope>
          <Salb type="text" description="Salb">0.13</Salb>
          <CN2Bare type="text" description="CN2Bare">85</CN2Bare>
          <CNRed type="text" description="CNRed">20</CNRed>
          <CNCov type="text" description="CNCov">0.8</CNCov>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <SWCON>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
          </SWCON>
        </SoilWater>
        <SoilOrganicMatter>
          <RootCN>40</RootCN>
          <RootWt>500</RootWt>
          <SoilCN>12</SoilCN>
          <EnrACoeff>7.4</EnrACoeff>
          <EnrBCoeff>0.2</EnrBCoeff>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <OC>
            <double>1</double>
            <double>0.8</double>
            <double>0.5</double>
            <double>0.3</double>
            <double>0.1</double>
          </OC>
          <FBiom>
            <double>0.03</double>
            <double>0.015</double>
            <double>0.01</double>
            <double>0.01</double>
            <double>0.01</double>
          </FBiom>
          <FInert>
            <double>0.35</double>
            <double>0.7</double>
            <double>0.8</double>
            <double>0.9</double>
            <double>0.95</double>
          </FInert>
        </SoilOrganicMatter>
        <Analysis>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <Texture>
            <string />
            <string />
            <string />
            <string />
            <string />
          </Texture>
          <MunsellColour>
            <string />
            <string />
            <string />
            <string />
            <string />
          </MunsellColour>
          <PH>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
          </PH>
          <Boron>
            <double>1.8</double>
            <double>1</double>
            <double>0.72</double>
            <double>0.57</double>
            <double>0.45</double>
          </Boron>
          <CEC>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
          </CEC>
          <PHUnits>Water</PHUnits>
          <BoronUnits>HotWater</BoronUnits>
        </Analysis>
        <InitialWater>
          <FractionFull>0.8</FractionFull>
          <DepthWetSoil>NaN</DepthWetSoil>
          <PercentMethod>FilledFromTop</PercentMethod>
          <RelativeTo>ll15</RelativeTo>
        </InitialWater>
        <Sample name="Initial nitrogen">
          <Thickness>
            <double>200</double>
            <double>1800</double>
          </Thickness>
          <NO3>
            <double>7</double>
            <double>3</double>
          </NO3>
          <NH4>
            <double>3</double>
            <double>2</double>
          </NH4>
          <NO3Units>kgha</NO3Units>
          <NH4Units>kgha</NH4Units>
          <SWUnits>Volumetric</SWUnits>
          <OCUnits>Total</OCUnits>
          <PHUnits>Water</PHUnits>
        </Sample>
      </Soil>
      <tracker>
        <variable>average of cover_surface_runoff on end_of_day from lr_start to lr_end as avg_cover</variable>
        <variable>average of carbon_tot() on end_of_day from start_year to now as avg_carbon</variable>
      </tracker>
    </area>
    <area name="plot2">
      <surfaceom name="SurfaceOrganicMatter">
        <PoolName type="text" description="Organic Matter pool name">maize_stubble</PoolName>
        <type type="list" listvalues="bambatsi,barley,base_type,broccoli,camaldulensis,canola,centro,chickpea,chikenmanure_base,cm,cmA,cmB,constants,cotton,cowpea,danthonia,navybean,fieldpea,fym,gbean,globulus,goatmanure,grandis,grass,horsegram,inert,lablab,lentil,lucerne,lupin,maize,manB,manure,medic,millet,mucuna,nativepasture,navybean,oats,orobanche,peanut,pigeonpea,potato,rice,sorghum,soybean,stylo,sugar,sunflower,sweetcorn,sweetsorghum,tillage,tithonia,vetch,weed,WF_Millet,wheat" description="Organic Matter type">maize</type>
        <mass type="text" description="Initial surface residue (kg/ha)">100.</mass>
        <cnr type="text" description="C:N ratio of initial residue">80.0</cnr>
        <cpr type="text" description="C:P ratio of initial residue (optional)" />
        <standing_fraction type="text" description="Fraction of residue standing">0.0</standing_fraction>
      </surfaceom>
      <fertiliser name="Fertiliser" />
      <maize />
      <sorghum />
      <peanut />
      <mucuna />
      <weed />
      <canopy>
        <intercrop type="text" description="Enter crop names to intercrop">maize sorghum peanut mucuna weed</intercrop>
      </canopy>
      <erosion name="Erosion">
        <model description="Model Name">freebairn</model>
        <slope description="Slope of plot in percent (%)">0.5</slope>
        <slope_length description="Length of plot (m)">60.0</slope_length>
        <k_factor description="Soil erodibility factor (t/ha/EI 30 )">0.4</k_factor>
        <p_factor description="Supporting practise factor (unitless)">1.0</p_factor>
        <bed_depth description="Depth to bedrock (mm)">1900</bed_depth>
        <profile_reduction type="list" listvalues="off,on" description="Profile Reduction">off</profile_reduction>
        <profile_layer_merge description="Fraction of original size in which the lowest layer is merged into the layer above (0-1)">0.05</profile_layer_merge>
        <minimum_depth description="If the profile erodes to this depth, the simulation is stopped (mm)">100.0</minimum_depth>
      </erosion>
      <Soil>
        <RecordNumber>0</RecordNumber>
        <Latitude>0</Latitude>
        <Longitude>0</Longitude>
        <DataSource>Dr Merv E Probert, CSIRO Sustainable Ecosystems, St. Lucia, Qld, Australia
Merv.Probert@csiro.au
</DataSource>
        <Water>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <BD>
            <double>1.1</double>
            <double>1.22</double>
            <double>1.31</double>
            <double>1.23</double>
            <double>1.19</double>
          </BD>
          <AirDry>
            <double>0.14</double>
            <double>0.2</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </AirDry>
          <LL15>
            <double>0.22</double>
            <double>0.24</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </LL15>
          <DUL>
            <double>0.35</double>
            <double>0.38</double>
            <double>0.4</double>
            <double>0.37</double>
            <double>0.36</double>
          </DUL>
          <SAT>
            <double>0.5</double>
            <double>0.49</double>
            <double>0.46</double>
            <double>0.48</double>
            <double>0.5</double>
          </SAT>
          <SoilCrop name="maize">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="millet">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="weed">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="peanut">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="pigeonpea">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="mucuna">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="sorghum">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
        </Water>
        <SoilWater>
          <SummerCona type="text" description="SummerCona">6</SummerCona>
          <SummerU type="text" description="SummerU">1.5</SummerU>
          <SummerDate type="text" description="SummerDate">1-Nov</SummerDate>
          <WinterCona type="text" description="WinterCona">6</WinterCona>
          <WinterU type="text" description="WinterU">1.5</WinterU>
          <WinterDate type="text" description="WinterDate">1-Apr</WinterDate>
          <DiffusConst type="text" description="DiffusConst">88</DiffusConst>
          <DiffusSlope type="text" description="DiffusSlope">35</DiffusSlope>
          <Salb type="text" description="Salb">0.13</Salb>
          <CN2Bare type="text" description="CN2Bare">85</CN2Bare>
          <CNRed type="text" description="CNRed">20</CNRed>
          <CNCov type="text" description="CNCov">0.8</CNCov>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <SWCON>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
          </SWCON>
        </SoilWater>
        <SoilOrganicMatter>
          <RootCN>40</RootCN>
          <RootWt>500</RootWt>
          <SoilCN>12</SoilCN>
          <EnrACoeff>7.4</EnrACoeff>
          <EnrBCoeff>0.2</EnrBCoeff>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <OC>
            <double>1</double>
            <double>0.8</double>
            <double>0.5</double>
            <double>0.3</double>
            <double>0.1</double>
          </OC>
          <FBiom>
            <double>0.03</double>
            <double>0.015</double>
            <double>0.01</double>
            <double>0.01</double>
            <double>0.01</double>
          </FBiom>
          <FInert>
            <double>0.35</double>
            <double>0.7</double>
            <double>0.8</double>
            <double>0.9</double>
            <double>0.95</double>
          </FInert>
        </SoilOrganicMatter>
        <Analysis>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <Texture>
            <string />
            <string />
            <string />
            <string />
            <string />
          </Texture>
          <MunsellColour>
            <string />
            <string />
            <string />
            <string />
            <string />
          </MunsellColour>
          <PH>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
          </PH>
          <Boron>
            <double>1.8</double>
            <double>1</double>
            <double>0.72</double>
            <double>0.57</double>
            <double>0.45</double>
          </Boron>
          <CEC>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
          </CEC>
          <PHUnits>Water</PHUnits>
          <BoronUnits>HotWater</BoronUnits>
        </Analysis>
        <InitialWater>
          <FractionFull>0.8</FractionFull>
          <DepthWetSoil>NaN</DepthWetSoil>
          <PercentMethod>FilledFromTop</PercentMethod>
          <RelativeTo>ll15</RelativeTo>
        </InitialWater>
        <Sample name="Initial nitrogen">
          <Thickness>
            <double>200</double>
            <double>1800</double>
          </Thickness>
          <NO3>
            <double>7</double>
            <double>3</double>
          </NO3>
          <NH4>
            <double>3</double>
            <double>2</double>
          </NH4>
          <NO3Units>kgha</NO3Units>
          <NH4Units>kgha</NH4Units>
          <SWUnits>Volumetric</SWUnits>
          <OCUnits>Total</OCUnits>
          <PHUnits>Water</PHUnits>
        </Sample>
      </Soil>
      <tracker>
        <variable>average of cover_surface_runoff on end_of_day from lr_start to lr_end as avg_cover</variable>
        <variable>average of carbon_tot() on end_of_day from start_year to now as avg_carbon</variable>
      </tracker>
    </area>
    <area name="plot3">
      <surfaceom name="SurfaceOrganicMatter">
        <PoolName type="text" description="Organic Matter pool name">maize_stubble</PoolName>
        <type type="list" listvalues="bambatsi,barley,base_type,broccoli,camaldulensis,canola,centro,chickpea,chikenmanure_base,cm,cmA,cmB,constants,cotton,cowpea,danthonia,navybean,fieldpea,fym,gbean,globulus,goatmanure,grandis,grass,horsegram,inert,lablab,lentil,lucerne,lupin,maize,manB,manure,medic,millet,mucuna,nativepasture,navybean,oats,orobanche,peanut,pigeonpea,potato,rice,sorghum,soybean,stylo,sugar,sunflower,sweetcorn,sweetsorghum,tillage,tithonia,vetch,weed,WF_Millet,wheat" description="Organic Matter type">maize</type>
        <mass type="text" description="Initial surface residue (kg/ha)">100.</mass>
        <cnr type="text" description="C:N ratio of initial residue">80.0</cnr>
        <cpr type="text" description="C:P ratio of initial residue (optional)" />
        <standing_fraction type="text" description="Fraction of residue standing">0.0</standing_fraction>
      </surfaceom>
      <fertiliser name="Fertiliser" />
      <maize />
      <sorghum />
      <peanut />
      <mucuna />
      <weed />
      <canopy>
        <intercrop type="text" description="Enter crop names to intercrop">maize sorghum peanut mucuna weed</intercrop>
      </canopy>
      <erosion name="Erosion">
        <model description="Model Name">freebairn</model>
        <slope description="Slope of plot in percent (%)">0.5</slope>
        <slope_length description="Length of plot (m)">60.0</slope_length>
        <k_factor description="Soil erodibility factor (t/ha/EI 30 )">0.4</k_factor>
        <p_factor description="Supporting practise factor (unitless)">1.0</p_factor>
        <bed_depth description="Depth to bedrock (mm)">1900</bed_depth>
        <profile_reduction type="list" listvalues="off,on" description="Profile Reduction">off</profile_reduction>
        <profile_layer_merge description="Fraction of original size in which the lowest layer is merged into the layer above (0-1)">0.05</profile_layer_merge>
        <minimum_depth description="If the profile erodes to this depth, the simulation is stopped (mm)">100.0</minimum_depth>
      </erosion>
      <Soil>
        <RecordNumber>0</RecordNumber>
        <Latitude>0</Latitude>
        <Longitude>0</Longitude>
        <DataSource>Dr Merv E Probert, CSIRO Sustainable Ecosystems, St. Lucia, Qld, Australia
Merv.Probert@csiro.au
</DataSource>
        <Water>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <BD>
            <double>1.1</double>
            <double>1.22</double>
            <double>1.31</double>
            <double>1.23</double>
            <double>1.19</double>
          </BD>
          <AirDry>
            <double>0.14</double>
            <double>0.2</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </AirDry>
          <LL15>
            <double>0.22</double>
            <double>0.24</double>
            <double>0.28</double>
            <double>0.3</double>
            <double>0.3</double>
          </LL15>
          <DUL>
            <double>0.35</double>
            <double>0.38</double>
            <double>0.4</double>
            <double>0.37</double>
            <double>0.36</double>
          </DUL>
          <SAT>
            <double>0.5</double>
            <double>0.49</double>
            <double>0.46</double>
            <double>0.48</double>
            <double>0.5</double>
          </SAT>
          <SoilCrop name="maize">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="millet">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="weed">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="peanut">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="pigeonpea">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="mucuna">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="sorghum">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
              <double>300</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
              <double>0.3</double>
              <double>0.3</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
              <double>0.08</double>
              <double>0.07</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>1</double>
              <double>0</double>
            </XF>
          </SoilCrop>
        </Water>
        <SoilWater>
          <SummerCona type="text" description="SummerCona">6</SummerCona>
          <SummerU type="text" description="SummerU">1.5</SummerU>
          <SummerDate type="text" description="SummerDate">1-Nov</SummerDate>
          <WinterCona type="text" description="WinterCona">6</WinterCona>
          <WinterU type="text" description="WinterU">1.5</WinterU>
          <WinterDate type="text" description="WinterDate">1-Apr</WinterDate>
          <DiffusConst type="text" description="DiffusConst">88</DiffusConst>
          <DiffusSlope type="text" description="DiffusSlope">35</DiffusSlope>
          <Salb type="text" description="Salb">0.13</Salb>
          <CN2Bare type="text" description="CN2Bare">85</CN2Bare>
          <CNRed type="text" description="CNRed">20</CNRed>
          <CNCov type="text" description="CNCov">0.8</CNCov>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <SWCON>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
          </SWCON>
        </SoilWater>
        <SoilOrganicMatter>
          <RootCN>40</RootCN>
          <RootWt>500</RootWt>
          <SoilCN>12</SoilCN>
          <EnrACoeff>7.4</EnrACoeff>
          <EnrBCoeff>0.2</EnrBCoeff>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <OC>
            <double>1</double>
            <double>0.8</double>
            <double>0.5</double>
            <double>0.3</double>
            <double>0.1</double>
          </OC>
          <FBiom>
            <double>0.03</double>
            <double>0.015</double>
            <double>0.01</double>
            <double>0.01</double>
            <double>0.01</double>
          </FBiom>
          <FInert>
            <double>0.35</double>
            <double>0.7</double>
            <double>0.8</double>
            <double>0.9</double>
            <double>0.95</double>
          </FInert>
        </SoilOrganicMatter>
        <Analysis>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <Texture>
            <string />
            <string />
            <string />
            <string />
            <string />
          </Texture>
          <MunsellColour>
            <string />
            <string />
            <string />
            <string />
            <string />
          </MunsellColour>
          <PH>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
            <double>6</double>
          </PH>
          <Boron>
            <double>1.8</double>
            <double>1</double>
            <double>0.72</double>
            <double>0.57</double>
            <double>0.45</double>
          </Boron>
          <CEC>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
          </CEC>
          <PHUnits>Water</PHUnits>
          <BoronUnits>HotWater</BoronUnits>
        </Analysis>
        <InitialWater>
          <FractionFull>0.8</FractionFull>
          <DepthWetSoil>NaN</DepthWetSoil>
          <PercentMethod>FilledFromTop</PercentMethod>
          <RelativeTo>ll15</RelativeTo>
        </InitialWater>
        <Sample name="Initial nitrogen">
          <Thickness>
            <double>200</double>
            <double>1800</double>
          </Thickness>
          <NO3>
            <double>7</double>
            <double>3</double>
          </NO3>
          <NH4>
            <double>3</double>
            <double>2</double>
          </NH4>
          <NO3Units>kgha</NO3Units>
          <NH4Units>kgha</NH4Units>
          <SWUnits>Volumetric</SWUnits>
          <OCUnits>Total</OCUnits>
          <PHUnits>Water</PHUnits>
        </Sample>
      </Soil>
      <tracker>
        <variable>average of cover_surface_runoff on end_of_day from lr_start to lr_end as avg_cover</variable>
        <variable>average of carbon_tot() on end_of_day from start_year to now as avg_carbon</variable>
      </tracker>
    </area>
    <area name="verges">
      <surfaceom name="SurfaceOrganicMatter">
        <PoolName type="text" description="Organic Matter pool name">maize_stubble</PoolName>
        <type type="list" listvalues="bambatsi,barley,base_type,broccoli,camaldulensis,canola,centro,chickpea,chikenmanure_base,cm,cmA,cmB,constants,cotton,cowpea,danthonia,navybean,fieldpea,fym,gbean,globulus,goatmanure,grandis,grass,horsegram,inert,lablab,lentil,lucerne,lupin,maize,manB,manure,medic,millet,mucuna,nativepasture,navybean,oats,orobanche,peanut,pigeonpea,potato,rice,sorghum,soybean,stylo,sugar,sunflower,sweetcorn,sweetsorghum,tillage,tithonia,vetch,weed,WF_Millet,wheat" description="Organic Matter type">maize</type>
        <mass type="text" description="Initial surface residue (kg/ha)">400.</mass>
        <cnr type="text" description="C:N ratio of initial residue">80.0</cnr>
        <cpr type="text" description="C:P ratio of initial residue (optional)" />
        <standing_fraction type="text" description="Fraction of residue standing">0.0</standing_fraction>
      </surfaceom>
      <fertiliser name="Fertiliser" />
      <erosion name="Erosion">
        <model description="Model Name">freebairn</model>
        <slope description="Slope of plot in percent (%)">0.5</slope>
        <slope_length description="Length of plot (m)">60.0</slope_length>
        <k_factor description="Soil erodibility factor (t/ha/EI 30 )">0.4</k_factor>
        <p_factor description="Supporting practise factor (unitless)">1.0</p_factor>
        <bed_depth description="Depth to bedrock (mm)">1900</bed_depth>
        <profile_reduction type="list" listvalues="off,on" description="Profile Reduction">off</profile_reduction>
        <profile_layer_merge description="Fraction of original size in which the lowest layer is merged into the layer above (0-1)">0.05</profile_layer_merge>
        <minimum_depth description="If the profile erodes to this depth, the simulation is stopped (mm)">100.0</minimum_depth>
      </erosion>
      <Soil>
        <RecordNumber>0</RecordNumber>
        <Latitude>0</Latitude>
        <Longitude>0</Longitude>
        <DataSource>Dr Merv E Probert, CSIRO Sustainable Ecosystems, St. Lucia, Qld, Australia
Merv.Probert@csiro.au
</DataSource>
        <Water>
          <SoilCrop name="maize">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="millet">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="weed">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="peanut">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="pigeonpea">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <SoilCrop name="sorghum">
            <Thickness>
              <double>150</double>
              <double>150</double>
              <double>300</double>
            </Thickness>
            <LL>
              <double>0.22</double>
              <double>0.24</double>
              <double>0.28</double>
            </LL>
            <KL>
              <double>0.12</double>
              <double>0.12</double>
              <double>0.1</double>
            </KL>
            <XF>
              <double>1</double>
              <double>1</double>
              <double>1</double>
            </XF>
          </SoilCrop>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
          </Thickness>
          <BD>
            <double>1.1</double>
            <double>1.22</double>
            <double>1.31</double>
          </BD>
          <AirDry>
            <double>0.14</double>
            <double>0.2</double>
            <double>0.28</double>
          </AirDry>
          <LL15>
            <double>0.22</double>
            <double>0.24</double>
            <double>0.28</double>
          </LL15>
          <DUL>
            <double>0.35</double>
            <double>0.38</double>
            <double>0.4</double>
          </DUL>
          <SAT>
            <double>0.5</double>
            <double>0.49</double>
            <double>0.46</double>
          </SAT>
        </Water>
        <SoilWater>
          <SummerCona type="text" description="SummerCona">6</SummerCona>
          <SummerU type="text" description="SummerU">1.5</SummerU>
          <SummerDate type="text" description="SummerDate">1-Nov</SummerDate>
          <WinterCona type="text" description="WinterCona">6</WinterCona>
          <WinterU type="text" description="WinterU">1.5</WinterU>
          <WinterDate type="text" description="WinterDate">1-Apr</WinterDate>
          <DiffusConst type="text" description="DiffusConst">88</DiffusConst>
          <DiffusSlope type="text" description="DiffusSlope">35</DiffusSlope>
          <Salb type="text" description="Salb">0.13</Salb>
          <CN2Bare type="text" description="CN2Bare">85</CN2Bare>
          <CNRed type="text" description="CNRed">20</CNRed>
          <CNCov type="text" description="CNCov">0.8</CNCov>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
          </Thickness>
          <SWCON>
            <double>0.5</double>
            <double>0.5</double>
            <double>0.5</double>
          </SWCON>
        </SoilWater>
        <SoilOrganicMatter>
          <RootCN>40</RootCN>
          <RootWt>500</RootWt>
          <SoilCN>12</SoilCN>
          <EnrACoeff>7.4</EnrACoeff>
          <EnrBCoeff>0.2</EnrBCoeff>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
            <double>300</double>
            <double>300</double>
          </Thickness>
          <OC>
            <double>0.1</double>
            <double>0.1</double>
            <double>0.1</double>
            <double>0.1</double>
            <double>0.1</double>
          </OC>
          <FBiom>
            <double>0.03</double>
            <double>0.015</double>
            <double>0.01</double>
            <double>0.01</double>
            <double>0.01</double>
          </FBiom>
          <FInert>
            <double>0.35</double>
            <double>0.7</double>
            <double>0.8</double>
            <double>0.9</double>
            <double>0.95</double>
          </FInert>
        </SoilOrganicMatter>
        <Analysis>
          <Thickness>
            <double>150</double>
            <double>150</double>
            <double>300</double>
          </Thickness>
          <PH>
            <double>6</double>
            <double>6</double>
            <double>6</double>
          </PH>
          <Boron>
            <double>1.8</double>
            <double>1</double>
            <double>0.72</double>
          </Boron>
          <CEC>
            <double>5.1</double>
            <double>5.1</double>
            <double>5.1</double>
          </CEC>
        </Analysis>
        <InitialWater>
          <RelativeTo>ll15</RelativeTo>
          <FractionFull>0.8</FractionFull>
          <PercentMethod>FilledFromTop</PercentMethod>
        </InitialWater>
        <Sample name="Initial nitrogen">
          <Date type="date" description="Sample date:" />
          <Thickness>
            <double>200</double>
            <double>1800</double>
          </Thickness>
          <NO3>
            <double>7</double>
            <double>3</double>
          </NO3>
          <NO3Units>kgha</NO3Units>
          <NH4>
            <double>3</double>
            <double>2</double>
          </NH4>
          <NH4Units>kgha</NH4Units>
        </Sample>
      </Soil>
      <grasp>
        <category type="category" />
        <root_depth_init type="text" description="Initial depth of roots (mm)">750</root_depth_init>
        <dm_dead_leaf_init type="text" description="Initial Dead Leaf weight (kg/ha)">150</dm_dead_leaf_init>
        <dm_dead_stem_init type="text" description="Initial Dead Stem weight (kg/ha)">80</dm_dead_stem_init>
        <dm_dead_root_init type="text" description="Initial Dead Root weight (kg/ha)">80</dm_dead_root_init>
        <dm_green_leaf_init type="text" description="Initial Green Leaf weight (p135, kg/ha)">850</dm_green_leaf_init>
        <dm_green_stem_init type="text" description="Initial Green Stem weight (p136, kg/ha)">150</dm_green_stem_init>
        <dm_green_root_init type="text" description="Initial Green Root weight (kg/ha)">250</dm_green_root_init>
        <basal_area_init type="text" description="Initial Basal area of tussocks (p005, %)">0.8</basal_area_init>
        <acc_trans_for_n_init type="text" description="Initial accumulated transpiration, used for N uptake (mm)">50</acc_trans_for_n_init>
        <acc_growth_for_n_init type="text" description="Initial accumulated growth, used for N uptake (kg/ha)">50</acc_growth_for_n_init>
        <category type="category" />
        <max_n_avail type="text" description="Limit to total N (p099, kg/year)">6</max_n_avail>
        <max_n_avail_dist type="text" description="Distribution of N in profile">0.8 0.1 0.05  0.05  0.0 0.0</max_n_avail_dist>
        <ll type="text" description="Lower limit (ll) of water extraction (mm/mm)">0.22 0.24 0.28 0.30 0.30</ll>
        <kl type="text" description="Rate of water extraction (kl)">0.5     0.5    0.5   0.5  0.0  0.0</kl>
        <kl2rlv type="text" description="kl2rlv">1.0</kl2rlv>
        <category type="category" />
        <crop_type type="text" description="crop_type">grass</crop_type>
        <uptake_source type="text" description="uptake_source">calc</uptake_source>
        <height_max type="text" description="Maximum canopy height (mm)">1200</height_max>
        <hgt_vpd_screen type="text" description="Height at which surface effects on vpd are 0 (p095*10, mm)">200</hgt_vpd_screen>
        <height_1000kg type="text" description="Sward Height per tonne (p096*10, mm)">100</height_1000kg>
        <et_use_efficiency type="text" description="Evapotranspiration use efficiency used in BA calc (p288, kg/ha/mm) (p288)">0</et_use_efficiency>
        <frac_leaf2total type="text" description="Fraction of total dm produced that goes into leaf pool (p123,0-1)">0.5</frac_leaf2total>
        <yld_cover_slope type="text" description="Shape of exponential curve relating yield and cover">0.693147</yld_cover_slope>
        <yld_fpc50 type="text" description="yld_fpc50 (p046)">1200</yld_fpc50>
        <yld_cov50 type="text" description="Yield transpiring at 50% of pan evap (p045)">1500</yld_cov50>
        <yld_tcov50 type="text" description="Tsdm yield at which cover for runoff is 50% (p271)">1500</yld_tcov50>
        <swi_fullgreen type="text" description="Min soil water for 100% green (p009)">0.1</swi_fullgreen>
        <swi_nogrow type="text" description="SWI when growth stops (swi_nogrow)">0.4</swi_nogrow>
        <pot_regrow type="text" description="Max rate regrowth from tussocks (p006, kg/ha/unit grass ba)">3.0</pot_regrow>
        <te_std type="text" description="Transpiration efficiency at vpd=20mb (p007)">10.0</te_std>
        <rad_factor type="text" description="rad_factor">8.97</rad_factor>
        <residual_plant_N type="text" description="Always this much n in plant (p097, kg/ha)">5</residual_plant_N>
        <litter_n type="text" description="N conc of detached stems and roots ((p110-p111)/2)">0.3</litter_n>
        <n_uptk_per100 type="text" description="Nitrogen uptake per 100mm water (p098, kg/ha)">5</n_uptk_per100>
        <frost_start type="text" description="Minimum screen temp at which green cover=100% (p125, oC)">2</frost_start>
        <frost_kill type="text" description="Minimum screen temp at which frost kills all green (p011, oC)">0</frost_kill>
        <death_slope type="text" description="Rate of green death per soil water (p051)">0.013</death_slope>
        <death_intercept type="text" description="Background death rate (p010)">0.002</death_intercept>
        <leaf_death_ratio type="text" description="Proportion of leaf death to total death (p133)">1</leaf_death_ratio>
        <stem_death_ratio type="text" description="Proportion of stem death to total death (p134)">1</stem_death_ratio>
        <n_conc_dm_crit type="text" description="Level of plant N at which no N stress occurs (p102)">2.5</n_conc_dm_crit>
        <n_conc_dm_min type="text" description="Level of soil N at which no N stress occurs (p101)">0.4</n_conc_dm_min>
        <n_conc_dm_max type="text" description="Level of soil N at which soil N to high for growth (p100)">0.5</n_conc_dm_max>
        <stem_thresh type="text" description="stem_thresh (p124)">0</stem_thresh>
        <detach_dryseason type="text" description="detach_dryseason: root, leaf, stem">0.0   0.008     0.008</detach_dryseason>
        <detach_wetseason type="text" description="detach_wetseason: root, leaf, stem">0.0   0.008     0.008</detach_wetseason>
        <category type="category" />
        <day_start_summer type="text" description="day_start_summer">335</day_start_summer>
        <day_end_summer type="text" description="day_end_summer">59</day_end_summer>
        <acc_et_reset type="text" description="acc_et_reset">273</acc_et_reset>
        <acc_growth_reset type="text" description="acc_growth_reset">273</acc_growth_reset>
        <trans_for_n_reset type="text" description="trans_for_n_reset">273</trans_for_n_reset>
        <growth_for_n_reset type="text" description="growth_for_n_reset">273</growth_for_n_reset>
        <day_start_wet type="text" description="day_start_wet">274</day_start_wet>
        <day_start_dry type="text" description="day_start_dry">91</day_start_dry>
        <enr_a_coeff type="text" description="enr_a_coeff">7.4</enr_a_coeff>
        <enr_b_coeff type="text" description="enr_b_coeff">0.2</enr_b_coeff>
      </grasp>
      <manager name="Establish pasture">
        <script>
          <event>init</event>
        </script>
        <script>
          <text>grasp establish init_section = establishment</text>
          <event>start_simulation</event>
        </script>
      </manager>
      <tracker>
        <variable>average of cover_surface_runoff on end_of_day from lr_start to lr_end as avg_cover</variable>
        <variable>average of carbon_tot() on end_of_day from start_year to now as avg_carbon</variable>
      </tracker>
    </area>
    <outputfile name="LivsimOutput">
      <filename output="yes">Sample LivsimOutput.out</filename>
      <title>Sample LivsimOutput</title>
      <variables name="Variables">
        <variable>dd/mm/yyyy as Date</variable>
        <variable>herdsize_shoats</variable>
        <variable>herdsize_cows</variable>
        <variable>inputdmOfShoats</variable>
        <variable>faecdmOfShoats</variable>
        <variable>milkOfShoats</variable>
        <variable>inputdmOfCows</variable>
        <variable>faecdmOfCows</variable>
        <variable>milkOfCows</variable>
        <variable>grass_eaten</variable>
        <variable>maize_eaten</variable>
        <variable>bran_eaten</variable>
        <variable>sorghum_eaten</variable>
        <variable>mucuna_eaten</variable>
        <variable>resd_eaten</variable>
        <variable>store</variable>
      </variables>
      <Graph name="Number">
        <Legend>
          <CheckedTitles> herdsize_shoats</CheckedTitles>
          <CheckedTitles> herdsize_cows</CheckedTitles>
        </Legend>
        <Format>AAEAAAD/////AQAAAAAAAAAMAgAAAFhUZWVDaGFydC5DbGllbnQsIFZlcnNpb249NC4xLjIwMTEuNzI4MywgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj05YzgxMjYyNzZjNzdiZGI3DAMAAABXU3lzdGVtLldpbmRvd3MuRm9ybXMsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5DAQAAABRU3lzdGVtLkRyYXdpbmcsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iMDNmNWY3ZjExZDUwYTNhBQEAAAAVU3RlZW1hLlRlZUNoYXJ0LkNoYXJ0+AAAAA4uWm9vbS5BbmltYXRlZBMuWm9vbS5BbmltYXRlZFN0ZXBzFC5QYW5uaW5nLk1vdXNlQnV0dG9uEC5DdXN0b21DaGFydFJlY3QXLlBhbmVsLkltYWdlQmV2ZWwuV2lkdGgVLlBhbmVsLkJldmVsLkNvbG9yT25lGy5QYW5lbC5CZXZlbC5TdHJpbmdDb2xvck9uZRUuUGFuZWwuQmV2ZWwuQ29sb3JUd28bLlBhbmVsLkJldmVsLlN0cmluZ0NvbG9yVHdvEi5QYW5lbC5CZXZlbC5PdXRlchIuUGFuZWwuQnJ1c2guQ29sb3ISLkxlZ2VuZC5DaGVja0JveGVzEi5MZWdlbmQuTWF4TnVtUm93cxwuTGVnZW5kLlRpdGxlLkJldmVsLkNvbG9yT25lIi5MZWdlbmQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUcLkxlZ2VuZC5UaXRsZS5CZXZlbC5Db2xvclR3byIuTGVnZW5kLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvFi5MZWdlbmQuQmV2ZWwuQ29sb3JPbmUcLkxlZ2VuZC5CZXZlbC5TdHJpbmdDb2xvck9uZRYuTGVnZW5kLkJldmVsLkNvbG9yVHdvHC5MZWdlbmQuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkxlZ2VuZC5TaGFkb3cuVmlzaWJsZRMuTGVnZW5kLlRyYW5zcGFyZW50DS5IZWFkZXIuTGluZXMRLkhlYWRlci5Gb250Lk5hbWURLkhlYWRlci5Gb250LlNpemUWLkhlYWRlci5Gb250LlNpemVGbG9hdBYuSGVhZGVyLkJldmVsLkNvbG9yT25lHC5IZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUWLkhlYWRlci5CZXZlbC5Db2xvclR3bxwuSGVhZGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5TdWJIZWFkZXIuQmV2ZWwuQ29sb3JPbmUfLlN1YkhlYWRlci5CZXZlbC5TdHJpbmdDb2xvck9uZRkuU3ViSGVhZGVyLkJldmVsLkNvbG9yVHdvHy5TdWJIZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkZvb3Rlci5CZXZlbC5Db2xvck9uZRwuRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yT25lFi5Gb290ZXIuQmV2ZWwuQ29sb3JUd28cLkZvb3Rlci5CZXZlbC5TdHJpbmdDb2xvclR3bxkuU3ViRm9vdGVyLkJldmVsLkNvbG9yT25lHy5TdWJGb290ZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUZLlN1YkZvb3Rlci5CZXZlbC5Db2xvclR3bx8uU3ViRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5Bc3BlY3QuQ29sb3JQYWxldHRlSW5kZXgOLkFzcGVjdC5WaWV3M0QIU2VyaWVzLjAVLlNlcmllcy4wLkJydXNoLkNvbG9yFy5TZXJpZXMuMC5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMC5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMC5Db2xvckVhY2gRLlNlcmllcy4wLlZpc2libGUPLlNlcmllcy4wLkNvbG9yDy5TZXJpZXMuMC5UaXRsZRYuU2VyaWVzLjAuU2hvd0luTGVnZW5kCFNlcmllcy4xFS5TZXJpZXMuMS5CcnVzaC5Db2xvchcuU2VyaWVzLjEuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjEuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjEuQ29sb3JFYWNoDy5TZXJpZXMuMS5Db2xvcg8uU2VyaWVzLjEuVGl0bGUIU2VyaWVzLjIVLlNlcmllcy4yLkJydXNoLkNvbG9yFy5TZXJpZXMuMi5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMi5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMi5Db2xvckVhY2gPLlNlcmllcy4yLkNvbG9yDy5TZXJpZXMuMi5UaXRsZRYuU2VyaWVzLjIuU2hvd0luTGVnZW5kCFNlcmllcy4zFS5TZXJpZXMuMy5CcnVzaC5Db2xvchcuU2VyaWVzLjMuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjMuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjMuQ29sb3JFYWNoES5TZXJpZXMuMy5WaXNpYmxlDy5TZXJpZXMuMy5Db2xvcg8uU2VyaWVzLjMuVGl0bGUWLlNlcmllcy4zLlNob3dJbkxlZ2VuZAhTZXJpZXMuNBUuU2VyaWVzLjQuQnJ1c2guQ29sb3IXLlNlcmllcy40LlBvaW50ZXIuU3R5bGUXLlNlcmllcy40LkxpbmVQZW4uV2lkdGgTLlNlcmllcy40LkNvbG9yRWFjaA8uU2VyaWVzLjQuQ29sb3IPLlNlcmllcy40LlRpdGxlFi5TZXJpZXMuNC5TaG93SW5MZWdlbmQIU2VyaWVzLjUVLlNlcmllcy41LkJydXNoLkNvbG9yFy5TZXJpZXMuNS5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuNS5MaW5lUGVuLldpZHRoEy5TZXJpZXMuNS5Db2xvckVhY2gPLlNlcmllcy41LkNvbG9yDy5TZXJpZXMuNS5UaXRsZQhTZXJpZXMuNhUuU2VyaWVzLjYuQnJ1c2guQ29sb3IXLlNlcmllcy42LlBvaW50ZXIuU3R5bGUXLlNlcmllcy42LkxpbmVQZW4uV2lkdGgTLlNlcmllcy42LkNvbG9yRWFjaBIuU2VyaWVzLjYuVmVydEF4aXMPLlNlcmllcy42LkNvbG9yDy5TZXJpZXMuNi5UaXRsZQhTZXJpZXMuNxUuU2VyaWVzLjcuQnJ1c2guQ29sb3IXLlNlcmllcy43LlBvaW50ZXIuU3R5bGUXLlNlcmllcy43LkxpbmVQZW4uV2lkdGgTLlNlcmllcy43LkNvbG9yRWFjaBEuU2VyaWVzLjcuVmlzaWJsZRIuU2VyaWVzLjcuVmVydEF4aXMPLlNlcmllcy43LkNvbG9yDy5TZXJpZXMuNy5UaXRsZRYuU2VyaWVzLjcuU2hvd0luTGVnZW5kCFNlcmllcy44FS5TZXJpZXMuOC5CcnVzaC5Db2xvchcuU2VyaWVzLjguUG9pbnRlci5TdHlsZRcuU2VyaWVzLjguTGluZVBlbi5XaWR0aBMuU2VyaWVzLjguQ29sb3JFYWNoES5TZXJpZXMuOC5WaXNpYmxlEi5TZXJpZXMuOC5WZXJ0QXhpcw8uU2VyaWVzLjguQ29sb3IPLlNlcmllcy44LlRpdGxlFi5TZXJpZXMuOC5TaG93SW5MZWdlbmQaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JPbmUgLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JPbmUaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JUd28gLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JUd28bLldhbGxzLlJpZ2h0LkJldmVsLkNvbG9yT25lIS5XYWxscy5SaWdodC5CZXZlbC5TdHJpbmdDb2xvck9uZRsuV2FsbHMuUmlnaHQuQmV2ZWwuQ29sb3JUd28hLldhbGxzLlJpZ2h0LkJldmVsLlN0cmluZ0NvbG9yVHdvGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yT25lIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yT25lGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yVHdvIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yVHdvHC5XYWxscy5Cb3R0b20uQmV2ZWwuQ29sb3JPbmUiLldhbGxzLkJvdHRvbS5CZXZlbC5TdHJpbmdDb2xvck9uZRwuV2FsbHMuQm90dG9tLkJldmVsLkNvbG9yVHdvIi5XYWxscy5Cb3R0b20uQmV2ZWwuU3RyaW5nQ29sb3JUd28OLldhbGxzLlZpc2libGUcLkF4ZXMuTGVmdC5MYWJlbHMuU2VwYXJhdGlvbh0uQXhlcy5MZWZ0LkxhYmVscy5WYWx1ZUZvcm1hdBsuQXhlcy5MZWZ0LkxhYmVscy5Gb250Lk5hbWUbLkF4ZXMuTGVmdC5MYWJlbHMuRm9udC5TaXplIC5BeGVzLkxlZnQuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0IC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yT25lJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yT25lIC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yVHdvJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGC5BeGVzLkxlZnQuQXhpc1Blbi5XaWR0aBkuQXhlcy5MZWZ0LkF4aXNQZW4uRW5kQ2FwFy5BeGVzLkxlZnQuR3JpZC5WaXNpYmxlGC5BeGVzLkxlZnQuTWF4aW11bU9mZnNldB0uQXhlcy5MZWZ0Lk1pbm9yVGlja3MuVmlzaWJsZRYuQXhlcy5MZWZ0LlRpY2tzLkNvbG9yGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5OYW1lGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplHy5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplRmxvYXQoLkF4ZXMuTGVmdC5UaXRsZS5Gb250LlNoYWRvdy5CcnVzaC5Db2xvciEuQXhlcy5MZWZ0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IfLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5Db2xvck9uZSUuQXhlcy5MZWZ0LlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHy5BeGVzLkxlZnQuVGl0bGUuQmV2ZWwuQ29sb3JUd28lLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bxsuQXhlcy5Ub3AuTGFiZWxzLlNlcGFyYXRpb24cLkF4ZXMuVG9wLkxhYmVscy5WYWx1ZUZvcm1hdBouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuTmFtZRouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZR8uQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Hy5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUlLkF4ZXMuVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZR8uQXhlcy5Ub3AuTGFiZWxzLkJldmVsLkNvbG9yVHdvJS5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28XLkF4ZXMuVG9wLkF4aXNQZW4uV2lkdGgYLkF4ZXMuVG9wLkF4aXNQZW4uRW5kQ2FwFi5BeGVzLlRvcC5HcmlkLlZpc2libGUcLkF4ZXMuVG9wLk1pbm9yVGlja3MuVmlzaWJsZRUuQXhlcy5Ub3AuVGlja3MuQ29sb3IZLkF4ZXMuVG9wLlRpdGxlLkZvbnQuTmFtZRkuQXhlcy5Ub3AuVGl0bGUuRm9udC5TaXplHi5BeGVzLlRvcC5UaXRsZS5Gb250LlNpemVGbG9hdCAuQXhlcy5Ub3AuVGl0bGUuRm9udC5CcnVzaC5Db2xvch4uQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuQ29sb3JPbmUkLkF4ZXMuVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHi5BeGVzLlRvcC5UaXRsZS5CZXZlbC5Db2xvclR3byQuQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28RLkF4ZXMuVG9wLlZpc2libGUdLkF4ZXMuUmlnaHQuTGFiZWxzLlNlcGFyYXRpb24eLkF4ZXMuUmlnaHQuTGFiZWxzLlZhbHVlRm9ybWF0HC5BeGVzLlJpZ2h0LkxhYmVscy5Gb250Lk5hbWUcLkF4ZXMuUmlnaHQuTGFiZWxzLkZvbnQuU2l6ZSEuQXhlcy5SaWdodC5MYWJlbHMuRm9udC5TaXplRmxvYXQhLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLkNvbG9yT25lJy5BeGVzLlJpZ2h0LkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSEuQXhlcy5SaWdodC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28nLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5BeGVzLlJpZ2h0LkF4aXNQZW4uV2lkdGgaLkF4ZXMuUmlnaHQuQXhpc1Blbi5FbmRDYXAYLkF4ZXMuUmlnaHQuR3JpZC5WaXNpYmxlHi5BeGVzLlJpZ2h0Lk1pbm9yVGlja3MuVmlzaWJsZRcuQXhlcy5SaWdodC5UaWNrcy5Db2xvchsuQXhlcy5SaWdodC5UaXRsZS5Gb250Lk5hbWUbLkF4ZXMuUmlnaHQuVGl0bGUuRm9udC5TaXplIC5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JPbmUmLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JUd28mLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28eLkF4ZXMuQm90dG9tLkxhYmVscy5TZXBhcmF0aW9uIi5BeGVzLkJvdHRvbS5MYWJlbHMuRGF0ZVRpbWVGb3JtYXQfLkF4ZXMuQm90dG9tLkxhYmVscy5WYWx1ZUZvcm1hdB0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuTmFtZR0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUoLkF4ZXMuQm90dG9tLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkJldmVsLkNvbG9yVHdvKC5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28aLkF4ZXMuQm90dG9tLkF4aXNQZW4uV2lkdGgbLkF4ZXMuQm90dG9tLkF4aXNQZW4uRW5kQ2FwGS5BeGVzLkJvdHRvbS5HcmlkLlZpc2libGUaLkF4ZXMuQm90dG9tLk1heGltdW1PZmZzZXQaLkF4ZXMuQm90dG9tLk1pbmltdW1PZmZzZXQfLkF4ZXMuQm90dG9tLk1pbm9yVGlja3MuVmlzaWJsZRguQXhlcy5Cb3R0b20uVGlja3MuQ29sb3IcLkF4ZXMuQm90dG9tLlRpdGxlLkZvbnQuTmFtZRwuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5TaXplIS5BeGVzLkJvdHRvbS5UaXRsZS5Gb250LlNpemVGbG9hdCMuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5CcnVzaC5Db2xvciEuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuQ29sb3JPbmUnLkF4ZXMuQm90dG9tLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIS5BeGVzLkJvdHRvbS5UaXRsZS5CZXZlbC5Db2xvclR3bycuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28kLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLkNvbG9yT25lKi5BeGVzLkRlcHRoVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSQuQXhlcy5EZXB0aFRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28qLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yT25lKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yVHdvKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvIS5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5Db2xvck9uZScuQXhlcy5EZXB0aC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JPbmUhLkF4ZXMuRGVwdGguTGFiZWxzLkJldmVsLkNvbG9yVHdvJy5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvclR3byAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvck9uZSYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvck9uZSAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvclR3byYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bwAABAAABAEEAQQEAAAEAQQBBAEEAQAABgEAAAQBBAEEAQQBBAEEAQQBBAEAAAEEBAAAAAQBAAEEBAAABAEBBAQAAAQBAAEEBAAAAAQBAAEEBAAABAEAAQQEAAAEAQEEBAAABAQBAQQEAAAABAQBAAEEBAAAAAQEAQAEAQQBBAEEAQQBBAEEAQQBAAABAQAABAEEAQAEAAAABAEAAAQEBAEEAQABAQAABAEEAQAEAAAEAQAABAQBBAEAAAEBAAAEAQQBAAQAAAQBAAAEBAEEAQABAQEAAAQBBAEABAAAAAAEAQAABAQBBAEEAQQBBAEEAQQBBAEEAQQBAQghU3lzdGVtLldpbmRvd3MuRm9ybXMuTW91c2VCdXR0b25zAwAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAjU3RlZW1hLlRlZUNoYXJ0LkRyYXdpbmcuQmV2ZWxTdHlsZXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEBCAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEjU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5WZXJ0aWNhbEF4aXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAIIFN5c3RlbS5EcmF3aW5nLkRyYXdpbmcyRC5MaW5lQ2FwBAAAAAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAACAAAAAQQAAAAF+////yFTeXN0ZW0uV2luZG93cy5Gb3Jtcy5Nb3VzZUJ1dHRvbnMBAAAAB3ZhbHVlX18ACAMAAAAAAEAAAAEAAAAF+v///xRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAEbmFtZQV2YWx1ZQprbm93bkNvbG9yBXN0YXRlAQAAAAkHBwQAAAAK/////wAAAAAAAAIABgcAAAAIRkZGRkZGRkYB+P////r///8KgICA/wAAAAAAAAIABgkAAAAIRkY4MDgwODAF9v///yNTdGVlbWEuVGVlQ2hhcnQuRHJhd2luZy5CZXZlbFN0eWxlcwEAAAAHdmFsdWVfXwAIAgAAAAAAAAAB9f////r///8K/////wAAAAAAAAIAAQgAAAAB9P////r///8K/////wAAAAAAAAIABg0AAAAIRkZGRkZGRkYB8v////r///8KgICA/wAAAAAAAAIABg8AAAAIRkY4MDgwODAB8P////r///8K/////wAAAAAAAAIABhEAAAAIRkZGRkZGRkYB7v////r///8KgICA/wAAAAAAAAIABhMAAAAIRkY4MDgwODAAAQkUAAAABhUAAAAGVGFob21hDAAAAAAAQEEB6v////r///8K/////wAAAAAAAAIABhcAAAAIRkZGRkZGRkYB6P////r///8KgICA/wAAAAAAAAIABhkAAAAIRkY4MDgwODAB5v////r///8K/////wAAAAAAAAIABhsAAAAIRkZGRkZGRkYB5P////r///8KgICA/wAAAAAAAAIABh0AAAAIRkY4MDgwODAB4v////r///8K/////wAAAAAAAAIABh8AAAAIRkZGRkZGRkYB4P////r///8KgICA/wAAAAAAAAIABiEAAAAIRkY4MDgwODAB3v////r///8K/////wAAAAAAAAIABiMAAAAIRkZGRkZGRkYB3P////r///8KgICA/wAAAAAAAAIABiUAAAAIRkY4MDgwODADAAAAAAYmAAAAG1N0ZWVtYS5UZWVDaGFydC5TdHlsZXMuTGluZQHZ////+v///woAAAAAAAAAACUAAQAF2P///yRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMBAAAAB3ZhbHVlX18ACAIAAAAJAAAAAgAAAAAAAdf////6////CgAAAAAAAAAAJQABAAYqAAAAGyBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUAAJJgAAAAHU////+v///woAAAAAAAAAAI0AAQAB0////9j///8JAAAAAgAAAAAB0v////r///8KAAAAAAAAAACNAAEABi8AAAAkIG1pbGxldF9iaW9tX2tnaGEsIE1pbGxldCBQIHBhZGRvY2sxCSYAAAABz/////r///8KAAAAAAAAAABPAAEAAc7////Y////CQAAAAIAAAAAAc3////6////CgAAAAAAAAAATwABAAY0AAAAJCBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUCBwYWRkb2NrMgAJJgAAAAHK////+v///woAAAAAAAAAAH8AAQAByf///9j///8JAAAAAgAAAAAAAcj////6////CgAAAAAAAAAAfwABAAY5AAAAHCBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAACSYAAAABxf////r///8KAAAAAAAAAABrAAEAAcT////Y////CQAAAAIAAAAAAcP////6////CgAAAAAAAAAAawABAAY+AAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazEACSYAAAABwP////r///8KAAAAAAAAAAAwAAEAAb/////Y////CQAAAAIAAAAAAb7////6////CgAAAAAAAAAAMAABAAZDAAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazIJJgAAAAG7////+v///woAAAAAAAAAACcAAQABuv///9j///8JAAAAAgAAAAAFuf///yNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwEAAAAHdmFsdWVfXwAIAgAAAAEAAAABuP////r///8KAAAAAAAAAAAnAAEABkkAAAAYIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQCSYAAAABtf////r///8KAAAAAAAAAACMAAEAAbT////Y////CQAAAAIAAAAAAAGz////uf///wEAAAABsv////r///8KAAAAAAAAAACMAAEABk8AAAAhIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQIHBhZGRvY2sxAAkmAAAAAa/////6////CgAAAAAAAAAATgABAAGu////2P///wkAAAACAAAAAAABrf///7n///8BAAAAAaz////6////CgAAAAAAAAAATgABAAZVAAAAISBzdG9yZV9iaW9tX2tnLCBNaWxsZXQgUCBwYWRkb2NrMgABqv////r///8K/////wAAAAAAAAIABlcAAAAIRkZGRkZGRkYBqP////r///8KgICA/wAAAAAAAAIABlkAAAAIRkY4MDgwODABpv////r///8K/////wAAAAAAAAIABlsAAAAIRkZGRkZGRkYBpP////r///8KgICA/wAAAAAAAAIABl0AAAAIRkY4MDgwODABov////r///8K/////wAAAAAAAAIABl8AAAAIRkZGRkZGRkYBoP////r///8KgICA/wAAAAAAAAIABmEAAAAIRkY4MDgwODABnv////r///8K/////wAAAAAAAAIABmMAAAAIRkZGRkZGRkYBnP////r///8KgICA/wAAAAAAAAIABmUAAAAIRkY4MDgwODAAUAAAAAZmAAAACCMjIzAuIyMjCRUAAAAJAAAAAAAQQQGY////+v///wr/////AAAAAAAAAgAGaQAAAAhGRkZGRkZGRgGW////+v///wqAgID/AAAAAAAAAgAGawAAAAhGRjgwODA4MAEAAAAFlP///yBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAEAAAAHdmFsdWVfXwAIBAAAAAIAAAAACgAAAAABk/////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGR////+v///wrAAAD/AAAAAAAAAgABkP////r///8K/wAA/wAAAAAAAAIAAY/////6////Cv////8AAAAAAAACAAZyAAAACEZGRkZGRkZGAY3////6////CoCAgP8AAAAAAAACAAZ0AAAACEZGODA4MDgwUAAAAAlmAAAACRUAAAAJAAAAAAAQQQGJ////+v///wr/////AAAAAAAAAgAGeAAAAAhGRkZGRkZGRgGH////+v///wqAgID/AAAAAAAAAgAGegAAAAhGRjgwODA4MAEAAAABhf///5T///8CAAAAAAABhP////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGC////+v///wr/AAD/AAAAAAAAAgABgf////r///8K/////wAAAAAAAAIABoAAAAAIRkZGRkZGRkYBf/////r///8KgICA/wAAAAAAAAIABoIAAAAIRkY4MDgwODAAUAAAAAlmAAAACRUAAAAJAAAAAAAQQQF7////+v///wr/////AAAAAAAAAgAGhgAAAAhGRkZGRkZGRgF5////+v///wqAgID/AAAAAAAAAgAGiAAAAAhGRjgwODA4MAEAAAABd////5T///8CAAAAAAABdv////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQF0////+v///wr/AAD/AAAAAAAAAgABc/////r///8K/////wAAAAAAAAIABo4AAAAIRkZGRkZGRkYBcf////r///8KgICA/wAAAAAAAAIABpAAAAAIRkY4MDgwODBQAAAABpEAAAAJZC9NTS95eXl5CWYAAAAJFQAAAAkAAAAAABBBAWz////6////Cv////8AAAAAAAACAAaVAAAACEZGRkZGRkZGAWr////6////CoCAgP8AAAAAAAACAAaXAAAACEZGODA4MDgwAQAAAAFo////lP///wIAAAAACgAAAAoAAAAAAWf////6////CgAAAP8AAAAAAAACAAkVAAAACwAAAAAAMEEBZf////r///8K/wAA/wAAAAAAAAIAAWT////6////Cv////8AAAAAAAACAAadAAAACEZGRkZGRkZGAWL////6////CoCAgP8AAAAAAAACAAafAAAACEZGODA4MDgwAWD////6////Cv////8AAAAAAAACAAahAAAACEZGRkZGRkZGAV7////6////CoCAgP8AAAAAAAACAAajAAAACEZGODA4MDgwAVz////6////Cv////8AAAAAAAACAAalAAAACEZGRkZGRkZGAVr////6////CoCAgP8AAAAAAAACAAanAAAACEZGODA4MDgwAVj////6////Cv////8AAAAAAAACAAapAAAACEZGRkZGRkZGAVb////6////CoCAgP8AAAAAAAACAAarAAAACEZGODA4MDgwAVT////6////Cv////8AAAAAAAACAAatAAAACEZGRkZGRkZGAVL////6////CoCAgP8AAAAAAAACAAavAAAACEZGODA4MDgwERQAAAABAAAABrAAAAAACw==</Format>
        <Plot>
          <SeriesType>Solid line</SeriesType>
          <PointType>None</PointType>
          <colour>
          </colour>
          <X>Date</X>
          <Y>herdsize_shoats</Y>
          <Y>herdsize_cows</Y>
          <GDApsimFileReader name="ApsimFileReader" />
        </Plot>
      </Graph>
      <Graph name="Flows">
        <Legend>
          <CheckedTitles> inputdmOfShoats</CheckedTitles>
          <CheckedTitles> faecdmOfShoats</CheckedTitles>
          <CheckedTitles> inputdmOfCows</CheckedTitles>
          <CheckedTitles> faecdmOfCows</CheckedTitles>
        </Legend>
        <Format>AAEAAAD/////AQAAAAAAAAAMAgAAAFhUZWVDaGFydC5DbGllbnQsIFZlcnNpb249NC4xLjIwMTEuNzI4MywgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj05YzgxMjYyNzZjNzdiZGI3DAMAAABXU3lzdGVtLldpbmRvd3MuRm9ybXMsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5DAQAAABRU3lzdGVtLkRyYXdpbmcsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iMDNmNWY3ZjExZDUwYTNhBQEAAAAVU3RlZW1hLlRlZUNoYXJ0LkNoYXJ0+AAAAA4uWm9vbS5BbmltYXRlZBMuWm9vbS5BbmltYXRlZFN0ZXBzFC5QYW5uaW5nLk1vdXNlQnV0dG9uEC5DdXN0b21DaGFydFJlY3QXLlBhbmVsLkltYWdlQmV2ZWwuV2lkdGgVLlBhbmVsLkJldmVsLkNvbG9yT25lGy5QYW5lbC5CZXZlbC5TdHJpbmdDb2xvck9uZRUuUGFuZWwuQmV2ZWwuQ29sb3JUd28bLlBhbmVsLkJldmVsLlN0cmluZ0NvbG9yVHdvEi5QYW5lbC5CZXZlbC5PdXRlchIuUGFuZWwuQnJ1c2guQ29sb3ISLkxlZ2VuZC5DaGVja0JveGVzEi5MZWdlbmQuTWF4TnVtUm93cxwuTGVnZW5kLlRpdGxlLkJldmVsLkNvbG9yT25lIi5MZWdlbmQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUcLkxlZ2VuZC5UaXRsZS5CZXZlbC5Db2xvclR3byIuTGVnZW5kLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvFi5MZWdlbmQuQmV2ZWwuQ29sb3JPbmUcLkxlZ2VuZC5CZXZlbC5TdHJpbmdDb2xvck9uZRYuTGVnZW5kLkJldmVsLkNvbG9yVHdvHC5MZWdlbmQuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkxlZ2VuZC5TaGFkb3cuVmlzaWJsZRMuTGVnZW5kLlRyYW5zcGFyZW50DS5IZWFkZXIuTGluZXMRLkhlYWRlci5Gb250Lk5hbWURLkhlYWRlci5Gb250LlNpemUWLkhlYWRlci5Gb250LlNpemVGbG9hdBYuSGVhZGVyLkJldmVsLkNvbG9yT25lHC5IZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUWLkhlYWRlci5CZXZlbC5Db2xvclR3bxwuSGVhZGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5TdWJIZWFkZXIuQmV2ZWwuQ29sb3JPbmUfLlN1YkhlYWRlci5CZXZlbC5TdHJpbmdDb2xvck9uZRkuU3ViSGVhZGVyLkJldmVsLkNvbG9yVHdvHy5TdWJIZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkZvb3Rlci5CZXZlbC5Db2xvck9uZRwuRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yT25lFi5Gb290ZXIuQmV2ZWwuQ29sb3JUd28cLkZvb3Rlci5CZXZlbC5TdHJpbmdDb2xvclR3bxkuU3ViRm9vdGVyLkJldmVsLkNvbG9yT25lHy5TdWJGb290ZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUZLlN1YkZvb3Rlci5CZXZlbC5Db2xvclR3bx8uU3ViRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5Bc3BlY3QuQ29sb3JQYWxldHRlSW5kZXgOLkFzcGVjdC5WaWV3M0QIU2VyaWVzLjAVLlNlcmllcy4wLkJydXNoLkNvbG9yFy5TZXJpZXMuMC5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMC5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMC5Db2xvckVhY2gRLlNlcmllcy4wLlZpc2libGUPLlNlcmllcy4wLkNvbG9yDy5TZXJpZXMuMC5UaXRsZRYuU2VyaWVzLjAuU2hvd0luTGVnZW5kCFNlcmllcy4xFS5TZXJpZXMuMS5CcnVzaC5Db2xvchcuU2VyaWVzLjEuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjEuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjEuQ29sb3JFYWNoDy5TZXJpZXMuMS5Db2xvcg8uU2VyaWVzLjEuVGl0bGUIU2VyaWVzLjIVLlNlcmllcy4yLkJydXNoLkNvbG9yFy5TZXJpZXMuMi5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMi5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMi5Db2xvckVhY2gPLlNlcmllcy4yLkNvbG9yDy5TZXJpZXMuMi5UaXRsZRYuU2VyaWVzLjIuU2hvd0luTGVnZW5kCFNlcmllcy4zFS5TZXJpZXMuMy5CcnVzaC5Db2xvchcuU2VyaWVzLjMuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjMuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjMuQ29sb3JFYWNoES5TZXJpZXMuMy5WaXNpYmxlDy5TZXJpZXMuMy5Db2xvcg8uU2VyaWVzLjMuVGl0bGUWLlNlcmllcy4zLlNob3dJbkxlZ2VuZAhTZXJpZXMuNBUuU2VyaWVzLjQuQnJ1c2guQ29sb3IXLlNlcmllcy40LlBvaW50ZXIuU3R5bGUXLlNlcmllcy40LkxpbmVQZW4uV2lkdGgTLlNlcmllcy40LkNvbG9yRWFjaA8uU2VyaWVzLjQuQ29sb3IPLlNlcmllcy40LlRpdGxlFi5TZXJpZXMuNC5TaG93SW5MZWdlbmQIU2VyaWVzLjUVLlNlcmllcy41LkJydXNoLkNvbG9yFy5TZXJpZXMuNS5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuNS5MaW5lUGVuLldpZHRoEy5TZXJpZXMuNS5Db2xvckVhY2gPLlNlcmllcy41LkNvbG9yDy5TZXJpZXMuNS5UaXRsZQhTZXJpZXMuNhUuU2VyaWVzLjYuQnJ1c2guQ29sb3IXLlNlcmllcy42LlBvaW50ZXIuU3R5bGUXLlNlcmllcy42LkxpbmVQZW4uV2lkdGgTLlNlcmllcy42LkNvbG9yRWFjaBIuU2VyaWVzLjYuVmVydEF4aXMPLlNlcmllcy42LkNvbG9yDy5TZXJpZXMuNi5UaXRsZQhTZXJpZXMuNxUuU2VyaWVzLjcuQnJ1c2guQ29sb3IXLlNlcmllcy43LlBvaW50ZXIuU3R5bGUXLlNlcmllcy43LkxpbmVQZW4uV2lkdGgTLlNlcmllcy43LkNvbG9yRWFjaBEuU2VyaWVzLjcuVmlzaWJsZRIuU2VyaWVzLjcuVmVydEF4aXMPLlNlcmllcy43LkNvbG9yDy5TZXJpZXMuNy5UaXRsZRYuU2VyaWVzLjcuU2hvd0luTGVnZW5kCFNlcmllcy44FS5TZXJpZXMuOC5CcnVzaC5Db2xvchcuU2VyaWVzLjguUG9pbnRlci5TdHlsZRcuU2VyaWVzLjguTGluZVBlbi5XaWR0aBMuU2VyaWVzLjguQ29sb3JFYWNoES5TZXJpZXMuOC5WaXNpYmxlEi5TZXJpZXMuOC5WZXJ0QXhpcw8uU2VyaWVzLjguQ29sb3IPLlNlcmllcy44LlRpdGxlFi5TZXJpZXMuOC5TaG93SW5MZWdlbmQaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JPbmUgLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JPbmUaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JUd28gLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JUd28bLldhbGxzLlJpZ2h0LkJldmVsLkNvbG9yT25lIS5XYWxscy5SaWdodC5CZXZlbC5TdHJpbmdDb2xvck9uZRsuV2FsbHMuUmlnaHQuQmV2ZWwuQ29sb3JUd28hLldhbGxzLlJpZ2h0LkJldmVsLlN0cmluZ0NvbG9yVHdvGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yT25lIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yT25lGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yVHdvIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yVHdvHC5XYWxscy5Cb3R0b20uQmV2ZWwuQ29sb3JPbmUiLldhbGxzLkJvdHRvbS5CZXZlbC5TdHJpbmdDb2xvck9uZRwuV2FsbHMuQm90dG9tLkJldmVsLkNvbG9yVHdvIi5XYWxscy5Cb3R0b20uQmV2ZWwuU3RyaW5nQ29sb3JUd28OLldhbGxzLlZpc2libGUcLkF4ZXMuTGVmdC5MYWJlbHMuU2VwYXJhdGlvbh0uQXhlcy5MZWZ0LkxhYmVscy5WYWx1ZUZvcm1hdBsuQXhlcy5MZWZ0LkxhYmVscy5Gb250Lk5hbWUbLkF4ZXMuTGVmdC5MYWJlbHMuRm9udC5TaXplIC5BeGVzLkxlZnQuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0IC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yT25lJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yT25lIC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yVHdvJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGC5BeGVzLkxlZnQuQXhpc1Blbi5XaWR0aBkuQXhlcy5MZWZ0LkF4aXNQZW4uRW5kQ2FwFy5BeGVzLkxlZnQuR3JpZC5WaXNpYmxlGC5BeGVzLkxlZnQuTWF4aW11bU9mZnNldB0uQXhlcy5MZWZ0Lk1pbm9yVGlja3MuVmlzaWJsZRYuQXhlcy5MZWZ0LlRpY2tzLkNvbG9yGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5OYW1lGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplHy5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplRmxvYXQoLkF4ZXMuTGVmdC5UaXRsZS5Gb250LlNoYWRvdy5CcnVzaC5Db2xvciEuQXhlcy5MZWZ0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IfLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5Db2xvck9uZSUuQXhlcy5MZWZ0LlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHy5BeGVzLkxlZnQuVGl0bGUuQmV2ZWwuQ29sb3JUd28lLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bxsuQXhlcy5Ub3AuTGFiZWxzLlNlcGFyYXRpb24cLkF4ZXMuVG9wLkxhYmVscy5WYWx1ZUZvcm1hdBouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuTmFtZRouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZR8uQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Hy5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUlLkF4ZXMuVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZR8uQXhlcy5Ub3AuTGFiZWxzLkJldmVsLkNvbG9yVHdvJS5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28XLkF4ZXMuVG9wLkF4aXNQZW4uV2lkdGgYLkF4ZXMuVG9wLkF4aXNQZW4uRW5kQ2FwFi5BeGVzLlRvcC5HcmlkLlZpc2libGUcLkF4ZXMuVG9wLk1pbm9yVGlja3MuVmlzaWJsZRUuQXhlcy5Ub3AuVGlja3MuQ29sb3IZLkF4ZXMuVG9wLlRpdGxlLkZvbnQuTmFtZRkuQXhlcy5Ub3AuVGl0bGUuRm9udC5TaXplHi5BeGVzLlRvcC5UaXRsZS5Gb250LlNpemVGbG9hdCAuQXhlcy5Ub3AuVGl0bGUuRm9udC5CcnVzaC5Db2xvch4uQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuQ29sb3JPbmUkLkF4ZXMuVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHi5BeGVzLlRvcC5UaXRsZS5CZXZlbC5Db2xvclR3byQuQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28RLkF4ZXMuVG9wLlZpc2libGUdLkF4ZXMuUmlnaHQuTGFiZWxzLlNlcGFyYXRpb24eLkF4ZXMuUmlnaHQuTGFiZWxzLlZhbHVlRm9ybWF0HC5BeGVzLlJpZ2h0LkxhYmVscy5Gb250Lk5hbWUcLkF4ZXMuUmlnaHQuTGFiZWxzLkZvbnQuU2l6ZSEuQXhlcy5SaWdodC5MYWJlbHMuRm9udC5TaXplRmxvYXQhLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLkNvbG9yT25lJy5BeGVzLlJpZ2h0LkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSEuQXhlcy5SaWdodC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28nLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5BeGVzLlJpZ2h0LkF4aXNQZW4uV2lkdGgaLkF4ZXMuUmlnaHQuQXhpc1Blbi5FbmRDYXAYLkF4ZXMuUmlnaHQuR3JpZC5WaXNpYmxlHi5BeGVzLlJpZ2h0Lk1pbm9yVGlja3MuVmlzaWJsZRcuQXhlcy5SaWdodC5UaWNrcy5Db2xvchsuQXhlcy5SaWdodC5UaXRsZS5Gb250Lk5hbWUbLkF4ZXMuUmlnaHQuVGl0bGUuRm9udC5TaXplIC5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JPbmUmLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JUd28mLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28eLkF4ZXMuQm90dG9tLkxhYmVscy5TZXBhcmF0aW9uIi5BeGVzLkJvdHRvbS5MYWJlbHMuRGF0ZVRpbWVGb3JtYXQfLkF4ZXMuQm90dG9tLkxhYmVscy5WYWx1ZUZvcm1hdB0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuTmFtZR0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUoLkF4ZXMuQm90dG9tLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkJldmVsLkNvbG9yVHdvKC5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28aLkF4ZXMuQm90dG9tLkF4aXNQZW4uV2lkdGgbLkF4ZXMuQm90dG9tLkF4aXNQZW4uRW5kQ2FwGS5BeGVzLkJvdHRvbS5HcmlkLlZpc2libGUaLkF4ZXMuQm90dG9tLk1heGltdW1PZmZzZXQaLkF4ZXMuQm90dG9tLk1pbmltdW1PZmZzZXQfLkF4ZXMuQm90dG9tLk1pbm9yVGlja3MuVmlzaWJsZRguQXhlcy5Cb3R0b20uVGlja3MuQ29sb3IcLkF4ZXMuQm90dG9tLlRpdGxlLkZvbnQuTmFtZRwuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5TaXplIS5BeGVzLkJvdHRvbS5UaXRsZS5Gb250LlNpemVGbG9hdCMuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5CcnVzaC5Db2xvciEuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuQ29sb3JPbmUnLkF4ZXMuQm90dG9tLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIS5BeGVzLkJvdHRvbS5UaXRsZS5CZXZlbC5Db2xvclR3bycuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28kLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLkNvbG9yT25lKi5BeGVzLkRlcHRoVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSQuQXhlcy5EZXB0aFRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28qLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yT25lKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yVHdvKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvIS5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5Db2xvck9uZScuQXhlcy5EZXB0aC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JPbmUhLkF4ZXMuRGVwdGguTGFiZWxzLkJldmVsLkNvbG9yVHdvJy5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvclR3byAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvck9uZSYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvck9uZSAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvclR3byYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bwAABAAABAEEAQQEAAAEAQQBBAEEAQAABgEAAAQBBAEEAQQBBAEEAQQBBAEAAAEEBAAAAAQBAAEEBAAABAEBBAQAAAQBAAEEBAAAAAQBAAEEBAAABAEAAQQEAAAEAQEEBAAABAQBAQQEAAAABAQBAAEEBAAAAAQEAQAEAQQBBAEEAQQBBAEEAQQBAAABAQAABAEEAQAEAAAABAEAAAQEBAEEAQABAQAABAEEAQAEAAAEAQAABAQBBAEAAAEBAAAEAQQBAAQAAAQBAAAEBAEEAQABAQEAAAQBBAEABAAAAAAEAQAABAQBBAEEAQQBBAEEAQQBBAEEAQQBAQghU3lzdGVtLldpbmRvd3MuRm9ybXMuTW91c2VCdXR0b25zAwAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAjU3RlZW1hLlRlZUNoYXJ0LkRyYXdpbmcuQmV2ZWxTdHlsZXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEBCAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEjU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5WZXJ0aWNhbEF4aXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAIIFN5c3RlbS5EcmF3aW5nLkRyYXdpbmcyRC5MaW5lQ2FwBAAAAAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAACAAAAAQQAAAAF+////yFTeXN0ZW0uV2luZG93cy5Gb3Jtcy5Nb3VzZUJ1dHRvbnMBAAAAB3ZhbHVlX18ACAMAAAAAAEAAAAEAAAAF+v///xRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAEbmFtZQV2YWx1ZQprbm93bkNvbG9yBXN0YXRlAQAAAAkHBwQAAAAK/////wAAAAAAAAIABgcAAAAIRkZGRkZGRkYB+P////r///8KgICA/wAAAAAAAAIABgkAAAAIRkY4MDgwODAF9v///yNTdGVlbWEuVGVlQ2hhcnQuRHJhd2luZy5CZXZlbFN0eWxlcwEAAAAHdmFsdWVfXwAIAgAAAAAAAAAB9f////r///8K/////wAAAAAAAAIAAQgAAAAB9P////r///8K/////wAAAAAAAAIABg0AAAAIRkZGRkZGRkYB8v////r///8KgICA/wAAAAAAAAIABg8AAAAIRkY4MDgwODAB8P////r///8K/////wAAAAAAAAIABhEAAAAIRkZGRkZGRkYB7v////r///8KgICA/wAAAAAAAAIABhMAAAAIRkY4MDgwODAAAQkUAAAABhUAAAAGVGFob21hDAAAAAAAQEEB6v////r///8K/////wAAAAAAAAIABhcAAAAIRkZGRkZGRkYB6P////r///8KgICA/wAAAAAAAAIABhkAAAAIRkY4MDgwODAB5v////r///8K/////wAAAAAAAAIABhsAAAAIRkZGRkZGRkYB5P////r///8KgICA/wAAAAAAAAIABh0AAAAIRkY4MDgwODAB4v////r///8K/////wAAAAAAAAIABh8AAAAIRkZGRkZGRkYB4P////r///8KgICA/wAAAAAAAAIABiEAAAAIRkY4MDgwODAB3v////r///8K/////wAAAAAAAAIABiMAAAAIRkZGRkZGRkYB3P////r///8KgICA/wAAAAAAAAIABiUAAAAIRkY4MDgwODADAAAAAAYmAAAAG1N0ZWVtYS5UZWVDaGFydC5TdHlsZXMuTGluZQHZ////+v///woAAAAAAAAAACUAAQAF2P///yRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMBAAAAB3ZhbHVlX18ACAIAAAAJAAAAAgAAAAAAAdf////6////CgAAAAAAAAAAJQABAAYqAAAAGyBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUAAJJgAAAAHU////+v///woAAAAAAAAAAI0AAQAB0////9j///8JAAAAAgAAAAAB0v////r///8KAAAAAAAAAACNAAEABi8AAAAkIG1pbGxldF9iaW9tX2tnaGEsIE1pbGxldCBQIHBhZGRvY2sxCSYAAAABz/////r///8KAAAAAAAAAABPAAEAAc7////Y////CQAAAAIAAAAAAc3////6////CgAAAAAAAAAATwABAAY0AAAAJCBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUCBwYWRkb2NrMgAJJgAAAAHK////+v///woAAAAAAAAAAH8AAQAByf///9j///8JAAAAAgAAAAAAAcj////6////CgAAAAAAAAAAfwABAAY5AAAAHCBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAACSYAAAABxf////r///8KAAAAAAAAAABrAAEAAcT////Y////CQAAAAIAAAAAAcP////6////CgAAAAAAAAAAawABAAY+AAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazEACSYAAAABwP////r///8KAAAAAAAAAAAwAAEAAb/////Y////CQAAAAIAAAAAAb7////6////CgAAAAAAAAAAMAABAAZDAAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazIJJgAAAAG7////+v///woAAAAAAAAAACcAAQABuv///9j///8JAAAAAgAAAAAFuf///yNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwEAAAAHdmFsdWVfXwAIAgAAAAEAAAABuP////r///8KAAAAAAAAAAAnAAEABkkAAAAYIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQCSYAAAABtf////r///8KAAAAAAAAAACMAAEAAbT////Y////CQAAAAIAAAAAAAGz////uf///wEAAAABsv////r///8KAAAAAAAAAACMAAEABk8AAAAhIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQIHBhZGRvY2sxAAkmAAAAAa/////6////CgAAAAAAAAAATgABAAGu////2P///wkAAAACAAAAAAABrf///7n///8BAAAAAaz////6////CgAAAAAAAAAATgABAAZVAAAAISBzdG9yZV9iaW9tX2tnLCBNaWxsZXQgUCBwYWRkb2NrMgABqv////r///8K/////wAAAAAAAAIABlcAAAAIRkZGRkZGRkYBqP////r///8KgICA/wAAAAAAAAIABlkAAAAIRkY4MDgwODABpv////r///8K/////wAAAAAAAAIABlsAAAAIRkZGRkZGRkYBpP////r///8KgICA/wAAAAAAAAIABl0AAAAIRkY4MDgwODABov////r///8K/////wAAAAAAAAIABl8AAAAIRkZGRkZGRkYBoP////r///8KgICA/wAAAAAAAAIABmEAAAAIRkY4MDgwODABnv////r///8K/////wAAAAAAAAIABmMAAAAIRkZGRkZGRkYBnP////r///8KgICA/wAAAAAAAAIABmUAAAAIRkY4MDgwODAAUAAAAAZmAAAACCMjIzAuIyMjCRUAAAAJAAAAAAAQQQGY////+v///wr/////AAAAAAAAAgAGaQAAAAhGRkZGRkZGRgGW////+v///wqAgID/AAAAAAAAAgAGawAAAAhGRjgwODA4MAEAAAAFlP///yBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAEAAAAHdmFsdWVfXwAIBAAAAAIAAAAACgAAAAABk/////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGR////+v///wrAAAD/AAAAAAAAAgABkP////r///8K/wAA/wAAAAAAAAIAAY/////6////Cv////8AAAAAAAACAAZyAAAACEZGRkZGRkZGAY3////6////CoCAgP8AAAAAAAACAAZ0AAAACEZGODA4MDgwUAAAAAlmAAAACRUAAAAJAAAAAAAQQQGJ////+v///wr/////AAAAAAAAAgAGeAAAAAhGRkZGRkZGRgGH////+v///wqAgID/AAAAAAAAAgAGegAAAAhGRjgwODA4MAEAAAABhf///5T///8CAAAAAAABhP////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGC////+v///wr/AAD/AAAAAAAAAgABgf////r///8K/////wAAAAAAAAIABoAAAAAIRkZGRkZGRkYBf/////r///8KgICA/wAAAAAAAAIABoIAAAAIRkY4MDgwODAAUAAAAAlmAAAACRUAAAAJAAAAAAAQQQF7////+v///wr/////AAAAAAAAAgAGhgAAAAhGRkZGRkZGRgF5////+v///wqAgID/AAAAAAAAAgAGiAAAAAhGRjgwODA4MAEAAAABd////5T///8CAAAAAAABdv////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQF0////+v///wr/AAD/AAAAAAAAAgABc/////r///8K/////wAAAAAAAAIABo4AAAAIRkZGRkZGRkYBcf////r///8KgICA/wAAAAAAAAIABpAAAAAIRkY4MDgwODBQAAAABpEAAAAJZC9NTS95eXl5CWYAAAAJFQAAAAkAAAAAABBBAWz////6////Cv////8AAAAAAAACAAaVAAAACEZGRkZGRkZGAWr////6////CoCAgP8AAAAAAAACAAaXAAAACEZGODA4MDgwAQAAAAFo////lP///wIAAAAACgAAAAoAAAAAAWf////6////CgAAAP8AAAAAAAACAAkVAAAACwAAAAAAMEEBZf////r///8K/wAA/wAAAAAAAAIAAWT////6////Cv////8AAAAAAAACAAadAAAACEZGRkZGRkZGAWL////6////CoCAgP8AAAAAAAACAAafAAAACEZGODA4MDgwAWD////6////Cv////8AAAAAAAACAAahAAAACEZGRkZGRkZGAV7////6////CoCAgP8AAAAAAAACAAajAAAACEZGODA4MDgwAVz////6////Cv////8AAAAAAAACAAalAAAACEZGRkZGRkZGAVr////6////CoCAgP8AAAAAAAACAAanAAAACEZGODA4MDgwAVj////6////Cv////8AAAAAAAACAAapAAAACEZGRkZGRkZGAVb////6////CoCAgP8AAAAAAAACAAarAAAACEZGODA4MDgwAVT////6////Cv////8AAAAAAAACAAatAAAACEZGRkZGRkZGAVL////6////CoCAgP8AAAAAAAACAAavAAAACEZGODA4MDgwERQAAAABAAAABrAAAAAACw==</Format>
        <Plot>
          <SeriesType>Solid line</SeriesType>
          <PointType>None</PointType>
          <colour>
          </colour>
          <X>Date</X>
          <Y>inputdmOfShoats</Y>
          <Y>faecdmOfShoats</Y>
          <Y>inputdmOfCows</Y>
          <Y>faecdmOfCows</Y>
          <GDApsimFileReader name="ApsimFileReader" />
        </Plot>
      </Graph>
      <Graph name="Eaten">
        <Legend>
          <CheckedTitles> grass_eaten</CheckedTitles>
          <CheckedTitles> bran_eaten</CheckedTitles>
          <CheckedTitles> maize_eaten</CheckedTitles>
          <CheckedTitles> mucuna_eaten</CheckedTitles>
        </Legend>
        <Format>AAEAAAD/////AQAAAAAAAAAMAgAAAFhUZWVDaGFydC5DbGllbnQsIFZlcnNpb249NC4xLjIwMTEuNzI4MywgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj05YzgxMjYyNzZjNzdiZGI3DAMAAABXU3lzdGVtLldpbmRvd3MuRm9ybXMsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5DAQAAABRU3lzdGVtLkRyYXdpbmcsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iMDNmNWY3ZjExZDUwYTNhBQEAAAAVU3RlZW1hLlRlZUNoYXJ0LkNoYXJ0+AAAAA4uWm9vbS5BbmltYXRlZBMuWm9vbS5BbmltYXRlZFN0ZXBzFC5QYW5uaW5nLk1vdXNlQnV0dG9uEC5DdXN0b21DaGFydFJlY3QXLlBhbmVsLkltYWdlQmV2ZWwuV2lkdGgVLlBhbmVsLkJldmVsLkNvbG9yT25lGy5QYW5lbC5CZXZlbC5TdHJpbmdDb2xvck9uZRUuUGFuZWwuQmV2ZWwuQ29sb3JUd28bLlBhbmVsLkJldmVsLlN0cmluZ0NvbG9yVHdvEi5QYW5lbC5CZXZlbC5PdXRlchIuUGFuZWwuQnJ1c2guQ29sb3ISLkxlZ2VuZC5DaGVja0JveGVzEi5MZWdlbmQuTWF4TnVtUm93cxwuTGVnZW5kLlRpdGxlLkJldmVsLkNvbG9yT25lIi5MZWdlbmQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUcLkxlZ2VuZC5UaXRsZS5CZXZlbC5Db2xvclR3byIuTGVnZW5kLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvFi5MZWdlbmQuQmV2ZWwuQ29sb3JPbmUcLkxlZ2VuZC5CZXZlbC5TdHJpbmdDb2xvck9uZRYuTGVnZW5kLkJldmVsLkNvbG9yVHdvHC5MZWdlbmQuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkxlZ2VuZC5TaGFkb3cuVmlzaWJsZRMuTGVnZW5kLlRyYW5zcGFyZW50DS5IZWFkZXIuTGluZXMRLkhlYWRlci5Gb250Lk5hbWURLkhlYWRlci5Gb250LlNpemUWLkhlYWRlci5Gb250LlNpemVGbG9hdBYuSGVhZGVyLkJldmVsLkNvbG9yT25lHC5IZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUWLkhlYWRlci5CZXZlbC5Db2xvclR3bxwuSGVhZGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5TdWJIZWFkZXIuQmV2ZWwuQ29sb3JPbmUfLlN1YkhlYWRlci5CZXZlbC5TdHJpbmdDb2xvck9uZRkuU3ViSGVhZGVyLkJldmVsLkNvbG9yVHdvHy5TdWJIZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkZvb3Rlci5CZXZlbC5Db2xvck9uZRwuRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yT25lFi5Gb290ZXIuQmV2ZWwuQ29sb3JUd28cLkZvb3Rlci5CZXZlbC5TdHJpbmdDb2xvclR3bxkuU3ViRm9vdGVyLkJldmVsLkNvbG9yT25lHy5TdWJGb290ZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUZLlN1YkZvb3Rlci5CZXZlbC5Db2xvclR3bx8uU3ViRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5Bc3BlY3QuQ29sb3JQYWxldHRlSW5kZXgOLkFzcGVjdC5WaWV3M0QIU2VyaWVzLjAVLlNlcmllcy4wLkJydXNoLkNvbG9yFy5TZXJpZXMuMC5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMC5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMC5Db2xvckVhY2gRLlNlcmllcy4wLlZpc2libGUPLlNlcmllcy4wLkNvbG9yDy5TZXJpZXMuMC5UaXRsZRYuU2VyaWVzLjAuU2hvd0luTGVnZW5kCFNlcmllcy4xFS5TZXJpZXMuMS5CcnVzaC5Db2xvchcuU2VyaWVzLjEuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjEuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjEuQ29sb3JFYWNoDy5TZXJpZXMuMS5Db2xvcg8uU2VyaWVzLjEuVGl0bGUIU2VyaWVzLjIVLlNlcmllcy4yLkJydXNoLkNvbG9yFy5TZXJpZXMuMi5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMi5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMi5Db2xvckVhY2gPLlNlcmllcy4yLkNvbG9yDy5TZXJpZXMuMi5UaXRsZRYuU2VyaWVzLjIuU2hvd0luTGVnZW5kCFNlcmllcy4zFS5TZXJpZXMuMy5CcnVzaC5Db2xvchcuU2VyaWVzLjMuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjMuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjMuQ29sb3JFYWNoES5TZXJpZXMuMy5WaXNpYmxlDy5TZXJpZXMuMy5Db2xvcg8uU2VyaWVzLjMuVGl0bGUWLlNlcmllcy4zLlNob3dJbkxlZ2VuZAhTZXJpZXMuNBUuU2VyaWVzLjQuQnJ1c2guQ29sb3IXLlNlcmllcy40LlBvaW50ZXIuU3R5bGUXLlNlcmllcy40LkxpbmVQZW4uV2lkdGgTLlNlcmllcy40LkNvbG9yRWFjaA8uU2VyaWVzLjQuQ29sb3IPLlNlcmllcy40LlRpdGxlFi5TZXJpZXMuNC5TaG93SW5MZWdlbmQIU2VyaWVzLjUVLlNlcmllcy41LkJydXNoLkNvbG9yFy5TZXJpZXMuNS5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuNS5MaW5lUGVuLldpZHRoEy5TZXJpZXMuNS5Db2xvckVhY2gPLlNlcmllcy41LkNvbG9yDy5TZXJpZXMuNS5UaXRsZQhTZXJpZXMuNhUuU2VyaWVzLjYuQnJ1c2guQ29sb3IXLlNlcmllcy42LlBvaW50ZXIuU3R5bGUXLlNlcmllcy42LkxpbmVQZW4uV2lkdGgTLlNlcmllcy42LkNvbG9yRWFjaBIuU2VyaWVzLjYuVmVydEF4aXMPLlNlcmllcy42LkNvbG9yDy5TZXJpZXMuNi5UaXRsZQhTZXJpZXMuNxUuU2VyaWVzLjcuQnJ1c2guQ29sb3IXLlNlcmllcy43LlBvaW50ZXIuU3R5bGUXLlNlcmllcy43LkxpbmVQZW4uV2lkdGgTLlNlcmllcy43LkNvbG9yRWFjaBEuU2VyaWVzLjcuVmlzaWJsZRIuU2VyaWVzLjcuVmVydEF4aXMPLlNlcmllcy43LkNvbG9yDy5TZXJpZXMuNy5UaXRsZRYuU2VyaWVzLjcuU2hvd0luTGVnZW5kCFNlcmllcy44FS5TZXJpZXMuOC5CcnVzaC5Db2xvchcuU2VyaWVzLjguUG9pbnRlci5TdHlsZRcuU2VyaWVzLjguTGluZVBlbi5XaWR0aBMuU2VyaWVzLjguQ29sb3JFYWNoES5TZXJpZXMuOC5WaXNpYmxlEi5TZXJpZXMuOC5WZXJ0QXhpcw8uU2VyaWVzLjguQ29sb3IPLlNlcmllcy44LlRpdGxlFi5TZXJpZXMuOC5TaG93SW5MZWdlbmQaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JPbmUgLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JPbmUaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JUd28gLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JUd28bLldhbGxzLlJpZ2h0LkJldmVsLkNvbG9yT25lIS5XYWxscy5SaWdodC5CZXZlbC5TdHJpbmdDb2xvck9uZRsuV2FsbHMuUmlnaHQuQmV2ZWwuQ29sb3JUd28hLldhbGxzLlJpZ2h0LkJldmVsLlN0cmluZ0NvbG9yVHdvGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yT25lIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yT25lGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yVHdvIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yVHdvHC5XYWxscy5Cb3R0b20uQmV2ZWwuQ29sb3JPbmUiLldhbGxzLkJvdHRvbS5CZXZlbC5TdHJpbmdDb2xvck9uZRwuV2FsbHMuQm90dG9tLkJldmVsLkNvbG9yVHdvIi5XYWxscy5Cb3R0b20uQmV2ZWwuU3RyaW5nQ29sb3JUd28OLldhbGxzLlZpc2libGUcLkF4ZXMuTGVmdC5MYWJlbHMuU2VwYXJhdGlvbh0uQXhlcy5MZWZ0LkxhYmVscy5WYWx1ZUZvcm1hdBsuQXhlcy5MZWZ0LkxhYmVscy5Gb250Lk5hbWUbLkF4ZXMuTGVmdC5MYWJlbHMuRm9udC5TaXplIC5BeGVzLkxlZnQuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0IC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yT25lJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yT25lIC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yVHdvJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGC5BeGVzLkxlZnQuQXhpc1Blbi5XaWR0aBkuQXhlcy5MZWZ0LkF4aXNQZW4uRW5kQ2FwFy5BeGVzLkxlZnQuR3JpZC5WaXNpYmxlGC5BeGVzLkxlZnQuTWF4aW11bU9mZnNldB0uQXhlcy5MZWZ0Lk1pbm9yVGlja3MuVmlzaWJsZRYuQXhlcy5MZWZ0LlRpY2tzLkNvbG9yGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5OYW1lGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplHy5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplRmxvYXQoLkF4ZXMuTGVmdC5UaXRsZS5Gb250LlNoYWRvdy5CcnVzaC5Db2xvciEuQXhlcy5MZWZ0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IfLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5Db2xvck9uZSUuQXhlcy5MZWZ0LlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHy5BeGVzLkxlZnQuVGl0bGUuQmV2ZWwuQ29sb3JUd28lLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bxsuQXhlcy5Ub3AuTGFiZWxzLlNlcGFyYXRpb24cLkF4ZXMuVG9wLkxhYmVscy5WYWx1ZUZvcm1hdBouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuTmFtZRouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZR8uQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Hy5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUlLkF4ZXMuVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZR8uQXhlcy5Ub3AuTGFiZWxzLkJldmVsLkNvbG9yVHdvJS5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28XLkF4ZXMuVG9wLkF4aXNQZW4uV2lkdGgYLkF4ZXMuVG9wLkF4aXNQZW4uRW5kQ2FwFi5BeGVzLlRvcC5HcmlkLlZpc2libGUcLkF4ZXMuVG9wLk1pbm9yVGlja3MuVmlzaWJsZRUuQXhlcy5Ub3AuVGlja3MuQ29sb3IZLkF4ZXMuVG9wLlRpdGxlLkZvbnQuTmFtZRkuQXhlcy5Ub3AuVGl0bGUuRm9udC5TaXplHi5BeGVzLlRvcC5UaXRsZS5Gb250LlNpemVGbG9hdCAuQXhlcy5Ub3AuVGl0bGUuRm9udC5CcnVzaC5Db2xvch4uQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuQ29sb3JPbmUkLkF4ZXMuVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHi5BeGVzLlRvcC5UaXRsZS5CZXZlbC5Db2xvclR3byQuQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28RLkF4ZXMuVG9wLlZpc2libGUdLkF4ZXMuUmlnaHQuTGFiZWxzLlNlcGFyYXRpb24eLkF4ZXMuUmlnaHQuTGFiZWxzLlZhbHVlRm9ybWF0HC5BeGVzLlJpZ2h0LkxhYmVscy5Gb250Lk5hbWUcLkF4ZXMuUmlnaHQuTGFiZWxzLkZvbnQuU2l6ZSEuQXhlcy5SaWdodC5MYWJlbHMuRm9udC5TaXplRmxvYXQhLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLkNvbG9yT25lJy5BeGVzLlJpZ2h0LkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSEuQXhlcy5SaWdodC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28nLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5BeGVzLlJpZ2h0LkF4aXNQZW4uV2lkdGgaLkF4ZXMuUmlnaHQuQXhpc1Blbi5FbmRDYXAYLkF4ZXMuUmlnaHQuR3JpZC5WaXNpYmxlHi5BeGVzLlJpZ2h0Lk1pbm9yVGlja3MuVmlzaWJsZRcuQXhlcy5SaWdodC5UaWNrcy5Db2xvchsuQXhlcy5SaWdodC5UaXRsZS5Gb250Lk5hbWUbLkF4ZXMuUmlnaHQuVGl0bGUuRm9udC5TaXplIC5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JPbmUmLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JUd28mLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28eLkF4ZXMuQm90dG9tLkxhYmVscy5TZXBhcmF0aW9uIi5BeGVzLkJvdHRvbS5MYWJlbHMuRGF0ZVRpbWVGb3JtYXQfLkF4ZXMuQm90dG9tLkxhYmVscy5WYWx1ZUZvcm1hdB0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuTmFtZR0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUoLkF4ZXMuQm90dG9tLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkJldmVsLkNvbG9yVHdvKC5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28aLkF4ZXMuQm90dG9tLkF4aXNQZW4uV2lkdGgbLkF4ZXMuQm90dG9tLkF4aXNQZW4uRW5kQ2FwGS5BeGVzLkJvdHRvbS5HcmlkLlZpc2libGUaLkF4ZXMuQm90dG9tLk1heGltdW1PZmZzZXQaLkF4ZXMuQm90dG9tLk1pbmltdW1PZmZzZXQfLkF4ZXMuQm90dG9tLk1pbm9yVGlja3MuVmlzaWJsZRguQXhlcy5Cb3R0b20uVGlja3MuQ29sb3IcLkF4ZXMuQm90dG9tLlRpdGxlLkZvbnQuTmFtZRwuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5TaXplIS5BeGVzLkJvdHRvbS5UaXRsZS5Gb250LlNpemVGbG9hdCMuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5CcnVzaC5Db2xvciEuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuQ29sb3JPbmUnLkF4ZXMuQm90dG9tLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIS5BeGVzLkJvdHRvbS5UaXRsZS5CZXZlbC5Db2xvclR3bycuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28kLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLkNvbG9yT25lKi5BeGVzLkRlcHRoVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSQuQXhlcy5EZXB0aFRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28qLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yT25lKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yVHdvKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvIS5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5Db2xvck9uZScuQXhlcy5EZXB0aC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JPbmUhLkF4ZXMuRGVwdGguTGFiZWxzLkJldmVsLkNvbG9yVHdvJy5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvclR3byAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvck9uZSYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvck9uZSAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvclR3byYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bwAABAAABAEEAQQEAAAEAQQBBAEEAQAABgEAAAQBBAEEAQQBBAEEAQQBBAEAAAEEBAAAAAQBAAEEBAAABAEBBAQAAAQBAAEEBAAAAAQBAAEEBAAABAEAAQQEAAAEAQEEBAAABAQBAQQEAAAABAQBAAEEBAAAAAQEAQAEAQQBBAEEAQQBBAEEAQQBAAABAQAABAEEAQAEAAAABAEAAAQEBAEEAQABAQAABAEEAQAEAAAEAQAABAQBBAEAAAEBAAAEAQQBAAQAAAQBAAAEBAEEAQABAQEAAAQBBAEABAAAAAAEAQAABAQBBAEEAQQBBAEEAQQBBAEEAQQBAQghU3lzdGVtLldpbmRvd3MuRm9ybXMuTW91c2VCdXR0b25zAwAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAjU3RlZW1hLlRlZUNoYXJ0LkRyYXdpbmcuQmV2ZWxTdHlsZXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEBCAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEjU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5WZXJ0aWNhbEF4aXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAIIFN5c3RlbS5EcmF3aW5nLkRyYXdpbmcyRC5MaW5lQ2FwBAAAAAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAACAAAAAQQAAAAF+////yFTeXN0ZW0uV2luZG93cy5Gb3Jtcy5Nb3VzZUJ1dHRvbnMBAAAAB3ZhbHVlX18ACAMAAAAAAEAAAAEAAAAF+v///xRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAEbmFtZQV2YWx1ZQprbm93bkNvbG9yBXN0YXRlAQAAAAkHBwQAAAAK/////wAAAAAAAAIABgcAAAAIRkZGRkZGRkYB+P////r///8KgICA/wAAAAAAAAIABgkAAAAIRkY4MDgwODAF9v///yNTdGVlbWEuVGVlQ2hhcnQuRHJhd2luZy5CZXZlbFN0eWxlcwEAAAAHdmFsdWVfXwAIAgAAAAAAAAAB9f////r///8K/////wAAAAAAAAIAAQgAAAAB9P////r///8K/////wAAAAAAAAIABg0AAAAIRkZGRkZGRkYB8v////r///8KgICA/wAAAAAAAAIABg8AAAAIRkY4MDgwODAB8P////r///8K/////wAAAAAAAAIABhEAAAAIRkZGRkZGRkYB7v////r///8KgICA/wAAAAAAAAIABhMAAAAIRkY4MDgwODAAAQkUAAAABhUAAAAGVGFob21hDAAAAAAAQEEB6v////r///8K/////wAAAAAAAAIABhcAAAAIRkZGRkZGRkYB6P////r///8KgICA/wAAAAAAAAIABhkAAAAIRkY4MDgwODAB5v////r///8K/////wAAAAAAAAIABhsAAAAIRkZGRkZGRkYB5P////r///8KgICA/wAAAAAAAAIABh0AAAAIRkY4MDgwODAB4v////r///8K/////wAAAAAAAAIABh8AAAAIRkZGRkZGRkYB4P////r///8KgICA/wAAAAAAAAIABiEAAAAIRkY4MDgwODAB3v////r///8K/////wAAAAAAAAIABiMAAAAIRkZGRkZGRkYB3P////r///8KgICA/wAAAAAAAAIABiUAAAAIRkY4MDgwODADAAAAAAYmAAAAG1N0ZWVtYS5UZWVDaGFydC5TdHlsZXMuTGluZQHZ////+v///woAAAAAAAAAACUAAQAF2P///yRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMBAAAAB3ZhbHVlX18ACAIAAAAJAAAAAgAAAAAAAdf////6////CgAAAAAAAAAAJQABAAYqAAAAGyBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUAAJJgAAAAHU////+v///woAAAAAAAAAAI0AAQAB0////9j///8JAAAAAgAAAAAB0v////r///8KAAAAAAAAAACNAAEABi8AAAAkIG1pbGxldF9iaW9tX2tnaGEsIE1pbGxldCBQIHBhZGRvY2sxCSYAAAABz/////r///8KAAAAAAAAAABPAAEAAc7////Y////CQAAAAIAAAAAAc3////6////CgAAAAAAAAAATwABAAY0AAAAJCBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUCBwYWRkb2NrMgAJJgAAAAHK////+v///woAAAAAAAAAAH8AAQAByf///9j///8JAAAAAgAAAAAAAcj////6////CgAAAAAAAAAAfwABAAY5AAAAHCBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAACSYAAAABxf////r///8KAAAAAAAAAABrAAEAAcT////Y////CQAAAAIAAAAAAcP////6////CgAAAAAAAAAAawABAAY+AAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazEACSYAAAABwP////r///8KAAAAAAAAAAAwAAEAAb/////Y////CQAAAAIAAAAAAb7////6////CgAAAAAAAAAAMAABAAZDAAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazIJJgAAAAG7////+v///woAAAAAAAAAACcAAQABuv///9j///8JAAAAAgAAAAAFuf///yNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwEAAAAHdmFsdWVfXwAIAgAAAAEAAAABuP////r///8KAAAAAAAAAAAnAAEABkkAAAAYIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQCSYAAAABtf////r///8KAAAAAAAAAACMAAEAAbT////Y////CQAAAAIAAAAAAAGz////uf///wEAAAABsv////r///8KAAAAAAAAAACMAAEABk8AAAAhIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQIHBhZGRvY2sxAAkmAAAAAa/////6////CgAAAAAAAAAATgABAAGu////2P///wkAAAACAAAAAAABrf///7n///8BAAAAAaz////6////CgAAAAAAAAAATgABAAZVAAAAISBzdG9yZV9iaW9tX2tnLCBNaWxsZXQgUCBwYWRkb2NrMgABqv////r///8K/////wAAAAAAAAIABlcAAAAIRkZGRkZGRkYBqP////r///8KgICA/wAAAAAAAAIABlkAAAAIRkY4MDgwODABpv////r///8K/////wAAAAAAAAIABlsAAAAIRkZGRkZGRkYBpP////r///8KgICA/wAAAAAAAAIABl0AAAAIRkY4MDgwODABov////r///8K/////wAAAAAAAAIABl8AAAAIRkZGRkZGRkYBoP////r///8KgICA/wAAAAAAAAIABmEAAAAIRkY4MDgwODABnv////r///8K/////wAAAAAAAAIABmMAAAAIRkZGRkZGRkYBnP////r///8KgICA/wAAAAAAAAIABmUAAAAIRkY4MDgwODAAUAAAAAZmAAAACCMjIzAuIyMjCRUAAAAJAAAAAAAQQQGY////+v///wr/////AAAAAAAAAgAGaQAAAAhGRkZGRkZGRgGW////+v///wqAgID/AAAAAAAAAgAGawAAAAhGRjgwODA4MAEAAAAFlP///yBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAEAAAAHdmFsdWVfXwAIBAAAAAIAAAAACgAAAAABk/////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGR////+v///wrAAAD/AAAAAAAAAgABkP////r///8K/wAA/wAAAAAAAAIAAY/////6////Cv////8AAAAAAAACAAZyAAAACEZGRkZGRkZGAY3////6////CoCAgP8AAAAAAAACAAZ0AAAACEZGODA4MDgwUAAAAAlmAAAACRUAAAAJAAAAAAAQQQGJ////+v///wr/////AAAAAAAAAgAGeAAAAAhGRkZGRkZGRgGH////+v///wqAgID/AAAAAAAAAgAGegAAAAhGRjgwODA4MAEAAAABhf///5T///8CAAAAAAABhP////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGC////+v///wr/AAD/AAAAAAAAAgABgf////r///8K/////wAAAAAAAAIABoAAAAAIRkZGRkZGRkYBf/////r///8KgICA/wAAAAAAAAIABoIAAAAIRkY4MDgwODAAUAAAAAlmAAAACRUAAAAJAAAAAAAQQQF7////+v///wr/////AAAAAAAAAgAGhgAAAAhGRkZGRkZGRgF5////+v///wqAgID/AAAAAAAAAgAGiAAAAAhGRjgwODA4MAEAAAABd////5T///8CAAAAAAABdv////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQF0////+v///wr/AAD/AAAAAAAAAgABc/////r///8K/////wAAAAAAAAIABo4AAAAIRkZGRkZGRkYBcf////r///8KgICA/wAAAAAAAAIABpAAAAAIRkY4MDgwODBQAAAABpEAAAAJZC9NTS95eXl5CWYAAAAJFQAAAAkAAAAAABBBAWz////6////Cv////8AAAAAAAACAAaVAAAACEZGRkZGRkZGAWr////6////CoCAgP8AAAAAAAACAAaXAAAACEZGODA4MDgwAQAAAAFo////lP///wIAAAAACgAAAAoAAAAAAWf////6////CgAAAP8AAAAAAAACAAkVAAAACwAAAAAAMEEBZf////r///8K/wAA/wAAAAAAAAIAAWT////6////Cv////8AAAAAAAACAAadAAAACEZGRkZGRkZGAWL////6////CoCAgP8AAAAAAAACAAafAAAACEZGODA4MDgwAWD////6////Cv////8AAAAAAAACAAahAAAACEZGRkZGRkZGAV7////6////CoCAgP8AAAAAAAACAAajAAAACEZGODA4MDgwAVz////6////Cv////8AAAAAAAACAAalAAAACEZGRkZGRkZGAVr////6////CoCAgP8AAAAAAAACAAanAAAACEZGODA4MDgwAVj////6////Cv////8AAAAAAAACAAapAAAACEZGRkZGRkZGAVb////6////CoCAgP8AAAAAAAACAAarAAAACEZGODA4MDgwAVT////6////Cv////8AAAAAAAACAAatAAAACEZGRkZGRkZGAVL////6////CoCAgP8AAAAAAAACAAavAAAACEZGODA4MDgwERQAAAABAAAABrAAAAAACw==</Format>
        <Plot>
          <SeriesType>Bar</SeriesType>
          <PointType>None</PointType>
          <colour>
          </colour>
          <X>Date</X>
          <Y>grass_eaten</Y>
          <Y>bran_eaten</Y>
          <Y>maize_eaten</Y>
          <Y>magic_eaten</Y>
          <Y>mucuna_eaten</Y>
          <Y>sorghum_eaten</Y>
          <GDApsimFileReader name="ApsimFileReader" />
        </Plot>
        <Plot name="Plot1">
          <SeriesType>Bar</SeriesType>
          <PointType>None</PointType>
          <colour>
          </colour>
          <X>Date</X>
          <Y>sold_residue_millet</Y>
          <Y>sold_residue_cowpea</Y>
          <GDApsimFileReader name="ApsimFileReader" />
        </Plot>
      </Graph>
      <Graph name="Store">
        <Legend>
          <CheckedTitles> Groundnut_residue_store.store</CheckedTitles>
          <CheckedTitles> Maize_residue_store.store</CheckedTitles>
          <CheckedTitles> Mucuna_residue_store.store</CheckedTitles>
        </Legend>
        <Format>AAEAAAD/////AQAAAAAAAAAMAgAAAFhUZWVDaGFydC5DbGllbnQsIFZlcnNpb249NC4xLjIwMTEuNzI4MywgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj05YzgxMjYyNzZjNzdiZGI3DAMAAABXU3lzdGVtLldpbmRvd3MuRm9ybXMsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5DAQAAABRU3lzdGVtLkRyYXdpbmcsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iMDNmNWY3ZjExZDUwYTNhBQEAAAAVU3RlZW1hLlRlZUNoYXJ0LkNoYXJ0+AAAAA4uWm9vbS5BbmltYXRlZBMuWm9vbS5BbmltYXRlZFN0ZXBzFC5QYW5uaW5nLk1vdXNlQnV0dG9uEC5DdXN0b21DaGFydFJlY3QXLlBhbmVsLkltYWdlQmV2ZWwuV2lkdGgVLlBhbmVsLkJldmVsLkNvbG9yT25lGy5QYW5lbC5CZXZlbC5TdHJpbmdDb2xvck9uZRUuUGFuZWwuQmV2ZWwuQ29sb3JUd28bLlBhbmVsLkJldmVsLlN0cmluZ0NvbG9yVHdvEi5QYW5lbC5CZXZlbC5PdXRlchIuUGFuZWwuQnJ1c2guQ29sb3ISLkxlZ2VuZC5DaGVja0JveGVzEi5MZWdlbmQuTWF4TnVtUm93cxwuTGVnZW5kLlRpdGxlLkJldmVsLkNvbG9yT25lIi5MZWdlbmQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUcLkxlZ2VuZC5UaXRsZS5CZXZlbC5Db2xvclR3byIuTGVnZW5kLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvFi5MZWdlbmQuQmV2ZWwuQ29sb3JPbmUcLkxlZ2VuZC5CZXZlbC5TdHJpbmdDb2xvck9uZRYuTGVnZW5kLkJldmVsLkNvbG9yVHdvHC5MZWdlbmQuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkxlZ2VuZC5TaGFkb3cuVmlzaWJsZRMuTGVnZW5kLlRyYW5zcGFyZW50DS5IZWFkZXIuTGluZXMRLkhlYWRlci5Gb250Lk5hbWURLkhlYWRlci5Gb250LlNpemUWLkhlYWRlci5Gb250LlNpemVGbG9hdBYuSGVhZGVyLkJldmVsLkNvbG9yT25lHC5IZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUWLkhlYWRlci5CZXZlbC5Db2xvclR3bxwuSGVhZGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5TdWJIZWFkZXIuQmV2ZWwuQ29sb3JPbmUfLlN1YkhlYWRlci5CZXZlbC5TdHJpbmdDb2xvck9uZRkuU3ViSGVhZGVyLkJldmVsLkNvbG9yVHdvHy5TdWJIZWFkZXIuQmV2ZWwuU3RyaW5nQ29sb3JUd28WLkZvb3Rlci5CZXZlbC5Db2xvck9uZRwuRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yT25lFi5Gb290ZXIuQmV2ZWwuQ29sb3JUd28cLkZvb3Rlci5CZXZlbC5TdHJpbmdDb2xvclR3bxkuU3ViRm9vdGVyLkJldmVsLkNvbG9yT25lHy5TdWJGb290ZXIuQmV2ZWwuU3RyaW5nQ29sb3JPbmUZLlN1YkZvb3Rlci5CZXZlbC5Db2xvclR3bx8uU3ViRm9vdGVyLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5Bc3BlY3QuQ29sb3JQYWxldHRlSW5kZXgOLkFzcGVjdC5WaWV3M0QIU2VyaWVzLjAVLlNlcmllcy4wLkJydXNoLkNvbG9yFy5TZXJpZXMuMC5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMC5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMC5Db2xvckVhY2gRLlNlcmllcy4wLlZpc2libGUPLlNlcmllcy4wLkNvbG9yDy5TZXJpZXMuMC5UaXRsZRYuU2VyaWVzLjAuU2hvd0luTGVnZW5kCFNlcmllcy4xFS5TZXJpZXMuMS5CcnVzaC5Db2xvchcuU2VyaWVzLjEuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjEuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjEuQ29sb3JFYWNoDy5TZXJpZXMuMS5Db2xvcg8uU2VyaWVzLjEuVGl0bGUIU2VyaWVzLjIVLlNlcmllcy4yLkJydXNoLkNvbG9yFy5TZXJpZXMuMi5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuMi5MaW5lUGVuLldpZHRoEy5TZXJpZXMuMi5Db2xvckVhY2gPLlNlcmllcy4yLkNvbG9yDy5TZXJpZXMuMi5UaXRsZRYuU2VyaWVzLjIuU2hvd0luTGVnZW5kCFNlcmllcy4zFS5TZXJpZXMuMy5CcnVzaC5Db2xvchcuU2VyaWVzLjMuUG9pbnRlci5TdHlsZRcuU2VyaWVzLjMuTGluZVBlbi5XaWR0aBMuU2VyaWVzLjMuQ29sb3JFYWNoES5TZXJpZXMuMy5WaXNpYmxlDy5TZXJpZXMuMy5Db2xvcg8uU2VyaWVzLjMuVGl0bGUWLlNlcmllcy4zLlNob3dJbkxlZ2VuZAhTZXJpZXMuNBUuU2VyaWVzLjQuQnJ1c2guQ29sb3IXLlNlcmllcy40LlBvaW50ZXIuU3R5bGUXLlNlcmllcy40LkxpbmVQZW4uV2lkdGgTLlNlcmllcy40LkNvbG9yRWFjaA8uU2VyaWVzLjQuQ29sb3IPLlNlcmllcy40LlRpdGxlFi5TZXJpZXMuNC5TaG93SW5MZWdlbmQIU2VyaWVzLjUVLlNlcmllcy41LkJydXNoLkNvbG9yFy5TZXJpZXMuNS5Qb2ludGVyLlN0eWxlFy5TZXJpZXMuNS5MaW5lUGVuLldpZHRoEy5TZXJpZXMuNS5Db2xvckVhY2gPLlNlcmllcy41LkNvbG9yDy5TZXJpZXMuNS5UaXRsZQhTZXJpZXMuNhUuU2VyaWVzLjYuQnJ1c2guQ29sb3IXLlNlcmllcy42LlBvaW50ZXIuU3R5bGUXLlNlcmllcy42LkxpbmVQZW4uV2lkdGgTLlNlcmllcy42LkNvbG9yRWFjaBIuU2VyaWVzLjYuVmVydEF4aXMPLlNlcmllcy42LkNvbG9yDy5TZXJpZXMuNi5UaXRsZQhTZXJpZXMuNxUuU2VyaWVzLjcuQnJ1c2guQ29sb3IXLlNlcmllcy43LlBvaW50ZXIuU3R5bGUXLlNlcmllcy43LkxpbmVQZW4uV2lkdGgTLlNlcmllcy43LkNvbG9yRWFjaBEuU2VyaWVzLjcuVmlzaWJsZRIuU2VyaWVzLjcuVmVydEF4aXMPLlNlcmllcy43LkNvbG9yDy5TZXJpZXMuNy5UaXRsZRYuU2VyaWVzLjcuU2hvd0luTGVnZW5kCFNlcmllcy44FS5TZXJpZXMuOC5CcnVzaC5Db2xvchcuU2VyaWVzLjguUG9pbnRlci5TdHlsZRcuU2VyaWVzLjguTGluZVBlbi5XaWR0aBMuU2VyaWVzLjguQ29sb3JFYWNoES5TZXJpZXMuOC5WaXNpYmxlEi5TZXJpZXMuOC5WZXJ0QXhpcw8uU2VyaWVzLjguQ29sb3IPLlNlcmllcy44LlRpdGxlFi5TZXJpZXMuOC5TaG93SW5MZWdlbmQaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JPbmUgLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JPbmUaLldhbGxzLkxlZnQuQmV2ZWwuQ29sb3JUd28gLldhbGxzLkxlZnQuQmV2ZWwuU3RyaW5nQ29sb3JUd28bLldhbGxzLlJpZ2h0LkJldmVsLkNvbG9yT25lIS5XYWxscy5SaWdodC5CZXZlbC5TdHJpbmdDb2xvck9uZRsuV2FsbHMuUmlnaHQuQmV2ZWwuQ29sb3JUd28hLldhbGxzLlJpZ2h0LkJldmVsLlN0cmluZ0NvbG9yVHdvGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yT25lIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yT25lGi5XYWxscy5CYWNrLkJldmVsLkNvbG9yVHdvIC5XYWxscy5CYWNrLkJldmVsLlN0cmluZ0NvbG9yVHdvHC5XYWxscy5Cb3R0b20uQmV2ZWwuQ29sb3JPbmUiLldhbGxzLkJvdHRvbS5CZXZlbC5TdHJpbmdDb2xvck9uZRwuV2FsbHMuQm90dG9tLkJldmVsLkNvbG9yVHdvIi5XYWxscy5Cb3R0b20uQmV2ZWwuU3RyaW5nQ29sb3JUd28OLldhbGxzLlZpc2libGUcLkF4ZXMuTGVmdC5MYWJlbHMuU2VwYXJhdGlvbh0uQXhlcy5MZWZ0LkxhYmVscy5WYWx1ZUZvcm1hdBsuQXhlcy5MZWZ0LkxhYmVscy5Gb250Lk5hbWUbLkF4ZXMuTGVmdC5MYWJlbHMuRm9udC5TaXplIC5BeGVzLkxlZnQuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0IC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yT25lJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yT25lIC5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLkNvbG9yVHdvJi5BeGVzLkxlZnQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGC5BeGVzLkxlZnQuQXhpc1Blbi5XaWR0aBkuQXhlcy5MZWZ0LkF4aXNQZW4uRW5kQ2FwFy5BeGVzLkxlZnQuR3JpZC5WaXNpYmxlGC5BeGVzLkxlZnQuTWF4aW11bU9mZnNldB0uQXhlcy5MZWZ0Lk1pbm9yVGlja3MuVmlzaWJsZRYuQXhlcy5MZWZ0LlRpY2tzLkNvbG9yGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5OYW1lGi5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplHy5BeGVzLkxlZnQuVGl0bGUuRm9udC5TaXplRmxvYXQoLkF4ZXMuTGVmdC5UaXRsZS5Gb250LlNoYWRvdy5CcnVzaC5Db2xvciEuQXhlcy5MZWZ0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IfLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5Db2xvck9uZSUuQXhlcy5MZWZ0LlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHy5BeGVzLkxlZnQuVGl0bGUuQmV2ZWwuQ29sb3JUd28lLkF4ZXMuTGVmdC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bxsuQXhlcy5Ub3AuTGFiZWxzLlNlcGFyYXRpb24cLkF4ZXMuVG9wLkxhYmVscy5WYWx1ZUZvcm1hdBouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuTmFtZRouQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZR8uQXhlcy5Ub3AuTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Hy5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUlLkF4ZXMuVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZR8uQXhlcy5Ub3AuTGFiZWxzLkJldmVsLkNvbG9yVHdvJS5BeGVzLlRvcC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28XLkF4ZXMuVG9wLkF4aXNQZW4uV2lkdGgYLkF4ZXMuVG9wLkF4aXNQZW4uRW5kQ2FwFi5BeGVzLlRvcC5HcmlkLlZpc2libGUcLkF4ZXMuVG9wLk1pbm9yVGlja3MuVmlzaWJsZRUuQXhlcy5Ub3AuVGlja3MuQ29sb3IZLkF4ZXMuVG9wLlRpdGxlLkZvbnQuTmFtZRkuQXhlcy5Ub3AuVGl0bGUuRm9udC5TaXplHi5BeGVzLlRvcC5UaXRsZS5Gb250LlNpemVGbG9hdCAuQXhlcy5Ub3AuVGl0bGUuRm9udC5CcnVzaC5Db2xvch4uQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuQ29sb3JPbmUkLkF4ZXMuVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lHi5BeGVzLlRvcC5UaXRsZS5CZXZlbC5Db2xvclR3byQuQXhlcy5Ub3AuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28RLkF4ZXMuVG9wLlZpc2libGUdLkF4ZXMuUmlnaHQuTGFiZWxzLlNlcGFyYXRpb24eLkF4ZXMuUmlnaHQuTGFiZWxzLlZhbHVlRm9ybWF0HC5BeGVzLlJpZ2h0LkxhYmVscy5Gb250Lk5hbWUcLkF4ZXMuUmlnaHQuTGFiZWxzLkZvbnQuU2l6ZSEuQXhlcy5SaWdodC5MYWJlbHMuRm9udC5TaXplRmxvYXQhLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLkNvbG9yT25lJy5BeGVzLlJpZ2h0LkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSEuQXhlcy5SaWdodC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28nLkF4ZXMuUmlnaHQuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvGS5BeGVzLlJpZ2h0LkF4aXNQZW4uV2lkdGgaLkF4ZXMuUmlnaHQuQXhpc1Blbi5FbmRDYXAYLkF4ZXMuUmlnaHQuR3JpZC5WaXNpYmxlHi5BeGVzLlJpZ2h0Lk1pbm9yVGlja3MuVmlzaWJsZRcuQXhlcy5SaWdodC5UaWNrcy5Db2xvchsuQXhlcy5SaWdodC5UaXRsZS5Gb250Lk5hbWUbLkF4ZXMuUmlnaHQuVGl0bGUuRm9udC5TaXplIC5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLlJpZ2h0LlRpdGxlLkZvbnQuQnJ1c2guQ29sb3IgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JPbmUmLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JPbmUgLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuQ29sb3JUd28mLkF4ZXMuUmlnaHQuVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28eLkF4ZXMuQm90dG9tLkxhYmVscy5TZXBhcmF0aW9uIi5BeGVzLkJvdHRvbS5MYWJlbHMuRGF0ZVRpbWVGb3JtYXQfLkF4ZXMuQm90dG9tLkxhYmVscy5WYWx1ZUZvcm1hdB0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuTmFtZR0uQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkZvbnQuU2l6ZUZsb2F0Ii5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuQ29sb3JPbmUoLkF4ZXMuQm90dG9tLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSIuQXhlcy5Cb3R0b20uTGFiZWxzLkJldmVsLkNvbG9yVHdvKC5BeGVzLkJvdHRvbS5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JUd28aLkF4ZXMuQm90dG9tLkF4aXNQZW4uV2lkdGgbLkF4ZXMuQm90dG9tLkF4aXNQZW4uRW5kQ2FwGS5BeGVzLkJvdHRvbS5HcmlkLlZpc2libGUaLkF4ZXMuQm90dG9tLk1heGltdW1PZmZzZXQaLkF4ZXMuQm90dG9tLk1pbmltdW1PZmZzZXQfLkF4ZXMuQm90dG9tLk1pbm9yVGlja3MuVmlzaWJsZRguQXhlcy5Cb3R0b20uVGlja3MuQ29sb3IcLkF4ZXMuQm90dG9tLlRpdGxlLkZvbnQuTmFtZRwuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5TaXplIS5BeGVzLkJvdHRvbS5UaXRsZS5Gb250LlNpemVGbG9hdCMuQXhlcy5Cb3R0b20uVGl0bGUuRm9udC5CcnVzaC5Db2xvciEuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuQ29sb3JPbmUnLkF4ZXMuQm90dG9tLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIS5BeGVzLkJvdHRvbS5UaXRsZS5CZXZlbC5Db2xvclR3bycuQXhlcy5Cb3R0b20uVGl0bGUuQmV2ZWwuU3RyaW5nQ29sb3JUd28kLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLkNvbG9yT25lKi5BeGVzLkRlcHRoVG9wLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvck9uZSQuQXhlcy5EZXB0aFRvcC5MYWJlbHMuQmV2ZWwuQ29sb3JUd28qLkF4ZXMuRGVwdGhUb3AuTGFiZWxzLkJldmVsLlN0cmluZ0NvbG9yVHdvIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yT25lKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yT25lIy5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLkNvbG9yVHdvKS5BeGVzLkRlcHRoVG9wLlRpdGxlLkJldmVsLlN0cmluZ0NvbG9yVHdvIS5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5Db2xvck9uZScuQXhlcy5EZXB0aC5MYWJlbHMuQmV2ZWwuU3RyaW5nQ29sb3JPbmUhLkF4ZXMuRGVwdGguTGFiZWxzLkJldmVsLkNvbG9yVHdvJy5BeGVzLkRlcHRoLkxhYmVscy5CZXZlbC5TdHJpbmdDb2xvclR3byAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvck9uZSYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvck9uZSAuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5Db2xvclR3byYuQXhlcy5EZXB0aC5UaXRsZS5CZXZlbC5TdHJpbmdDb2xvclR3bwAABAAABAEEAQQEAAAEAQQBBAEEAQAABgEAAAQBBAEEAQQBBAEEAQQBBAEAAAEEBAAAAAQBAAEEBAAABAEBBAQAAAQBAAEEBAAAAAQBAAEEBAAABAEAAQQEAAAEAQEEBAAABAQBAQQEAAAABAQBAAEEBAAAAAQEAQAEAQQBBAEEAQQBBAEEAQQBAAABAQAABAEEAQAEAAAABAEAAAQEBAEEAQABAQAABAEEAQAEAAAEAQAABAQBBAEAAAEBAAAEAQQBAAQAAAQBAAAEBAEEAQABAQEAAAQBBAEABAAAAAAEAQAABAQBBAEEAQQBBAEEAQQBBAEEAQQBAQghU3lzdGVtLldpbmRvd3MuRm9ybXMuTW91c2VCdXR0b25zAwAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAjU3RlZW1hLlRlZUNoYXJ0LkRyYXdpbmcuQmV2ZWxTdHlsZXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEIFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEBCAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAJFN0ZWVtYS5UZWVDaGFydC5TdHlsZXMuUG9pbnRlclN0eWxlcwIAAAAIARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAABFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAACRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMCAAAACAEjU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5WZXJ0aWNhbEF4aXMCAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAkU3RlZW1hLlRlZUNoYXJ0LlN0eWxlcy5Qb2ludGVyU3R5bGVzAgAAAAgBASNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwIAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAEUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAsUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAIIFN5c3RlbS5EcmF3aW5nLkRyYXdpbmcyRC5MaW5lQ2FwBAAAAAEBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAAQgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABARRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgICxRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAACCBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAQAAAABCAgBFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAAAgLFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAUU3lzdGVtLkRyYXdpbmcuQ29sb3IEAAAAFFN5c3RlbS5EcmF3aW5nLkNvbG9yBAAAABRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAACAAAAAQQAAAAF+////yFTeXN0ZW0uV2luZG93cy5Gb3Jtcy5Nb3VzZUJ1dHRvbnMBAAAAB3ZhbHVlX18ACAMAAAAAAEAAAAEAAAAF+v///xRTeXN0ZW0uRHJhd2luZy5Db2xvcgQAAAAEbmFtZQV2YWx1ZQprbm93bkNvbG9yBXN0YXRlAQAAAAkHBwQAAAAK/////wAAAAAAAAIABgcAAAAIRkZGRkZGRkYB+P////r///8KgICA/wAAAAAAAAIABgkAAAAIRkY4MDgwODAF9v///yNTdGVlbWEuVGVlQ2hhcnQuRHJhd2luZy5CZXZlbFN0eWxlcwEAAAAHdmFsdWVfXwAIAgAAAAAAAAAB9f////r///8K/////wAAAAAAAAIAAQgAAAAB9P////r///8K/////wAAAAAAAAIABg0AAAAIRkZGRkZGRkYB8v////r///8KgICA/wAAAAAAAAIABg8AAAAIRkY4MDgwODAB8P////r///8K/////wAAAAAAAAIABhEAAAAIRkZGRkZGRkYB7v////r///8KgICA/wAAAAAAAAIABhMAAAAIRkY4MDgwODAAAQkUAAAABhUAAAAGVGFob21hDAAAAAAAQEEB6v////r///8K/////wAAAAAAAAIABhcAAAAIRkZGRkZGRkYB6P////r///8KgICA/wAAAAAAAAIABhkAAAAIRkY4MDgwODAB5v////r///8K/////wAAAAAAAAIABhsAAAAIRkZGRkZGRkYB5P////r///8KgICA/wAAAAAAAAIABh0AAAAIRkY4MDgwODAB4v////r///8K/////wAAAAAAAAIABh8AAAAIRkZGRkZGRkYB4P////r///8KgICA/wAAAAAAAAIABiEAAAAIRkY4MDgwODAB3v////r///8K/////wAAAAAAAAIABiMAAAAIRkZGRkZGRkYB3P////r///8KgICA/wAAAAAAAAIABiUAAAAIRkY4MDgwODADAAAAAAYmAAAAG1N0ZWVtYS5UZWVDaGFydC5TdHlsZXMuTGluZQHZ////+v///woAAAAAAAAAACUAAQAF2P///yRTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlBvaW50ZXJTdHlsZXMBAAAAB3ZhbHVlX18ACAIAAAAJAAAAAgAAAAAAAdf////6////CgAAAAAAAAAAJQABAAYqAAAAGyBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUAAJJgAAAAHU////+v///woAAAAAAAAAAI0AAQAB0////9j///8JAAAAAgAAAAAB0v////r///8KAAAAAAAAAACNAAEABi8AAAAkIG1pbGxldF9iaW9tX2tnaGEsIE1pbGxldCBQIHBhZGRvY2sxCSYAAAABz/////r///8KAAAAAAAAAABPAAEAAc7////Y////CQAAAAIAAAAAAc3////6////CgAAAAAAAAAATwABAAY0AAAAJCBtaWxsZXRfYmlvbV9rZ2hhLCBNaWxsZXQgUCBwYWRkb2NrMgAJJgAAAAHK////+v///woAAAAAAAAAAH8AAQAByf///9j///8JAAAAAgAAAAAAAcj////6////CgAAAAAAAAAAfwABAAY5AAAAHCBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAACSYAAAABxf////r///8KAAAAAAAAAABrAAEAAcT////Y////CQAAAAIAAAAAAcP////6////CgAAAAAAAAAAawABAAY+AAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazEACSYAAAABwP////r///8KAAAAAAAAAAAwAAEAAb/////Y////CQAAAAIAAAAAAb7////6////CgAAAAAAAAAAMAABAAZDAAAAJSBwYXN0dXJlX2Jpb21fa2doYSwgTWlsbGV0IFAgcGFkZG9jazIJJgAAAAG7////+v///woAAAAAAAAAACcAAQABuv///9j///8JAAAAAgAAAAAFuf///yNTdGVlbWEuVGVlQ2hhcnQuU3R5bGVzLlZlcnRpY2FsQXhpcwEAAAAHdmFsdWVfXwAIAgAAAAEAAAABuP////r///8KAAAAAAAAAAAnAAEABkkAAAAYIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQCSYAAAABtf////r///8KAAAAAAAAAACMAAEAAbT////Y////CQAAAAIAAAAAAAGz////uf///wEAAAABsv////r///8KAAAAAAAAAACMAAEABk8AAAAhIHN0b3JlX2Jpb21fa2csIE1pbGxldCBQIHBhZGRvY2sxAAkmAAAAAa/////6////CgAAAAAAAAAATgABAAGu////2P///wkAAAACAAAAAAABrf///7n///8BAAAAAaz////6////CgAAAAAAAAAATgABAAZVAAAAISBzdG9yZV9iaW9tX2tnLCBNaWxsZXQgUCBwYWRkb2NrMgABqv////r///8K/////wAAAAAAAAIABlcAAAAIRkZGRkZGRkYBqP////r///8KgICA/wAAAAAAAAIABlkAAAAIRkY4MDgwODABpv////r///8K/////wAAAAAAAAIABlsAAAAIRkZGRkZGRkYBpP////r///8KgICA/wAAAAAAAAIABl0AAAAIRkY4MDgwODABov////r///8K/////wAAAAAAAAIABl8AAAAIRkZGRkZGRkYBoP////r///8KgICA/wAAAAAAAAIABmEAAAAIRkY4MDgwODABnv////r///8K/////wAAAAAAAAIABmMAAAAIRkZGRkZGRkYBnP////r///8KgICA/wAAAAAAAAIABmUAAAAIRkY4MDgwODAAUAAAAAZmAAAACCMjIzAuIyMjCRUAAAAJAAAAAAAQQQGY////+v///wr/////AAAAAAAAAgAGaQAAAAhGRkZGRkZGRgGW////+v///wqAgID/AAAAAAAAAgAGawAAAAhGRjgwODA4MAEAAAAFlP///yBTeXN0ZW0uRHJhd2luZy5EcmF3aW5nMkQuTGluZUNhcAEAAAAHdmFsdWVfXwAIBAAAAAIAAAAACgAAAAABk/////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGR////+v///wrAAAD/AAAAAAAAAgABkP////r///8K/wAA/wAAAAAAAAIAAY/////6////Cv////8AAAAAAAACAAZyAAAACEZGRkZGRkZGAY3////6////CoCAgP8AAAAAAAACAAZ0AAAACEZGODA4MDgwUAAAAAlmAAAACRUAAAAJAAAAAAAQQQGJ////+v///wr/////AAAAAAAAAgAGeAAAAAhGRkZGRkZGRgGH////+v///wqAgID/AAAAAAAAAgAGegAAAAhGRjgwODA4MAEAAAABhf///5T///8CAAAAAAABhP////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQGC////+v///wr/AAD/AAAAAAAAAgABgf////r///8K/////wAAAAAAAAIABoAAAAAIRkZGRkZGRkYBf/////r///8KgICA/wAAAAAAAAIABoIAAAAIRkY4MDgwODAAUAAAAAlmAAAACRUAAAAJAAAAAAAQQQF7////+v///wr/////AAAAAAAAAgAGhgAAAAhGRkZGRkZGRgF5////+v///wqAgID/AAAAAAAAAgAGiAAAAAhGRjgwODA4MAEAAAABd////5T///8CAAAAAAABdv////r///8KAAAA/wAAAAAAAAIACRUAAAALAAAAAAAwQQF0////+v///wr/AAD/AAAAAAAAAgABc/////r///8K/////wAAAAAAAAIABo4AAAAIRkZGRkZGRkYBcf////r///8KgICA/wAAAAAAAAIABpAAAAAIRkY4MDgwODBQAAAABpEAAAAJZC9NTS95eXl5CWYAAAAJFQAAAAkAAAAAABBBAWz////6////Cv////8AAAAAAAACAAaVAAAACEZGRkZGRkZGAWr////6////CoCAgP8AAAAAAAACAAaXAAAACEZGODA4MDgwAQAAAAFo////lP///wIAAAAACgAAAAoAAAAAAWf////6////CgAAAP8AAAAAAAACAAkVAAAACwAAAAAAMEEBZf////r///8K/wAA/wAAAAAAAAIAAWT////6////Cv////8AAAAAAAACAAadAAAACEZGRkZGRkZGAWL////6////CoCAgP8AAAAAAAACAAafAAAACEZGODA4MDgwAWD////6////Cv////8AAAAAAAACAAahAAAACEZGRkZGRkZGAV7////6////CoCAgP8AAAAAAAACAAajAAAACEZGODA4MDgwAVz////6////Cv////8AAAAAAAACAAalAAAACEZGRkZGRkZGAVr////6////CoCAgP8AAAAAAAACAAanAAAACEZGODA4MDgwAVj////6////Cv////8AAAAAAAACAAapAAAACEZGRkZGRkZGAVb////6////CoCAgP8AAAAAAAACAAarAAAACEZGODA4MDgwAVT////6////Cv////8AAAAAAAACAAatAAAACEZGRkZGRkZGAVL////6////CoCAgP8AAAAAAAACAAavAAAACEZGODA4MDgwERQAAAABAAAABrAAAAAACw==</Format>
        <Plot>
          <SeriesType>Solid line</SeriesType>
          <PointType>None</PointType>
          <colour>
          </colour>
          <X>Date</X>
          <Y>Groundnut_residue_store.store</Y>
          <Y>Maize_residue_store.store</Y>
          <Y>Mucuna_residue_store.store</Y>
          <GDApsimFileReader name="ApsimFileReader" />
        </Plot>
      </Graph>
    </outputfile>
    <RGraphics name="Goat Growth Curves">
      <script>
        <text>library(ggplot2)

default&lt;-  theme(
       axis.line = element_line(colour = "black"),
       panel.grid.major = element_blank(),
       panel.grid.minor = element_blank(),
       panel.border = element_blank(),
       panel.background = element_blank() )

d&lt;-read.csv("Mavona individual Goats.csv")
d$date&lt;-as.Date(d$date)
for (id in unique(d$id)) {
  d$age[d$id==id] &lt;- (d$date[d$id==id] - min(d$date[d$id==id])) / 365.25
}

#breeders &lt;- unique(d$id[d$age &gt; 2.5])
#d&lt;- d[!d$id %in% breeders,]

#Ignore the first 6 (initial) goats
#d&lt;- d[!d$id %in% 0:4,]

jpeg(imageFileName, width=width, height=height)
g&lt;-ggplot(data=d,aes(x=age,y=Weight,group=id)) + geom_line() + default
print(g)
dev.off()

</text>
      </script>
    </RGraphics>
    <RGraphics name="Cow Growth Curves">
      <script>
        <text>library(ggplot2)

default&lt;-  theme(
       axis.line = element_line(colour = "black"),
       panel.grid.major = element_blank(),
       panel.grid.minor = element_blank(),
       panel.border = element_blank(),
       panel.background = element_blank() )

d&lt;-read.csv("Mavona individual Cows.csv")
d$date&lt;-as.Date(d$date)
for (id in unique(d$id)) {
  d$age[d$id==id] &lt;- (d$date[d$id==id] - min(d$date[d$id==id])) / 365.25
}

#Ignore the first 1 (initial) cow
#d&lt;- d[!d$id %in% 0:1,]


jpeg(imageFileName, width=width, height=height)
g&lt;-ggplot(data=d,aes(x=age,y=Weight,group=id)) + geom_line() + default
print(g)
dev.off()

</text>
      </script>
    </RGraphics>
  </simulation>
</folder>