     ###     ######     #####   #   #     #   
    #   #    #     #   #        #   ##   ##   
   #     #   #     #   #        #   ##   ##   
   #######   ######     #####   #   # # # #   
   #     #   #              #   #   #  #  #   
   #     #   #         #####    #   #  #  #   
                                              
                                              
 The Agricultural Production Systems Simulator
             Copyright(c) APSRU               

Version                = 7.4
Title                  = CQ Mixed GG
   Component                        "clock" = %apsim%\Model\Clock.dll
   Component                          "met" = %apsim%\Model\Input.dll
   Component                 "Farm Manager" = %apsim%\Model\TclLink.dll
   Component                    "Machinery" = %apsim%\Model\TclLink.dll
   Component                    "Economics" = %apsim%\Model\TclLink.dll
   Component                         "mob1" = %apsim%\Model\Graz.dll
   Component                         "mob2" = %apsim%\Model\Graz.dll
   Component                         "mob3" = %apsim%\Model\Graz.dll
   Component                         "mob4" = %apsim%\Model\Graz.dll
   Component                         "mob5" = %apsim%\Model\Graz.dll
   Component                         "mob6" = %apsim%\Model\Graz.dll
   Component                         "mob7" = %apsim%\Model\Graz.dll
   Component                         "mob8" = %apsim%\Model\Graz.dll
   Component                         "mob9" = %apsim%\Model\Graz.dll
   Component                        "mob10" = %apsim%\Model\Graz.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component              "Grasp Managment" = %apsim%\Model\Manager.dll
   Component                   "soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                       "Buffel" = %apsim%\Model\Grasp.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component             "Oats Sowing rule" = %apsim%\Model\Manager.dll
   Component            "Sowing fertiliser" = %apsim%\Model\Manager.dll
   Component                      "endcrop" = %apsim%\Model\Manager.dll
   Component                   "soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                         "oats" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component              "Grasp Managment" = %apsim%\Model\Manager.dll
   Component                   "soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                     "leucaena" = %apsim%\Model\Grasp.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component    "Sow using a variable rule" = %apsim%\Model\Manager.dll
   Component            "Sowing fertiliser" = %apsim%\Model\Manager.dll
   Component                      "endcrop" = %apsim%\Model\Manager.dll
   Component                   "soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                 "SweetSorghum" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                           "Cl" = %apsim%\Model\Solute.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                           "Cl" = %apsim%\Model\Solute.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                           "Cl" = %apsim%\Model\Solute.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                           "Cl" = %apsim%\Model\Solute.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "Erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                           "Cl" = %apsim%\Model\Solute.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                      "tracker" = %apsim%\Model\Tracker.dll

------- clock Initialisation --------------------------------------------------
     Sequencer phases:
        prepare
        init_step
        do_pasture_water
        process
        do_pasture_growth
        do_stock
        post
        end_step
     Simulation start date =  1/01/1980
     Simulation end date   = 31/12/1983
     Time step =           = 1440 (mins)

------- met Initialisation ----------------------------------------------------
     Sparse data is not allowed
     INPUT File name: %apsim%\Examples\MetFiles\Goond.met
Farm Manager: 
     Copyright (C) 1991-1994 The Regents of the University of California.
     Copyright (C) 1996-1997 Sun Microsystems, Inc.
     Copyright (C) 2001      ActiveState.
     --->Section: end_simulation

          
closeLogging

closeAnimals

set fp [open $simName.event.csv w]

puts -nonewline $fp "event,paddock,year,date,days since last event,crop,"
puts -nonewline $fp "yield (kg/ha dry),biomass (kg/ha dry),protein(%),Ep (mm),"
puts -nonewline $fp "esw (mm rel ll15),no3 (kg/ha),"
puts -nonewline $fp "incroprain,fallowrain,"
puts -nonewline $fp "soil evap (mm),runoff (mm),drainage (mm),soil loss (t/ha),surface OM (kg),cover (%),n_mineralisation"
puts -nonewline $fp "\n"

foreach line $event(lines) {
  puts $fp $line
}

close $fp

set fp [open $simName.economics.csv w]

puts -nonewline $fp "event,paddock,area,year,date,days since last event,crop,"
puts -nonewline $fp "yield (kg/ha dry),biomass (kg/ha dry),protein(%),type,amount,weight"
puts -nonewline $fp "\n"

foreach line $event(econLines) {
  puts $fp $line
}

close $fp
   
close_annual_stuff


     --->Section: end_year

do_end_year
     --->Section: init

set simName "CQ Mixed GG"

############ Structural - what's here and what it's connected to:
set config(paddocks)  [list "BuffelPaddock" \
                            "LeucaenaGrassPaddock" \
                            "OatsPaddock" \
                            "SorghumPaddock"  \
                            "CropPaddock1" \
                            "CropPaddock2" \
                            "CropPaddock3" \
                            "CropPaddock4" \
                            "CropPaddock5" ]
                                   


set config(cropPaddocks)    [list "CropPaddock1" \
                            "CropPaddock2" \
                            "CropPaddock3" \
                            "CropPaddock4" \
                            "CropPaddock5" ]

set config(Chickpea,alias)     "chickpea"
set config(Wheat,alias)        "wheat"
set config(Sorghum,alias)      "sorghum"

set config(crops) [list chickpea wheat ]

##########Initial states
set config(CropPaddock1,initialState)  Fallow
set config(CropPaddock2,initialState)  Fallow_1
set config(CropPaddock3,initialState)  Fallow_2
set config(CropPaddock4,initialState)  Fallow_3
set config(CropPaddock5,initialState)  Fallow_4

foreach paddock $config(cropPaddocks) {
   set config($paddock,area)          200.0
   set config($paddock,graphNames)    GrainCrops
   set config($paddock,history)       {}
   set config($paddock,daysSinceLastHarvest) 365
}


set config(foragePaddocks)  [list "OatsPaddock" "SorghumPaddock" ]
set config(pasturePaddocks) [list "BuffelPaddock" "LeucaenaGrassPaddock" ]

set config(BuffelPaddock,area)         2000.0                         ;# 2000ha of buffel at CQ Mixed GG
set config(LeucaenaGrassPaddock,area)  600.0                          ;# area of Leucaena-Grass at CQ Mixed GG

# These paddocks are "managed" by in-paddock management rules
set config(OatsPaddock,graphNames)           {} ;# ForageOats 
set config(SorghumPaddock,graphNames)        {} ;# ForageSorghum


set config(BuffelPaddock,graphNames)         {} ;# buffel
set config(LeucaenaGrassPaddock,graphNames)  {} ;# Leucaena


# Some dummy initial values
foreach paddock [concat $config(foragePaddocks) $config(pasturePaddocks)] {
  set config($paddock,initialState)  {}
  set config($paddock,history)   {}
  set config($paddock,daysSinceLastHarvest) 365
}


############ Forage and pasture initialisation data
#  Maximum number of animals allowed in each paddock
set config(BuffelPaddock,numAnimals)         1000
set config(LeucaenaGrassPaddock,numAnimals)  200
set config(OatsPaddock,numAnimals)           300
set config(SorghumPaddock,numAnimals)        100

set config(OatsPaddock,area)           300.0                          ;# Area of Oats paddock at CQ Mixed GG
set config(SorghumPaddock,area)        100.0                          ;# Area of Forage sorghum paddock at CQ Mixed GG - 250ha

# Potential growth rates for each pasture type by season
set config(buffel,summer_lwg)  80
set config(buffel,autumn_lwg)  40
set config(buffel,winter_lwg)  10
set config(buffel,spring_lwg)  40

set config(SweetSorghum,summer_lwg)  100
set config(SweetSorghum,autumn_lwg)  60
set config(SweetSorghum,winter_lwg)  10
set config(SweetSorghum,spring_lwg)  60

set config(oats,summer_lwg)  40
set config(oats,autumn_lwg)  60
set config(oats,winter_lwg)  80
set config(oats,spring_lwg)  60

set config(leucaena,summer_lwg)  85
set config(leucaena,autumn_lwg)  85
set config(leucaena,winter_lwg)  30
set config(leucaena,spring_lwg)  30


# Defaults for a lot of things.
# we use this table to build a list of "name/value" pairs that get fed into
# sow/fertiliser commands etc.
# ***Check the summary file for what it uses, search other files for "gatherArgs"
   set defaults(sow,sowing_depth)              30
   set defaults(fertiliser,calcMethod)         targetN
   set defaults(fertiliser,depth)              50
   set defaults(fertiliser,type)               no3_n

   set defaults(wheat,sow,cultivar)            hartog
   set defaults(wheat,sow,plants)              100       ;# plants per sq mt established
   set defaults(wheat,fertiliser,amount)       75        ;# kg n/ha

   set defaults(chickpea,sow,cultivar)         amethyst
   set defaults(chickpea,sow,plants)           30
   set defaults(chickpea,fertiliser,amount)    0

   set defaults(sow,tractor)                   'tractor1'
   set defaults(sow,implement)                 'planter'
   set defaults(spray,tractor)                 'tractor1'
   set defaults(spray,implement)               'sprayrig'  ;# this is spray rig
   set defaults(herbicide,spray,name)          "Roundup"


####################
########### Support procedures

proc max {a b} { return [expr {($a > $b) ? $a : $b}] }
proc min {a b} { return [expr {($a > $b) ? $b : $a}] }

# Return the current state of the system
proc currentState {paddock} {
   global state
   return $state($paddock)
}

# Gather arguments (eg sowing depth, fert rate etc} from defaults array
# $action: the operation (sow, fert ...
# $what: the module (wheat, sorghum ...
proc gatherArgs {action what} {
   global defaults config

   # 1. "sow,..."
   foreach {index value} [array get defaults $action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 2. override above with any "wheat,sow,..."
   foreach {index value} [array get defaults $what,$action,*] {
      set args([lindex [split $index ","] end]) $value
   }
   # 3. override above with any "SpringWheat,sow,..."
   if {[info exists config($what,alias)]} {
      foreach {index value} [array get defaults $config($what,alias),$action,*] {
         set args([lindex [split $index ","] end]) $value
      }
   }
   return [array get args]
}

# Mash a list into name/value pairs to pass via the apsim message system
proc mash {list} {
   set result {}
   foreach {name value} $list {lappend result [list $name $value]}
   return $result
}

# Sum a list
proc lsum {list} {
   set result 0.0
   foreach value $list {set result [expr $result + $value]}
   return $result
}

# Linear interpolation
proc linint {x_coords y_coords value} {
   set y  0.0

   if {[llength $x_coords] <= 0 || [llength $y_coords] <= 0 || [llength $x_coords] != [llength $y_coords]} {
      error "bad coordinates in linear_interp_real"
   }

   for {set indx 0} {$indx < [llength $x_coords]} {incr indx} {
      if {$value <= [lindex $x_coords $indx]} {
         if {$indx == 0} {
            set y [lindex $y_coords $indx]
         } else {
            if {abs($value - [lindex $x_coords $indx]) < 1.0E-4} {
               set y [lindex $y_coords $indx]
            } else  {
               set y_part [expr [lindex $y_coords $indx] - [lindex $y_coords [expr $indx-1]] ]
               set x_part [expr [lindex $x_coords $indx] - [lindex $x_coords [expr $indx-1]] ]
               set y [expr ($y_part/$x_part) * ($value - [lindex $x_coords [expr $indx - 1]]) + [lindex $y_coords [expr $indx- 1]] ]
            }
         break;
         }
      } elseif {$indx == [lindex $x_coords $indx]-1} {
         set y  [lindex $y_coords $indx]
      } else {
         set y  0.0
      }
   }
   return $y
}
###############Utilities
proc dateWithin {t0 t1} {
   set d0 [date2day $t0]
   set d1 [date2day $t1]
   return [dayWithin $d0 $d1]
}

proc dateIs {t} {
   set d [date2day $t]
   return [dayIs $d]
}

proc dayWithin {t0 t1} {
   set t [apsimGet day]
   if {$t0 > $t1} {
      return [expr $t >= $t0 || $t <= $t1]
   } else {
      return [expr $t >= $t0 && $t <= $t1]
   }
   # notreached
}

proc dayIs {t} {
   return [expr $t == [apsimGet day]]
}

proc date2day {d} {
   set year [apsimGet year]
   return [string trimleft [clock format [clock scan "$d-$year"] -format %j] "0"]
}

# Return the fraction planted under a crop
proc areaPlanted {what} {
   global config
   set sum 0; set n 0
   foreach paddock $config(cropPaddocks) {
      set state [currentState $paddock]
      if {[info exists config($state,alias)]} {set state $config($state,alias)}
      if {"$state" == "$what"} {
        incr sum
      }
      incr n
   }
   return [expr $sum/$n.0 ]
}

proc machineryAvailable {what} {
   return [apsimGet available_$what]
}

#############################
############### The decision routine(s).
#############################
# Return the score for planting "what"
proc checkRules {thisPaddock} {
  global config

  uplevel #0 set paddock \"$thisPaddock\"
  set bestScore -1.0; set bestTarget {}; set bestArc {}; set bestGraph {}
  foreach graph $config($thisPaddock,graphNames) {
     foreach arc [$graph arcs -out [currentState $thisPaddock]] {
        set expr {}
        set target [$graph arc target $arc]
        foreach rule [$graph arc get $arc rules] {
           set value [uplevel #0 expr $rule]
           lappend expr $value
           if {$value == 0} {break} ;# no need to continue evaluating subsequent rules
        }
        if {[llength $expr] > 0} {
           set score [expr [join $expr "*"]]
           if {$score > $bestScore} {
              set bestScore  $score
              set bestTarget $target
              set bestArc    $arc
              set bestGraph  $graph
           }
        }
     }
  }   
  return [list  $bestScore $bestGraph $bestTarget $bestArc]
}

# A place holder function to monitor state transitions
proc logState {graph paddock state} {}

# Change state to another
proc changeState {paddock graph arc} {
   global state
   uplevel #0 set paddock \"$paddock\"
   foreach action [$graph arc get $arc actions] { uplevel #0 $action }
   set state($paddock) [$graph arc target $arc]
   logState $graph $paddock $state($paddock)
}

# Do daily process at top level
proc doProcess {} {
   global date config daysSinceLastHarvest
   
   set date "[apsimGet day],[apsimGet year]"

   set more 1
   while {$more} {
      set more 0
      # 1. Find out what's possible
      set bestPaddock {}; set bestScore -1.0
      foreach paddock $config(paddocks) {
         foreach {score graph target arc} [checkRules $paddock] {break}
         if {$score > $bestScore} {
            set bestPaddock $paddock; set bestScore $score; set bestGraph $graph; set bestTarget $target; set bestArc $arc
         }
      }
      if {$bestScore > 0.0} {
         changeState $bestPaddock $bestGraph $bestArc
         set more 1
      }
   }
   
   foreach paddock $config(paddocks) {
      incr daysSinceLastHarvest($paddock)
   }   
}

# pass events to various output files
proc reportEvent {from what} {
   foreach {event args} [split $what "-"] {break}
}


# The rainfall accumulator - set this list to 
#   the 10 days of rain prior to start of simulation
set rainList {0.2 1.0 0 0 0 0 15 12 0 0 0 0}

# Return the sum of the last n days rainfall
proc sumLastRain {n} {
   global rainList
   return  [expr [join [lrange $rainList end-[expr $n-1] end] "+"]]
}

# Maintain a list of rainfall amounts.
proc accumRain {} {
   global rainList
   set rainList [concat [lrange $rainList 1 end] [apsimGet rain]]
}


# Rug plotting facility

# 2 areas of interest:
# - logState - called when a graph is changing state, called just after the "actions" have been evaluated

# a logfile is used to generate the rugplots of farm activities. There are 2 parts:
# an xml of paddocks, states & times,
# a binary of decision rules on each evaluation cycle
proc log {msg} {
   #puts $msg
}

package require cdftcl
package require tdom

proc setupLogging {} {
   global simName config 

   # Find the number of graphs - 1 file for each. Delete each.
   set config(graphs) {}
   foreach paddock $config(paddocks) {
     foreach graph $config($paddock,graphNames) {
        if {[lsearch $config(graphs) $graph] < 0} {
           lappend config(graphs) $graph
        }
     }
  }
  foreach graph $config(graphs) {
    apsimWriteToSummaryFile "deleting $simName.$graph.\[xml,nc\]"
    file delete -force $simName.$graph.xml
    file delete -force $simName.$graph.nc
    foreach paddock $config(paddocks) {
       set config(history,$paddock,$graph) {}
    }
  }
  set config(states) {}
  set config(rules) {}
  set config(historyDays) {}
}

# Log a set of rule evaluations
proc logRules {paddock graph rules values } {
   global config history

   set data {}
   for {set i 0} {$i < [llength $rules]} {incr i} {
      lappend data [lindex $rules $i] [lindex $values $i]
   }

   set today [apsimGet today]

   lappend history($paddock,$graph,$today) $data

   if {[lsearch $config(historyDays) $today] < 0} {
       lappend config(historyDays) $today
       set config($today,ddmmyyyy) [apsimGet clock.dd/mm/yyyy]
   }
}

# Log a state transition
proc logState {graph paddock state} {
   global config
   set today [apsimGet today]
   lappend config(history,$paddock,$graph) $today $state
   if {[lsearch $config(states) $state] < 0} {lappend config(states) $state}
}

# Write the files. 
proc closeLogging {} {
   global config history simName

   set config(xmldoc) [dom parse [apsimGetComponentXML]]
   set config(docroot) [$config(xmldoc) documentElement]

   foreach graph $config(graphs) {
      set ncfp [ncdf create $simName.$graph.nc] 
      ncdfdim $ncfp create index [llength $config(historyDays)]
      ncdfdim $ncfp create time -1

      ncdfvar $ncfp create position long {index}
      ncdfvar $ncfp create daynum float {index}

      ncdfvar $ncfp create day     float {time}
      ncdfvar $ncfp create paddock short {time}
      ncdfvar $ncfp create rule    short {time}
      ncdfvar $ncfp create value   float {time}

      set day [lindex $config(historyDays) 0]
      ncdfatt $ncfp GLOBAL put startdate float $day
      ncdfatt $ncfp GLOBAL put startddmmyyyy char $config($day,ddmmyyyy)

      set day [lindex $config(historyDays) end]
      ncdfatt $ncfp GLOBAL put enddate float $day
      ncdfatt $ncfp GLOBAL put endddmmyyyy char $config($day,ddmmyyyy)

      ncdf enddef $ncfp
      set id 0
      foreach p $config(paddocks) {
         set pid($p) $id; incr id
      }   
	    catch {unset pos}
      set i 0
      foreach day $config(historyDays) {
         foreach paddock $config(paddocks) {
            if {[info exists history($paddock,$graph,$day)]} {
               set pos($paddock,$day) $i
               foreach data $history($paddock,$graph,$day) {
                  foreach {rule value} $data {
                     ncdfvar $ncfp put day     $i $day
                     ncdfvar $ncfp put paddock $i $pid($paddock)
                     ncdfvar $ncfp put rule    $i $rule
                     ncdfvar $ncfp put value   $i $value
                     incr i
                  } 
               }
            }
         }
      }

	    #Positions
      for {set i 0} {$i < [llength $config(historyDays)]} {incr i} {
         set day [lindex $config(historyDays) $i]
         set f 0
         foreach paddock $config(paddocks) {
            if {[info exists pos($paddock,$day)]} {
               ncdfvar $ncfp put position  $i $pos($paddock,$day)
               set f 1
               break
            } 
         }
         if {!$f} {
            ncdfvar $ncfp put position  $i -1
         }   
      }
      
      for {set j 0} {$j < [llength $config(historyDays)]} {incr j} {
         ncdfvar $ncfp put daynum $j [lindex $config(historyDays) $j]
      }   

      ncdf close $ncfp

      set fp [open $simName.$graph.xml w]
      puts $fp "<?xml version=\"1.0\" encoding=\"UTF-8\"?><simulation>"
      set id 0
      foreach paddock $config(paddocks) {
         puts $fp "<history id=\"$id\" name=\"$paddock\">"
         foreach {day state} $config(history,$paddock,$graph) {
            if {[info exists pos($paddock,$day)]} {
               puts $fp "<transition day=\"$day\" to=\"$state\" position=\"$pos($paddock,$day)\" />"
            } 
         }
         puts $fp "</history>"
         incr id
      }

      foreach paddock $config(paddocks) {
         puts $fp "<paddock id=\"$pid($paddock)\" name=\"$paddock\" />"
      }   
      set id 0
      foreach rule $config(rules) {
         set rule [string map {\< "&lt;"  \> "&gt;"     
                               \& "&amp;" \" "&quot;"  
                               \[ "&#91;" \] "&#93;"    } $rule]
         puts $fp "<rule id=\"$id\" name=\"$rule\" />"
         incr id
      }

      # Colours
      foreach node [$config(docroot) selectNodes //node] {
          set state [getValue $node "name"]
          set colour [getValue $node "fill"]
          puts $fp "<state name=\"$state\" colour=\"$colour\" />"
      }

      set day [lindex $config(historyDays) 0]
      puts $fp "<startdate ddmmyyyy=\"$config($day,ddmmyyyy)\" day=\"$day\" />"
      set day [lindex $config(historyDays) end]
      puts $fp "<enddate ddmmyyyy=\"$config($day,ddmmyyyy)\" day=\"$day\" />"

      puts $fp "</simulation>"
      close $fp
   }  
   # $config(xmldoc) delete
}

# Override the "standard" decision routine to keep track of state info
proc checkRules {thisPaddock} {
  global config 
  uplevel #0 set paddock $thisPaddock
  set bestScore -1.0; set bestTarget {}; set bestArc {}; set bestGraph {}
  foreach graph $config($thisPaddock,graphNames) {
     foreach arc [$graph arcs -out [currentState $thisPaddock]] {
        set values {}; set rules {}
        set target [$graph arc target $arc]
        if {[$graph arc keyexists $arc window]} {set inWindow [uplevel #0 expr [$graph arc get $arc window]]} else {set inWindow 0}
        foreach rule [$graph arc get $arc rules] {
           set value [uplevel #0 expr $rule]
           lappend values $value
           lappend rules [enCodeRule $target $rule]
        }
        logRules $thisPaddock $graph $rules $values
        if {[llength $values] > 0} {
           set score [expr [join $values "*"]]
           if {$score > $bestScore} {
              set bestScore  $score
              set bestTarget $target
              set bestArc    $arc
              set bestGraph  $graph
           }
        }
     }
  }   
  return [list  $bestScore $bestGraph $bestTarget $bestArc]
}

proc enCodeRule {target ruleText} {
  global config
  regsub -all "\," $ruleText "\-" ruleText

  for {set i 0} {$i < [llength $config(rules)]} {incr i} {
     set rule [lindex $config(rules) $i]
     if {[string equal $rule "$target,$ruleText"]} {
        return $i
     }
  }
  lappend config(rules) "$target,$ruleText"
  return [expr [llength $config(rules)] - 1]
}


# Get the value of an objects 'thing'
proc getValue {id thing} {
   foreach node [$id childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         return [$node text]
      }
   }
   return ""
}

package require struct
::struct::graph GrainCrops
GrainCrops node insert "Chickpea"
set colour(Chickpea) "-16711872"
GrainCrops node insert "Fallow_4"
set colour(Fallow_4) "-657956"
GrainCrops node insert "Wheat_1"
set colour(Wheat_1) "-256"
GrainCrops node insert "Wheat"
set colour(Wheat) "-128"
GrainCrops node insert "Fallow"
set colour(Fallow) "-657956"
GrainCrops node insert "Fallow_1"
set colour(Fallow_1) "-657956"
GrainCrops node insert "Fallow_2"
set colour(Fallow_2) "-657956"
GrainCrops node insert "Wheat_2"
set colour(Wheat_2) "-32704"
GrainCrops node insert "Spray"
set colour(Spray) "-657956"
GrainCrops node insert "Fallow_3"
set colour(Fallow_3) "-657956"
GrainCrops node insert "Wheat_3"
set colour(Wheat_3) "-32768"
GrainCrops arc insert "Fallow_1" "Fallow_2" "arc11"
GrainCrops arc lappend "arc11" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc11" rules {[apsimGet day] == 153}
GrainCrops arc lappend "arc11" rules {[apsimGet year] > $config($paddock,yr) }
GrainCrops arc insert "Fallow_2" "Fallow_3" "arc12"
GrainCrops arc lappend "arc12" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc12" rules {[apsimGet day] == 153}
GrainCrops arc lappend "arc12" rules {[apsimGet year] > $config($paddock,yr) }
GrainCrops arc insert "Fallow_4" "Fallow" "arc13"
GrainCrops arc lappend "arc13" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc13" rules {[apsimGet day] == 153}
GrainCrops arc lappend "arc13" rules {[apsimGet year]  > $config($paddock,yr) }
GrainCrops arc insert "Fallow_3" "Fallow_4" "arc14"
GrainCrops arc lappend "arc14" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc14" rules {[apsimGet day] == 153}
GrainCrops arc lappend "arc14" rules {[apsimGet year] > $config($paddock,yr) }
GrainCrops arc insert "Chickpea" "Spray" "arc16"
GrainCrops arc lappend "arc16" actions {sprayChickpeas $paddock}
GrainCrops arc lappend "arc16" actions {set numChickSprays($paddock) 1}
GrainCrops arc lappend "arc16" rules {[set chickPeaRain($paddock) [expr $chickPeaRain($paddock) + [apsimGet rain]]] > 150}
GrainCrops arc lappend "arc16" rules {$numChickSprays($paddock) == 0}
GrainCrops arc insert "Wheat_1" "Fallow_1" "arc0"
GrainCrops arc lappend "arc0" actions {harvestAndEndCrop $paddock wheat}
GrainCrops arc lappend "arc0" rules {[canHarvestCrop $paddock wheat]}
GrainCrops arc insert "Spray" "Chickpea" "arc17"
GrainCrops arc lappend "arc17" actions {}
GrainCrops arc lappend "arc17" rules {1}
GrainCrops arc insert "Chickpea" "Fallow_4" "arc1"
GrainCrops arc lappend "arc1" actions {harvestAndEndCrop $paddock chickpea}
GrainCrops arc lappend "arc1" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc1" rules {[canHarvestCrop $paddock chickpea]}
GrainCrops arc insert "Wheat" "Fallow" "arc2"
GrainCrops arc lappend "arc2" actions {harvestAndEndCrop $paddock wheat}
GrainCrops arc lappend "arc2" rules {[canHarvestCrop $paddock wheat]}
GrainCrops arc insert "Fallow" "Wheat_1" "arc3"
GrainCrops arc lappend "arc3" actions {sowCrop $paddock wheat}
GrainCrops arc lappend "arc3" rules {[dayWithin 129 152]}
GrainCrops arc lappend "arc3" rules {[getEsw $paddock] > 183}
GrainCrops arc lappend "arc3" rules {[getMSeek2 $paddock] > 0.65}
GrainCrops arc lappend "arc3" rules {$daysSinceLastHarvest($paddock) > 30}
GrainCrops arc lappend "arc3" rules {[machineryAvailable tractor1_planter]}
GrainCrops arc lappend "arc3" rules {[areaPlanted wheat]  <=1}
GrainCrops arc lappend "arc3" rules {[getEsw $paddock]}
GrainCrops arc insert "Wheat_2" "Fallow_2" "arc4"
GrainCrops arc lappend "arc4" actions {harvestAndEndCrop $paddock wheat}
GrainCrops arc lappend "arc4" rules {[canHarvestCrop $paddock wheat]}
GrainCrops arc insert "Fallow_1" "Wheat_2" "arc5"
GrainCrops arc lappend "arc5" actions {sowCrop $paddock wheat}
GrainCrops arc lappend "arc5" rules {[dayWithin 129 152]}
GrainCrops arc lappend "arc5" rules {[getEsw $paddock] > 183}
GrainCrops arc lappend "arc5" rules {[getMSeek2 $paddock] > 0.65}
GrainCrops arc lappend "arc5" rules {$daysSinceLastHarvest($paddock) > 30}
GrainCrops arc lappend "arc5" rules {[machineryAvailable tractor1_planter]}
GrainCrops arc lappend "arc5" rules {[areaPlanted wheat]  <=1}
GrainCrops arc lappend "arc5" rules {[getEsw $paddock]}
GrainCrops arc insert "Fallow_3" "Chickpea" "arc6"
GrainCrops arc lappend "arc6" actions {sowCrop $paddock chickpea}
GrainCrops arc lappend "arc6" actions {set chickPeaRain($paddock) 0.0}
GrainCrops arc lappend "arc6" actions {set numChickSprays($paddock) 0}
GrainCrops arc lappend "arc6" rules {[dayWithin 135 151]}
GrainCrops arc lappend "arc6" rules {[getEsw $paddock] > 183                 ;# is on LL15 not crop}
GrainCrops arc lappend "arc6" rules {$daysSinceLastHarvest($paddock) >30}
GrainCrops arc lappend "arc6" rules {[areaPlanted Chickpea] <0.2}
GrainCrops arc lappend "arc6" rules {[getMSeek2 $paddock] > 0.65}
GrainCrops arc lappend "arc6" rules {[machineryAvailable tractor1_planter]}
GrainCrops arc lappend "arc6" rules {[getEsw $paddock]}
GrainCrops arc insert "Fallow_4" "Wheat" "arc7"
GrainCrops arc lappend "arc7" actions {sowCrop $paddock wheat}
GrainCrops arc lappend "arc7" rules {[dayWithin 129 152]}
GrainCrops arc lappend "arc7" rules {[getEsw $paddock] > 183}
GrainCrops arc lappend "arc7" rules {[getMSeek2 $paddock] > 0.65}
GrainCrops arc lappend "arc7" rules {$daysSinceLastHarvest($paddock) > 30}
GrainCrops arc lappend "arc7" rules {[machineryAvailable tractor1_planter]}
GrainCrops arc lappend "arc7" rules {[areaPlanted wheat]  <=1}
GrainCrops arc lappend "arc7" rules {[getEsw $paddock]}
GrainCrops arc insert "Fallow_2" "Wheat_3" "arc8"
GrainCrops arc lappend "arc8" actions {sowCrop $paddock wheat}
GrainCrops arc lappend "arc8" rules {[dayWithin 129 152]}
GrainCrops arc lappend "arc8" rules {[getEsw $paddock] > 183}
GrainCrops arc lappend "arc8" rules {[getMSeek2 $paddock] > 0.65}
GrainCrops arc lappend "arc8" rules {$daysSinceLastHarvest($paddock) > 30}
GrainCrops arc lappend "arc8" rules {[machineryAvailable tractor1_planter]}
GrainCrops arc lappend "arc8" rules {[areaPlanted wheat]  <=1}
GrainCrops arc lappend "arc8" rules {[getEsw $paddock]}
GrainCrops arc insert "Wheat_3" "Fallow_3" "arc9"
GrainCrops arc lappend "arc9" actions {harvestAndEndCrop $paddock wheat}
GrainCrops arc lappend "arc9" rules {[canHarvestCrop $paddock wheat]}
GrainCrops arc insert "Fallow" "Fallow_1" "arc10"
GrainCrops arc lappend "arc10" actions {set config($paddock,yr)   [apsimGet year]}
GrainCrops arc lappend "arc10" rules {[apsimGet day] == 153}
GrainCrops arc lappend "arc10" rules {[apsimGet year] > $config($paddock,yr) }
if {[info exists config(p1,graphNames)]} {lappend config(p1,graphNames) GrainCrops} else {set config(p1,graphNames) GrainCrops}
set config(p1,initialState) "Fallow"
if {[info exists config(p2,graphNames)]} {lappend config(p2,graphNames) GrainCrops} else {set config(p2,graphNames) GrainCrops}
set config(p2,initialState) "Fallow"
if {[info exists config(p3,graphNames)]} {lappend config(p3,graphNames) GrainCrops} else {set config(p3,graphNames) GrainCrops}
set config(p3,initialState) "Fallow"
if {[info exists config(p4,graphNames)]} {lappend config(p4,graphNames) GrainCrops} else {set config(p4,graphNames) GrainCrops}
set config(p4,initialState) "Fallow"
if {[info exists config(p5,graphNames)]} {lappend config(p5,graphNames) GrainCrops} else {set config(p5,graphNames) GrainCrops}
set config(p5,initialState) "Fallow"

#############################
# Generic sowing/harvesting procedures. These rely on a "defaults" array for crop specifics
# There are NO ECONOMICS in this - just event based reporting (sow,harvest & spray)
#############################
# Change to a new state (utility procedure). Sows crop and fertilises it
proc sowCrop {paddock crop} {
   global defaults config

   # See if this is an alias
   if {[info exists config($crop,alias)]} {
      set realCrop $config($crop,alias)
   } else {
      set realCrop $crop
   }
   array set sow [gatherArgs sow $crop]

   eval apsimSendMessage .masterpm.$paddock.$realCrop sow [mash [array get sow]]

   # machinery operation
   eval apsimSendMessage machinery operate \
                   [mash [concat [array get sow] area $config($paddock,area)  \
                   paddock $paddock costtype incrop_cost ]]

   # Work out what to do with fertiliser stuff
   array set fert [gatherArgs fertiliser $crop]
   if {$fert(calcMethod) == "constant_rate"} {
      eval apsimSendMessage .masterpm.$paddock.fertiliser apply [mash [array get fert]]
      reportEvent $paddock "fertilise-type=$fert(type),amount=$fert(amount)"
 
   } elseif {$fert(calcMethod) == "targetN"} {
      set n [apsimGet $config($paddock,nModule).no3()]
      set deficit [expr $fert(amount) - $n]
      if {$deficit > 0.0} {
         set fert(amount) $deficit
         eval apsimSendMessage .masterpm.$paddock.fertiliser apply [mash [array get fert]]
         reportEvent $paddock "fertilise-type=$fert(type),amount=$fert(amount)"

      }                                 
   } elseif {$fert(calcMethod) == "howard"} {
      set N  [apsimGet $config($paddock,nModule).no3()]      
      set sw [apsimGet esw]             
      set deficit [expr $sw - $N]
      if {$deficit > 0.0} {
         set fert(amount) $deficit
         eval apsimSendMessage $paddock.fertiliser apply [mash [array get fert]]
         reportEvent $paddock "fertilise-type=$fert(type),amount=$fert(amount)"
      }
   }

   # Finally, see if there's a helper function defined
   if {[info commands sow$realCrop] != {}} {
      extraSow$realCrop
   } elseif {[info commands sow$crop] != {}} {
      extraSow$crop
   }

   reportEvent $paddock "sow-crop=$crop"
}

# See whether an apsim crop can be harvested (utility procedure)
proc canHarvestCrop {paddock crop} {
   global config

   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}

   if {$crop == "wheat" || $crop == "sorghum" || $crop == "maize" || $crop == "chickpea" || $crop == "weed"} {
      set stageName [apsimGet $paddock.$crop.StageName]
      set plant_status [apsimGet $paddock.$crop.plant_status]
      if {$stageName == "harvest_ripe" || $plant_status == "dead"} {
         return 1
      }
      return 0
   } else {
      error "canHarvestCrop: Don't know harvest a crop called $crop"
   }
}

# Harvest and end a crop
proc harvestAndEndCrop {paddock crop} {
   global config daysSinceLastHarvest defaults

   if {[info exists config($crop,alias)]} {
      set realCrop $config($crop,alias)
   } else {
      set realCrop $crop
   }

   if {[apsimGet .masterpm.$paddock.$realCrop.plant_status] != "dead"} {
      reportEvent $paddock "harvest-crop=$crop"
   } else {
      reportEvent $paddock "fail-crop=$crop"
   }
   apsimSendMessage .masterpm.$paddock.$realCrop harvest
   apsimSendMessage .masterpm.$paddock.$realCrop end_crop
   set daysSinceLastHarvest($paddock) 0
}

proc getEsw {paddock} {
   global config
   return [apsimGetOptional $config($paddock,watBal).esw]
}

proc getMSeek2 {paddock} {
   global config

   set ll2    [lindex [apsimGet $config($paddock,watBal).ll15] 1]
   set swat2  [lindex [apsimGet $config($paddock,watBal).sw]   1]
   set dul2   [lindex [apsimGet $config($paddock,watBal).dul]  1]
   
   set mseek2 [expr (($swat2-$ll2)/($dul2-$ll2))]

   return $mseek2
}

proc sprayChickpeas {paddock} {
   apsimWriteToSummaryFile "spraying Chickpeas"
   reportEvent $paddock "spray-type=insecticide,amount=0.3"
}


###############Animal management

proc OatsAreReady {} {
   set status [apsimGetOptional ".masterpm.OatsPaddock.oats.plant_status"]
   return [string match $status "alive"]
}

proc SorghumIsReady {} {
   set status [apsimGetOptional ".masterpm.SorghumPaddock.SweetSorghum.plant_status"]
   return [string match $status "alive"]
}


# Dummy economic values
set animals(steers,price)     0.0  ;# $/kg live at gate
set animals(inCost)           0.0  ;# $/head handling cost
set animals(outCost)          0.0  ;# $/head stock handling cost at CQ Mixed GG

proc setupAnimals {nMobs} {
   global config animals simName
   catch {file delete ${simName}.livestock.csv}
   set animals(mobs) {}
   for {set mob 1} {$mob <= $nMobs} {incr mob} {
      lappend animals(mobs) "mob$mob"
      set animals(mob$mob,number) 0
      set animals(mob$mob,state) "off"
      set animals(mob$mob,paddock)  {}
      set animals(mob$mob,crop)   {}
      set animals(mob$mob,supplemented) 0
      set animals(mob$mob,id) ".masterpm.mob${mob}"
      apsimSet $animals(mob$mob,id).stocking_rate 0.0
      apsimSet $animals(mob$mob,id).alw 0.0
      apsimSet $animals(mob$mob,id).pasture_source ".masterpm.farm manager"
      apsimSet $animals(mob$mob,id).allow_supplements 0
   }
}

proc closeAnimals {} {
   global animals simName

   set fp [open "${simName}.livestock.csv" w]
   puts $fp "date,mob,number,from,to,weight"
   puts $fp [join $animals(report) "\n"]
   close $fp
}

# Bring some animals into the system
proc animalsIn { number class initialWeight } {
   global config animals

   foreach mob $animals(mobs) {
      if {$animals(${mob},state) == "off"} {break}
   } 
   if {$animals(${mob},state) != "off"} {parray animals; error "Already too many mobs to make $class"}
   
   set animals($mob,state)        on
   set animals($mob,class)        $class
   set animals($mob,alw)          $initialWeight
   set animals($mob,number)       $number
   set animals($mob,age)          0
   set animals($mob,paddock)        {}
   set animals($mob,crop)         {}
   set animals($mob,supplemented) 0
   apsimSet $animals($mob,id).allow_supplements 0

   reportEvent livestock "buy-amount=$number,type=$class,weight=$initialWeight"

   apsimSendMessage economics expenditure {paddock livestock}\
             "cost [expr $number * $initialWeight * $animals($class,price)]" \
             [list comment "purchase of $number $class at $initialWeight kg"]

   apsimSendMessage economics expenditure {paddock livestock}\
             "cost [expr $number * $animals(inCost)]" \
             [list comment "in costs of $number $class"]

   apsimWriteToSummaryFile "[apsimGet dd/mm/yyyy]: animals:In: mob $mob is class $class, weight=$initialWeight"
   # initial stocking rate isn't set until we have a paddock with an area
   return $mob
}

# Take animals out the system
proc animalsOut { mob number } {
   global animals

   if {![info exists animals($mob,state)]} {apsimWriteToSummaryFile "Trying to remove non-existent mob $mob"; return}
   
   if {$number == "all"} { set number $animals($mob,number) }

   set animals(${mob},number) [expr $animals(${mob},number) - $number]
   
   reportEvent livestock "sell-amount=$number,type=$animals($mob,class),weight=[format %.0f $animals($mob,alw)]"
   lappend animals(report) "[apsimGet dd/mm/yyyy],$mob,$number,$animals($mob,paddock).$animals($mob,crop),out,[format %.0f $animals($mob,alw)]"

   apsimSendMessage economics expenditure {paddock livestock}\
             "cost [expr $number * $animals(outCost)]" \
             [list comment "out costs of $number $animals($mob,class)"]

   apsimSendMessage economics income \
       {paddock livestock} "name $animals(${mob},class)" \
       "amount [expr $number * $animals(${mob},alw) * $animals($animals(${mob},class),price)]" \
       [list comment "sale of $number $animals(${mob},class) at $animals(${mob},alw) kg"]

   apsimWriteToSummaryFile "[apsimGet dd/mm/yyyy]: animals:Out: removing $number of mob $mob ($animals(${mob},class))  at [format %.0f $animals(${mob},alw)] kg"

   if {$animals(${mob},number) <= 0} {
      set animals(${mob},state)  off
      set animals(${mob},alw)    0.0
      set animals(${mob},age)    0
      set animals(${mob},paddock)  {}
      set animals(${mob},crop)   {}
      set animals($mob,supplemented) 0
      apsimSet $animals($mob,id).pasture_source ".masterpm.farm manager"
      apsimSet $animals($mob,id).stocking_rate  0.0
      apsimSet $animals($mob,id).alw            0.0
      apsimSet $animals($mob,id).allow_supplements 0
      apsimWriteToSummaryFile "[apsimGet dd/mm/yyyy]: animals:Out: mob $mob is gone"
   } else {
      error "Adjust stocking rate here.."
   }
}

# Keep track of alw and age
proc doPostAnimals {} {
   global animals config

   foreach mob $animals(mobs) {
      if {$animals(${mob},state) != "off"} {

          # keep track of ALW if they're on a 'fake' paddock
          if {$animals(${mob},crop) == "stubble" || $animals(${mob},crop) == "stubble"} {
             set animals($mob,alw) [expr $animals($mob,alw) + 0.9]      ;# 0.9 kg/hd/day
             
          } elseif {$animals(${mob},crop) == "feedlot"} {
             set animals($mob,alw) [expr $animals($mob,alw) + 2.0]      ;# 2.0 kg/hd/day
          } else {
             if {$animals($mob,supplemented)} {
                # Work out pot lwg and ignore feed restrictions
                set month [apsimGet month]
                set season(1) summer
                set season(2) summer
                set season(3) autumn
                set season(4) autumn
                set season(5) autumn
                set season(6) winter
                set season(7) winter
                set season(8) winter
                set season(9) spring
                set season(10) spring
                set season(11) spring
                set season(12) summer
                set lwg [expr $config($animals(${mob},crop),$season($month)_lwg) / 91.25]
                set animals($mob,alw) [expr $animals($mob,alw) + $lwg]
                apsimSet $animals($mob,id).alw $animals($mob,alw)
             } else {
               set animals($mob,alw) [apsimGet $animals($mob,id).alw]
             }  
          }
          incr animals(${mob},age)
      }
   }
}


#Move stock somewhere. 
# mob = name of the animal group
# paddock = the paddock they're going to
# crop = The name of the crop they'll eat
proc moveStockTo {mob paddock crop} {
   global config animals

   set from "$animals($mob,paddock).$animals($mob,crop)"
   if {$crop == "feedlot"} {
      apsimSet $animals($mob,id).pasture_source ".masterpm.farm manager"
   } elseif {$crop == "stubble" || $crop == "Stubble"} {
      apsimSet $animals($mob,id).pasture_source ".masterpm.farm manager"
   } else {
      apsimSet $animals($mob,id).pasture_source ".masterpm.$paddock.$crop"
      set newSr [expr $animals($mob,number) / $config($paddock,area)]

      ##?? need to convert animal equivalents here

      apsimSet $animals($mob,id).stocking_rate $newSr
      apsimSet $animals($mob,id).alw $animals($mob,alw)

      foreach season {summer_lwg winter_lwg autumn_lwg spring_lwg} {
         apsimSet $animals($mob,id).${season} $config($crop,$season)
      }
   }
   set animals($mob,paddock)  $paddock
   set animals($mob,crop)   $crop
   set animals($mob,state)  "$paddock.$crop"
   set animals($mob,age)    0
   set animals($mob,age)    0
   set animals($mob,supplemented) 0
   apsimSet $animals($mob,id).allow_supplements 0
   apsimWriteToSummaryFile "[apsimGet dd/mm/yyyy]: animals:moveStockTo mob=$mob from=$from to=$paddock.$crop wt=[format %.0f $animals($mob,alw)] sr=[format %.2f [apsimGet $animals($mob,id).stocking_rate]]"
   lappend animals(report) "[apsimGet dd/mm/yyyy],$mob,$animals($mob,number),$from,$paddock.$crop,$animals($mob,alw)"
}

# Split a mob.  
proc splitMob { mob num paddock crop } {
   global config animals

   apsimWriteToSummaryFile "[apsimGet dd/mm/yyyy]: animals:split $animals($mob,class) old =$animals($mob,number), new =[expr $animals($mob,number) - $num]"

   foreach newmob $animals(mobs) {
      if {$animals(${newmob},state) == "off"} {break}
   } 
   if {$animals(${newmob},state) != "off"} {parray animals; error "Too many mobs to split"}
   
   foreach what {state class alw number age} {
      set animals($newmob,$what) $animals($mob,$what)  
   }
   set animals($mob,number) [expr $animals($mob,number) - $num]
   if {$animals($mob,number) < 0} {parray animals; error "mob $mob has negative size"}
   moveStockTo $mob $animals($mob,paddock) $animals($mob,crop)

   set animals($newmob,number)  $num
   if {$animals($newmob,number) < 0} {parray animals; error "mob $newmob has negative size"}
   moveStockTo $newmob $paddock $crop
   return $newmob
}

proc setSupplementsOn {mob} {
   global animals
   set animals($mob,supplemented) 1
   apsimSet $animals($mob,id).allow_supplements 1
}

proc setSupplementsOff {mob} {
   global animals
   set animals($mob,supplemented) 0
   apsimSet $animals($mob,id).allow_supplements 0
}

proc animalWeight {mob} {
   global animals
   if {[info exists animals($mob,alw)]} { return $animals($mob,alw)}
   return {}
}

proc animalNumber {mob} {
   global animals
   if {[info exists animals($mob,number)]} {return $animals($mob,number)}
   return {}
}

proc animalPaddock {mob} {
   global animals
   if {[info exists animals($mob,paddock)]} {return $animals($mob,paddock)}
   return {}
}

proc animalCrop {mob} {
   global animals
   if {[info exists animals($mob,crop)]} {return $animals($mob,crop)}
   return {}
}

proc animalDaysIn {mob where} {
   global animals
   if {$animals($mob,crop) == "$where"} {
     return $animals($mob,age)
   } 
   return 0  
}

proc heaviestMob {} {
   global animals
   set w 0.0; set m {}
   foreach mob $animals(mobs) {
      if {[info exists animals($mob,alw)]} { 
          if {$animals($mob,alw) > $w} {
             set w $animals($mob,alw)
             set m $mob
          }
      }
   }
   return $m
}

proc heaviestMobNotIn {paddock} {
   global animals
   set w 0.0; set m {}
   foreach mob $animals(mobs) {
      if {[info exists animals($mob,alw)]} { 
          if {[animalPaddock $mob] != "$paddock" && $animals($mob,alw) > $w} {
             set w $animals($mob,alw)
             set m $mob
          }
      }
   }
   return $m
}

proc lightestMobIn {paddock} {
   global animals
   set w 10000.0; set m {}
   foreach mob [listAnimalsIn $paddock] {
      if {[info exists animals($mob,alw)]} { 
          if {$animals($mob,alw) < $w} {
             set w $animals($mob,alw)
             set m $mob
          }
      }
   }
   return $m
}

proc anyAnimalsIn {paddock} {
   global animals
   foreach mob $animals(mobs) {
       if {$animals($mob,paddock) == "$paddock"} {return 1} 
   }
   return 0
}

proc listAnimalsIn {paddock} {
   global animals
   set r {}
   foreach mob $animals(mobs) {
       if {$animals($mob,paddock) == "$paddock"} {lappend r $mob} 
   }
   return $r
}

proc mobsOnFarm {} {
   global animals
   set mobs {}
   foreach mob $animals(mobs) {
       if {$animals($mob,state) != "off"} {lappend mobs $mob} 
   }
   return $mobs
}

proc doSupplementCosts {} {
   global animals

   set nSupplemented 0
   foreach mob $animals(mobs) {
      if {$animals($mob,supplemented)} {
         set nSupplemented [expr $nSupplemented + $animals($mob,number)]
      }
   }

   if {$nSupplemented > 0} {
      apsimSendMessage economics expenditure {paddock livestock}\
             "cost [expr $nSupplemented * $animals(dailySupplementCost)]" \
             [list comment "supplement costs for $nSupplemented beasts"]
   }
}

proc doFeedlotCosts {} {
   global animals

   # Work out feedlot costs for today
   set nInFeedlot 0
   foreach mob $animals(mobs) {
      if {$animals($mob,paddock) == "feedlot"} {
         set nInFeedlot [expr $nInFeedlot + $animals($mob,number)]
      }
   }

   if {$nInFeedlot > 0} {
      apsimSendMessage economics expenditure {paddock livestock}\
             "cost [expr $nInFeedlot * $animals(dailyFeedlotCost)]" \
             [list comment "feedlot costs for $nInFeedlot beasts"]
   }
}


proc sellAndReplace {mob} {
   set n [animalNumber $mob]
   sell $mob
   replace $mob $n
}
    
proc sell {mob} {
   animalsOut $mob all
}

proc replace {mob n} {
   set mob [animalsIn $n steers 250]      ;# replace sold animals @ 250Kg 
   moveStockTo $mob BuffelPaddock buffel  ;# move onto buffel paddock
}

proc numAnimalsIn { paddock } {
  set n 0
  foreach mob [listAnimalsIn $paddock] {
    set n [expr $n + [animalNumber $mob]]
  }   
  return $n
}



# Some extra bits (needed to fool animals to talk to top level)
set leafgreenwt 0.0
set stemgreenwt 0.0
set leafsenescedwt 0.0
set stemsenescedwt 0.0
set dlt_dm 0.0
set source {}


# Newer version of weed germination - spray 2 weeks after a {germination event & swCrit & temp}.
proc checkWeeds {} {
   global daysSinceLastHarvest weeds  config

   foreach paddock $config(cropPaddocks) {
      if {[string match -nocase *fallow* [currentState $paddock]] && 
          $daysSinceLastHarvest($paddock) > 30} {

         if {$weeds($paddock,GermDay) == {} && [sumLastRain 4] >= 25} {
            set weeds($paddock,GermDay) [apsimGet day]
            set weeds($paddock,tt) 0.0
            apsimWriteToSummaryFile "Weeds germinating in $paddock"

         } elseif {$weeds($paddock,GermDay) != {}} {
            # Thermal time calc
            set weeds($paddock,tt) [expr $weeds($paddock,tt) + ([apsimGet maxt] + [apsimGet mint])/2.0]
         
            # Surface SW calc
            set ll [lindex [apsimGet $config($paddock,watBal).ll15] 0];
            set sw [lindex [apsimGet $config($paddock,watBal).sw] 0]
            set dul [lindex [apsimGet $config($paddock,watBal).dul] 0]
            set swf [expr (($sw-$ll)/($dul-$ll))]
         
            if {$swf < 0.5} {
               # kill off weeds
               set weeds($paddock,GermDay) {}
               apsimWriteToSummaryFile "Weeds die in $paddock"
         
            } elseif {$weeds($paddock,tt) > 250.0} {
               # Weeds are mature - spray them
               incr weeds($paddock,Events)

               eval apsimSendMessage machinery operate [mash [concat [gatherArgs spray herbicide] \
                      area $config($paddock,area)  paddock $paddock  costtype fallow_cost]]

               apsimWriteToSummaryFile "Weeds mature in $paddock - sprayed out."
            
               reportEvent $paddock "spray-type=roundup,amount=1.5"
         
               set weeds($paddock,GermDay) {}
               set weeds($paddock,tt)      0.0
            }
         }
      }   
   }
}

# An event based report file - "agronomic" style

# Write a line to the CSV report file
proc reportCSV {from evt args} {
   global config event
   foreach arg [split $args ","] {
      foreach {name value} [split $arg "="] {break}
      set info($name) $value
   }
   if {[info exists info(crop)]} {set crop $info(crop)} else {set crop ""}
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}
   if {$crop == ""} {return}

   set line "$evt,$from,[apsimGet year],[apsimGet dd/mm/yyyy]"

   if {[info exists event($from,daysSinceEvent)]} {append line ",$event($from,daysSinceEvent)"} else {append line ","}
   set event($from,daysSinceEvent) 0
   
   append line ",$crop"
   if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.yield]"} else {append line ","}
   if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.biomass]"} else {append line ","}
   if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.grain_protein]"} else {append line ","}
   append line ",$event($from,ep)"; set event($from,ep) 0.0
   append line ",[apsimGet $config($from,watBal).esw]"
   append line ",[apsimGet $config($from,nModule).no3()]"

   if {$evt == "harvest"} {append line ",[apsimGetOptional $from.tracker.incroprain]"} else {append line ","}
   if {$evt == "sow"} {append line ",[apsimGetOptional $from.tracker.fallowrain]"} else  {append line ","}

   append line ",[apsimGet $from.tracker.es_sum]"
   append line ",[apsimGet $from.tracker.runoff_sum]"
   append line ",[apsimGet $from.tracker.drainage_sum]"
   append line ",[apsimGet $from.tracker.soil_loss_sum]"
   append line ,[apsimGet "$from.surface organic matter.surfaceom_wt"]
   append line ",[apsimGet $config($from,watBal).cover_surface_runoff]"
   append line ",[apsimGet $from.tracker.n_mineralisation_sum]"
   
   apsimSendMessage $from.tracker blork

   lappend event(lines) $line
}

rename reportEvent reportEvent_OLD
proc reportEvent [info args reportEvent_OLD] "[info body reportEvent_OLD]; reportCSV \$from \$event \$args"


# Set up an "economic event" based report file

# Write a line to the CSV report file
proc reportEcon {from evt args} {
   global config event
   foreach arg [split $args ","] {
      foreach {name value} [split $arg "="] {break}
      set info($name) $value
   }
   if {[info exists info(crop)]} {set crop $info(crop)} else {set crop ""}
   if {[info exists config($crop,alias)]} {set crop $config($crop,alias)}

   set line "$evt,$from"
   if {[info exists config($from,area)]} {append line ",$config($from,area)"} else {append line ","}
   append line ",[apsimGet year],[apsimGet dd/mm/yyyy]"

   if {[info exists event($from,daysSinceEcon)]} {append line ",$event($from,daysSinceEcon)"} else {append line ","}
   set event($from,daysSinceEcon) 0
   
   if {$crop != ""} {
     append line ",$crop"
     if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.yield]"} else {append line ","}
     if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.biomass]"} else {append line ","}
     if {$evt == "harvest"} {append line ",[apsimGetOptional .masterpm.$from.$crop.grain_protein]"} else {append line ","}
   } else {
     append line ",,,,"
   }  

   if {[info exists info(type)]} {append line ",$info(type)"} else {append line ","}
   if {[info exists info(amount)]} {append line ",$info(amount)"} else {append line ","}
   if {[info exists info(weight)]} {append line ",$info(weight)"} else {append line ","}

   lappend event(econLines) $line
}

rename reportEvent reportEvent_OLDECON
proc reportEvent [info args reportEvent_OLDECON] "[info body reportEvent_OLDECON]; reportEcon \$from \$event \$args"


# Annual summary of whole farm averages

proc open_annual_stuff {} {
   global annual config

   set year [expr [apsimGet year] - 1 ]
   set annual(years) $year
   set annual(accRain) 0.0
   set annual($year,balance) [apsimGetOptional balance] 
   foreach {accumulator} {runoff drain soil_loss es } {
     foreach paddock $config(paddocks) {
        set annual($paddock,$accumulator) 0.0
     }   
   }
}

set annual(states) {}

proc do_end_year {} {
   global config annual

   set year [apsimGet year]

   foreach {accumulator} {runoff drain soil_loss es} {
     foreach paddock $config(paddocks) {
        set annual($year,$paddock,$accumulator) $annual($paddock,$accumulator)
        set annual($paddock,$accumulator) 0.0
     }
   }

   set annual($year,accRain) $annual(accRain)
   set annual(accRain) 0.0

   set annual($year,balance) [apsimGetOptional balance]
   lappend annual(years) $year
}

proc close_annual_stuff {} {
   global simName config annual

   # Heading
   set fp [open $simName.annual.csv w]
   puts -nonewline $fp "year"
   foreach {accumulator} {runoff drain soil_loss es rain} {
      puts -nonewline $fp ",$accumulator"
   }
   foreach state $annual(states) {
      if {$state != {}} {
        puts -nonewline $fp ",$state"
      }
   }
   puts $fp ",profit"

   # Area weighted averages of environmental stuff
   set tfa 0.0
   foreach paddock $config(paddocks) {set tfa [expr $tfa + $config($paddock,area)]}

   foreach year [lrange $annual(years) 1 end] {
      puts -nonewline $fp "$year"
      foreach {accumulator} {runoff drain soil_loss es} {
         set s 0.0
         foreach paddock $config(cropPaddocks) {
            set s [expr $s + $annual($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
         }
         puts -nonewline $fp ",$s"
      }
      puts -nonewline $fp ",$annual($year,accRain)"

      # Number of "state transitions" made in each year
      foreach state $annual(states) {
         if {$state != {}} {
            if {[info exists annual($year,$state)]} {
              puts -nonewline $fp ",$annual($year,$state)"
            } else {
              puts -nonewline $fp ",0"
            }  
         }
      }

      # profit = change in bank balance each year
      catch {
         puts -nonewline $fp ",[expr $annual($year,balance) - $annual([expr $year-1],balance)]"
      }
      puts $fp ""
   }
   close $fp
   
}

# Log a state transition
proc logState {graph paddock state} {
   global config annual
   set today [apsimGet today]
   lappend config(history,$paddock,$graph) $today $state
   if {[lsearch $config(states) $state] < 0} {lappend config(states) $state}

   set day [apsimGet day]
   set year [apsimGet year]
   
   if {![info exists annual($year,$state)]} {
     set annual($year,$state) 1
   } else {
     incr annual($year,$state)
   }
   if {[lsearch $annual(states) $state] < 0} {lappend annual(states) $state}
}




     --->Section: post

doPostAnimals 
   foreach x [array names event  *,daysSinceEvent] {
      incr event($x)
   }

foreach paddock $config(cropPaddocks) {
   foreach crop $config(crops) {
      set ep [apsimGetOptional $paddock.$crop.ep]
      if {$ep != ""} {
        set event($paddock,ep) [expr $event($paddock,ep) + $ep]
      }  
   }
}
   foreach x [array names event  *,daysSinceEcon] {
      incr event($x)
   }

   
   set annual(accRain) [expr $annual(accRain) + [apsimGet rain]]
   
   foreach {accumulator} {runoff drain es } {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet $config($paddock,watBal).$accumulator]]
         }
      }   
   }
   foreach {accumulator} {soil_loss} {
      foreach paddock $config(paddocks) {
         if {$paddock != "toplevel"} {
            set annual($paddock,$accumulator) [expr $annual($paddock,$accumulator) + [apsimGet .masterpm.$paddock.erosion.$accumulator]]
         }
      }   
   }
   
     --->Section: prepare

accumRain

######## Daily Animal Management

# If there's an oats crop ready with no animals on it, put the heaviest mob there
if {[apsimGet "OatsPaddock.oats.biomass"] > 1500 &&
     [numAnimalsIn OatsPaddock] < $config(OatsPaddock,numAnimals) } { ;#if there's no animals on this paddock then
    set heaviest [heaviestMobNotIn OatsPaddock]
    if {$heaviest != {}} {
       moveStockTo $heaviest  OatsPaddock oats  ;# move onto oats paddock
    } else {apsimWriteToSummaryFile "animals: whoops! trying to move empty mob onto oats"}
}

# If the oats are flogged, move any animals there out.
if {[anyAnimalsIn OatsPaddock] &&
     [apsimGet "OatsPaddock.oats.biomass"] < 1000 } {
   foreach mob [listAnimalsIn OatsPaddock] {
      moveStockTo $mob LeucaenaGrassPaddock leucaena      ;# move
   }
}

# Same for sorghum
if {[apsimGet "SorghumPaddock.SweetSorghum.biomass"] > 2500 &&
     [numAnimalsIn SorghumPaddock] < $config(SorghumPaddock,numAnimals) } {
    set heaviest [heaviestMobNotIn SorghumPaddock]
    if {$heaviest != {}} {
       moveStockTo $heaviest  SorghumPaddock SweetSorghum
    } else {apsimWriteToSummaryFile "animals: whoops! trying to move empty mob onto sorg"}
}

if {[anyAnimalsIn SorghumPaddock] &&
    [apsimGet "SorghumPaddock.SweetSorghum.biomass"] < 1000 } {
  foreach mob [listAnimalsIn SorghumPaddock] {
     if {[numAnimalsIn LeucaenaGrassPaddock] < $config(LeucaenaGrassPaddock,numAnimals) } {
         moveStockTo $mob LeucaenaGrassPaddock leucaena      
     } else {    
         moveStockTo $mob BuffelPaddock buffel 
     }
  }    
}

# If buffel is flogged, move animals to leucaena
if {[anyAnimalsIn BuffelPaddock ] &&
     [apsimGet "BuffelPaddock.buffel.tsdm"] < 1000 &&
     [numAnimalsIn LeucaenaGrassPaddock] < $config(LeucaenaGrassPaddock,numAnimals) &&
     [apsimGet "LeucaenaGrassPaddock.leucaena.tsdm"] > 1000 } {
   apsimWriteToSummaryFile "animals: Buffel is scarce - tsdm=[apsimGet BuffelPaddock.buffel.tsdm]"
   set mob [lightestMobIn BuffelPaddock ] 
   if {$mob != {}} {
       moveStockTo $mob LeucaenaGrassPaddock leucaena   
   }
}

# Sell animals if buffel is finished
if {[anyAnimalsIn BuffelPaddock ] &&
    [apsimGet "BuffelPaddock.buffel.tsdm"] < 800 } {
   apsimWriteToSummaryFile "animals: Buffel is flogged - tsdm=[apsimGet BuffelPaddock.buffel.tsdm]"
   foreach mob [listAnimalsIn BuffelPaddock ] {
      sell $mob   
   }
}

# Sell if everything gone - nowhere left to go
if {[anyAnimalsIn LeucaenaGrassPaddock ] &&
    [apsimGet "LeucaenaGrassPaddock.leucaena.tsdm"] < 800 } {
   apsimWriteToSummaryFile "animals: Leucaena is flogged - tsdm=[apsimGet LeucaenaGrassPaddock.leucaena.tsdm]"
   foreach mob [listAnimalsIn LeucaenaGrassPaddock] {
      sell $mob
   }
}

# Replace stock if pasture becomes available
if { [llength [mobsOnFarm]] < [llength $animals(mobs)] } {
#puts "animals: Only have  [llength [mobsOnFarm]] mobs on farm"
   foreach {paddock pasture} {LeucaenaGrassPaddock leucaena BuffelPaddock buffel} {
      set n [numAnimalsIn $paddock]
#puts "there are $n animals on $paddock.$pasture, which is [apsimGet $paddock.$pasture.tsdm]kg/ha"
      if {$n <  $config($paddock,numAnimals) && [apsimGet "$paddock.$pasture.tsdm"]  > 1000} {
#puts "trying to bring 100 animals into $paddock  $pasture"
         set mob [animalsIn 100 steers 250]       ;# replace sold animals @ 250Kg 
         moveStockTo $mob $paddock $pasture
      }
   }
}

# Sell any animal > 450kg
foreach mob $animals(mobs) {
   if { [animalWeight $mob] > 450 } {    
      sellAndReplace $mob
   }
}

     --->Section: process

# Housekeeping
if {[catch {doProcess } msg]} {
   puts "$errorInfo"
   error "$msg\n$errorInfo"
}


c