     ###     ######     #####   #   #     #   
    #   #    #     #   #        #   ##   ##   
   #     #   #     #   #        #   ##   ##   
   #######   ######     #####   #   # # # #   
   #     #   #              #   #   #  #  #   
   #     #   #         #####    #   #  #  #   
                                              
                                              
 The Agricultural Production Systems Simulator
             Copyright(c) APSRU               

Version                = 7.4
Title                  = MCA plastic
   Component                        "clock" = %apsim%\Model\Clock.dll
   Component                          "met" = %apsim%\Model\Input.dll
   Component                    "Economics" = %apsim%\Model\TclLink.dll
   Component                    "Machinery" = %apsim%\Model\TclLink.dll
   Component                 "Farm Manager" = %apsim%\Model\TclLink.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll
Paddock:
   Component                        "accum" = %apsim%\Model\Accum.dll
   Component                   "fertiliser" = %apsim%\Model\Fertiliser.dll
   Component                   "Soil Water" = %apsim%\Model\SoilWat.dll
   Component       "surface organic matter" = %apsim%\Model\SurfaceOM.dll
   Component                      "erosion" = %apsim%\Model\Erosion.dll
   Component                "Soil Nitrogen" = %apsim%\Model\SoilN.dll
   Component                        "wheat" = %apsim%\Model\Plant.dll
   Component                     "chickpea" = %apsim%\Model\Plant.dll
   Component                         "weed" = %apsim%\Model\Plant.dll
   Component                      "sorghum" = %apsim%\Model\Sorghum.dll

------- clock Initialisation --------------------------------------------------
     Sequencer phases:
        prepare
        init_step
        do_pasture_water
        process
        do_pasture_growth
        do_stock
        post
        end_step
     Simulation start date =  1/01/1970
     Simulation end date   =  2/07/1972
     Time step =           = 1440 (mins)

------- met Initialisation ----------------------------------------------------
     Sparse data is not allowed
     INPUT File name: %apsim%\Examples\Metfiles\Goond.met
Economics: 
     Copyright (C) 1991-1994 The Regents of the University of California.
     Copyright (C) 1996-1997 Sun Microsystems, Inc.
     Copyright (C) 2001      ActiveState.
     --->Section: init

# Apsim/Economics Cashbook (sub)module

# accepts messages:
#  cashbook income {amount 64000.0} {comment "description here"}
#  cashbook income {category cropprice} {name wheat} {yield 4000} {protein 12.3} {comment "description here"}
#  cashbook income {category cropprice} {name sorghum} {yield 6000} {comment "description here"}
#  cashbook expenditure {cost 42.0} {comment "description here"}
#  cashbook expenditure {category seed} {name wheat} {rate 120} {comment "description here"}
# Keeps a balance, writes a log.

########################## Apsim interface code here
source $apsuite/Model/TclLink/CIDataTypes.tcl

set balance [expr 0.0]
apsimRegisterGetSet balance
apsimSubscribeVariant  income      "cashbook:incomeHandler"
apsimSubscribeVariant  expenditure "cashbook:expenditureHandler"
apsimSubscribeNull  process     "cashbook:processHandler"
apsimSubscribeNull  end_simulation "cashbook:exitHandler"

# An event handler. 
#  cashbook income {amount 64000.0}                                              {comment "description here"}
#  cashbook income {category cropprice} {name wheat} {yield 4000} {protein 12.3} {comment "description here"}
#  cashbook income {category cropprice} {name sorghum} {yield 6000}              {comment "description here"}
proc cashbook:incomeHandler {args} {
   global config incomingVariant balance

   set names {}
   foreach {_name _value} [unpack_Variant $incomingVariant] {
      set $_name [string tolower $_value]
      lappend names $_name
   }
   if {![info exists comment]} { set comment "" }
   if {![info exists paddock]} { set paddock "" }
   if {![info exists protein]} { set protein "" }
   
   if {[info exists amount] && [string is double -strict $amount]} {
      set balance [expr $balance + $amount]
      cashbook:log income amount $amount comment $comment paddock $paddock

   } elseif {[info exists category] && [info exists name] && 
             [info exists yield] && [info exists area]} {
      set amount "NA"
      set price  "NA"
      if {![info exists config(economics,$category,$name)] } {
         foreach {n v} [array get config economics*] {apsimWriteToSummaryFile "economics $n=$v"}
         error "No price information for crop $name in $category"
      }
      if {![info exists config(economics,$category,$name,grain_moisture)] } {
         apsimWriteToSummaryFile "Warning!!!!\nNo grain moisture found for $name. Using 12%."
         set config(economics,$category,$name,grain_moisture) 12.0
      }
      if {$name != "wheat"} {
         set price $config(economics,$category,$name)
      } else {
         # oddball wheat pricing system..
         set proteins $config(economics,$category,$name,protein)
         set prices $config(economics,$category,$name)
         set price [lindex $prices 0]
         for {set i 0} {($i < [llength $proteins]) && 
             ($protein > [lindex $proteins $i])} {incr i} {
               set price [lindex $prices $i]
         }
      }  
      set wetYield [expr ($yield * 100.0) / (100.0 - $config(economics,$category,$name,grain_moisture))]
      set amount [expr  $price * $wetYield * $area]

      set comment "$category ($name)"
      apsimWriteToSummaryFile "Priced $name $category (price='$price', yield='$wetYield' wet) over '$area' ha = '$amount'"
      set balance [expr $balance + $amount]
      cashbook:log income amount $amount comment $comment \
                          income $amount crop_income $amount \
                          paddock $paddock area $area \
                          yield $wetYield protein $protein crop $name
   } else {
      error "cashbook:income: Must specify a either an numeric amount, or <category, name, price and area>."
   }
}

proc cashbook:expenditureHandler {args} {
  global incomingVariant config
  set _names {}

  set comment ""
  foreach {_name _value} [unpack_Variant $incomingVariant] { 
     set $_name [string tolower $_value]
     lappend _names $_name
  }

  if {[lsearch ${_names} comment] < 0} {lappend _names comment}

  if {[info exists cost]} {
     # Simple 
     global balance
     set balance [expr $balance - $cost]
  } elseif {[info exists category] && [info exists name] && [info exists rate] && [info exists area]} {
     # lookup this expense in our table of costs

     if {![info exists config(economics,$category,$name)] } {
        foreach {n v} [array get config economics*] {apsimWriteToSummaryFile "economics $n=$v"}
        error "No price information for $name in $category"
     }

     set price $config(economics,$category,$name)
     set cost [expr $price * $rate * $area]

     if {[lsearch ${_names} price] < 0} {lappend _names price}

     set comment "$category ($name)"
     apsimWriteToSummaryFile "Costed $name $category (rate=$rate, price=$price) over $area ha = $cost"
     
     global balance
     set balance [expr $balance - $cost]
  } else {
     error "cashbook:expenditure: Must specify a either a cost or a (category + name + rate + area)."
  }
  if {[info exists fallow_cost] && ![string is double -strict $fallow_cost]} {set fallow_cost $cost}
  if {[info exists incrop_cost] && ![string is double -strict $incrop_cost]} {set incrop_cost $cost}
  set cmd "cashbook:log expenditure cost $cost" 
  foreach _name ${_names} { lappend cmd ${_name} [set ${_name}] }
  eval $cmd
}

# Add up the annual farm overheads
proc cashbook:doFarmOverheads {} {
   global balance config
   set sum $config(economics,overheads)
      
   set balance [expr $balance - $sum]
   cashbook:log expenditure cost $sum comment "Farm Overheads"
}

# Work our repayments on initial investment
proc cashbook:doInitialCapital {} {
   global config balance

   if {![info exists config(economics,icapital,ivalue)] ||
       ![info exists config(economics,icapital,loanRate)] ||
       ![info exists config(economics,icapital,loanDuration)]} {
      return   
   }
       
   if {![info exists config(economics,icapital,loanPeriod)]} {
      set config(economics,icapital,loanPeriod) 1
   }
   
   if {$config(economics,icapital,loanRate) > 0.0} {
      if {$config(economics,icapital,loanPeriod) <=  $config(economics,icapital,loanDuration)} {
         #A = P(i(1+i)^n)/((1+i)^n - 1)
         set P $config(economics,icapital,ivalue)
         set i [expr $config(economics,icapital,loanRate)/100.0]
         set n $config(economics,icapital,loanDuration)
         
         set A [expr $P * ($i*pow(1+$i,$n))/(pow(1.0+$i,$n) - 1.0) ]
      
         set balance [expr $balance - $A]
         cashbook:log expenditure cost $A \
                                  interest_paid $A \
                                  comment "Loan repayments for initial capital outlay"
         
         set config(economics,icapital,loanPeriod) [expr 1 + $config(economics,icapital,loanPeriod)]
         if { $config(economics,icapital,loanPeriod) >  $config(economics,icapital,loanDuration) } {
             apsimWriteToSummaryFile "Loan for initial capital outlay is finished"
         }    
      }
   }
   puts "doInitialCapital done"
}
     


# Send an "end financial year" message when needed
proc cashbook:processHandler {args} {
  if {[apsimGet day] == 181} {
     cashbook:doFarmOverheads
     cashbook:doInitialCapital
     apsimSendMessage "" end_financial_year
  }
}

proc cashbook:log {what args} {
   global balance config 
   set date [apsimGet dd/mmm/yyyy]

   set _names {}
   foreach {_name _value} $args { 
      set ${_name} ${_value} 
      lappend _names $_name
   }

   if { [info exists config(economics,outputfp)] } {
      if {$what == "income"} {
         puts $config(economics,outputfp) "$date,$amount,,$balance,$comment"
      } elseif {$what == "expenditure"} {
         puts $config(economics,outputfp) "$date,,$cost,$balance,$comment"
      } else {
         error "Unknown cashbook operation '$what'"
      }
   }

   if {$what == "income"} {
      set cmd "cashbook:summary date $date $what $amount"
   } elseif {$what == "expenditure"} {
      set cmd "cashbook:summary date $date $what $cost "
   } else {
      error "Unknown cashbook operation '$what'"
   }
   foreach _name ${_names} { lappend cmd ${_name} [set ${_name}] }
   eval $cmd
}

proc cashbook:summary {args} {
   global balance config
   
   if { [info exists config(economics,summaryfp)]} {
      
      foreach {_name _value} $args {set ${_name} ${_value} }

      foreach v {date paddock area crop yield protein "fertiliser_type" \
               "fertiliser_rate" "interim_rainfall" "interim_runoff" "interim_drainage" \
               "interim_soil_loss" "SW_state" "NO3_state" "fallow_cost" "incrop_cost" "crop_income" \
               "interest_paid" "expenditure" "income" "comment"} {
         if {[info exists $v]} {
            puts -nonewline $config(economics,summaryfp) "[set $v],"
         } else {
            puts -nonewline $config(economics,summaryfp) ","
         }     
      }
      puts $config(economics,summaryfp) ""
   }
}
# Annual summaries. Re-read the event file we have written into a single array and
# write a cash flow summary
proc cashbook:exitHandler {} {
   global config

   puts "Cashbook: Writing summaries"

   if { [info exists config(economics,outputfp)] } { close $config(economics,outputfp) }
   if { [info exists config(economics,summaryfp)] } { close $config(economics,summaryfp) }

   if { ![info exists config(economics,cashSummaryName)] } { return }

   #1. Read and store event data
   set fp [open $config(economics,cashSummaryName) r]
   gets $fp header
   set columns [split $header ","]
   
   set minyear 3000; set maxyear 0; 
   set years {}; set paddocks {}; catch {unset A}
   
   while {[gets $fp line] >= 0} {
      foreach what {incrop_cost fallow_cost crop_income income expenditure interest_paid interest_earned} {catch {unset $what}}
      foreach $columns [split $line ","] {break}
      regsub -all "/" $date "-" date
      set now [clock scan $date]
      set endYear [clock scan "30-june-[clock format $now -format %Y]"]
   
      if {$now > $endYear} {
         set year [expr [clock format $now -format %Y]+1]
      } else {
         set year [clock format $now -format %Y]
      }
   
      if {$year < $minyear} {set minyear $year}
      if {$year > $maxyear} {set maxyear $year}
      if {[lsearch $years $year] < 0} {lappend years $year}
      if {$paddock != {} && $paddock != "livestock" && [lsearch $paddocks $paddock] < 0} {lappend paddocks $paddock}
      foreach what {incrop_cost fallow_cost crop_income} {
         if {[string is double -strict [set $what]]} {
            if {![info exists A($year,$paddock,$what)]} {
               set A($year,$paddock,$what) [set $what]
            } else {
               set A($year,$paddock,$what) [expr $A($year,$paddock,$what) + [set $what]]
            }
         }
      }
      
      foreach what {income expenditure interest_paid interest_earned} {
         if {$paddock == {} && 
             [info exists $what] && 
             [string is double -strict [set $what]]} {
            if {![info exists A($year,farm_$what)]} {
               set A($year,farm_$what) [set $what]
            } else {
               set A($year,farm_$what) [expr $A($year,farm_$what) + [set $what]]
            }
         }

         if {$paddock == "livestock" && 
             [info exists $what] && 
             [string is double -strict [set $what]]} {
            if {![info exists A($year,livestock_$what)]} {
               set A($year,livestock_$what) [set $what]
            } else {
               set A($year,livestock_$what) [expr $A($year,livestock_$what) + [set $what]]
            }
         }

      }
   }
   close $fp
   
   set paddocks [lsort $paddocks]
   
   #2. Write annual cash flow summary
   set fp [open $config(economics,annualSummaryName) w]

   foreach year $years {puts -nonewline $fp ",Year $year"}
   puts $fp "\nCrop income"
   foreach paddock $paddocks {
      puts -nonewline $fp "Paddock $paddock"
      foreach year $years {
         if {[info exists A($year,$paddock,crop_income)]} {
            puts -nonewline $fp ",[format "%.0f" $A($year,$paddock,crop_income)]"
         } else {
            puts -nonewline $fp ","
         }
      }
      puts $fp ""
   }
   
   puts -nonewline $fp "Livestock income"
   foreach year $years {
      if {[info exists A($year,livestock_income)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,livestock_income)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   puts -nonewline $fp "Other farm income"
   foreach year $years {
      if {[info exists A($year,farm_income)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,farm_income)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   puts -nonewline $fp "Interest Earned"
   foreach year $years {
      if {[info exists A($year,farm_interest_earned)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,farm_interest_earned)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   
   puts -nonewline $fp "Total income"
   foreach year $years {
      set sum 0.0
      foreach {name value} [array get A $year,*income] {
         set sum [expr $sum + $value]
      }   
      puts -nonewline $fp ",[format %.0f $sum]"
      set A($year,total_income) $sum
   }
   puts $fp "\n"
   
   puts $fp "Variable expenses"
   foreach what {incrop_cost fallow_cost} {
      foreach paddock $paddocks {
         puts -nonewline $fp "Paddock $paddock $what"
         foreach year $years {
            if {[info exists A($year,$paddock,$what)]} {
               puts -nonewline $fp ",[format "%.0f" $A($year,$paddock,$what)]"
            } else {
               puts -nonewline $fp ","
            }
         }
         puts $fp ""
      }
   }
   puts -nonewline $fp "Livestock expenses"
   foreach year $years {
      if {[info exists A($year,livestock_expenditure)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,livestock_expenditure)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   puts -nonewline $fp "Other expenses"
   foreach year $years {
      if {[info exists A($year,farm_expenditure)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,farm_expenditure)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   
   puts -nonewline $fp "Interest Paid"
   foreach year $years {
      if {[info exists A($year,farm_interest_paid)]} {
         puts -nonewline $fp ",[format "%.0f" $A($year,farm_interest_paid)]"
      } else {
         puts -nonewline $fp ","
      }
   }
   puts $fp ""
   
   puts -nonewline $fp "Total expenses"
   foreach year $years {
      set sum 0.0
      foreach {name value} [array get A $year,farm_expenditure] {
         set sum [expr $sum + $value]
      }   
      foreach {name value} [array get A $year,*cost] {
         set sum [expr $sum + $value]
      }   
      puts -nonewline $fp ",[format %.0f $sum]"
      set A($year,total_expenses) $sum
   }
   puts $fp "\n"

   puts -nonewline $fp "Annual Surplus/Deficit"
   foreach year $years {
      set sum [expr $A($year,total_income) - $A($year,total_expenses)]
      set A($year,surplus) $sum
      puts -nonewline $fp ",[format %.0f $sum]"
   }
   puts $fp "\n"

   puts -nonewline $fp "Cumulative Cash Flow"
   set year [expr [lindex $years 0]-1]
   set A($year,balance) $config(initialBalance)
   foreach year $years {
      set A($year,balance) [expr $A([expr $year-1],balance) + $A($year,surplus)]
      puts -nonewline $fp ",[format %.0f $A($year,balance)]"
   }
   puts $fp "\n"

   close $fp
}

# apsim 'strings' are returned as arrays of strings and may need this
proc unlist {list} {
   if {[llength $list] == 1} {return [lindex $list 0]}
   return $list
}

########################## End apsim interface code

apsimWriteToSummaryFile "     Cashbook initialised."
apsimWriteToSummaryFile ""


set config(economics,icapital,ivalue) "1"
set config(economics,icapital,loanRate) "6.0"
set config(economics,icapital,loanDuration) "50"
          
set runTitle [unlist [apsimGet title]]

if {"yes" != "no"} {
   set config(economics,outputfp) [open $runTitle.cashBook.csv w]
   puts $config(economics,outputfp) "date,income,expenditure,balance,comment"
}

if {"summaryfile" != "no"} {
   set config(economics,cashSummaryName) "$runTitle.cashSummary.csv"
   set config(economics,summaryfp) [open $config(economics,cashSummaryName) w]
   puts $config(economics,summaryfp) "date,paddock,area,crop,yield,protein,fertiliser_type,fertiliser_rate,\
interim_rainfall,interim_runoff,interim_drainage,\
interim_soil_loss,SW_state,NO3_state,fallow_cost,incrop_cost,crop_income,interest_paid,expenditure,income,comment"

   set config(economics,annualSummaryName) "$runTitle.cashSummary.Annual.csv"
   file delete -force $config(economics,annualSummaryName)
}

set config(initialBalance) "42000"

          
set config(economics,cropprice,wheat) "180.0"
set config(economics,cropprice,wheat,protein) "12.0"
set config(economics,cropprice,sorghum) "140.0"
set config(economics,cropprice,chickpea) "350.0"
set config(economics,cropprice,weed) "0.0"
set config(economics,cropprice,maize) "0.0"
          
set config(economics,overheads) [expr 5000.0 + 500.0 \
  + 500.0 + 2000.0 + 0.0 + 10000.0 + 6000.0 \
  + 5000.0 + 3500.0 + 20000.0 + 1000.0 + 2500.0 + 50000.0 \
  + 0.0 + 30000.0 ]
          
set config(economics,fuelcosts,fuelcosts) "1.0"
          
set config(economics,fertilisercost,map) "0.56"
set config(economics,fertilisercost,starter_z) "0.62"
set config(economics,fertilisercost,urea) "0.6"
set config(economics,fertilisercost,no3_n) "1.0"
          
set config(economics,herbicide,roundup) "7.64"
set config(economics,herbicide,mcpalve) "5.0"
set config(economics,herbicide,ally) "0.2"
set config(economics,herbicide,amicide625) "5.5"
set config(economics,herbicide,simazine) "5.5"
          
set config(economics,insecticide,larvinlv) "27.97"
set config(economics,insecticide,steward) "85.36"
          
set config(economics,seedcost,weed) "0.0"
set config(economics,seedcost,barley) "0.78"
set config(economics,seedcost,chickpea) "1.1"
set config(economics,seedcost,cotton) "5.6"
set config(economics,seedcost,foragesorghum) "3.96"
set config(economics,seedcost,lucerne) "5.45"
set config(economics,seedcost,maize) "8.4"
set config(economics,seedcost,millet) "8.4"
set config(economics,seedcost,mungbean) ""
set config(economics,seedcost,sorghum) "5.8"
set config(economics,seedcost,wheat) "0.9"
          
set config(economics,harvesting,generic) "250.0"
          
     --->Section: start_simulation

set balance "42000"
apsimWriteToSummaryFile "     Initial Balance = $balance"
          
     --->End
          Cashbook initialised.
     
Machinery: 
     --->Section: init

# Apsim Machinery (sub)Module
# Contains Tractors, Implements & Labour.

# Operations: 
# bool available(<config>)    ; See if a configuration can be used today (read)
# operate <config> <area>     ; Operate a configuration over an area until finished (event)

########################## Apsim interface code here
source $apsuite/Model/TclLink/CIDataTypes.tcl

# A trace handler for status. This handler is called whenever another module 
# asks us whether machinery is available.
#    NB. Careful! Errors in trace routines are not caught!!!
proc machinery:maProc {name1 name2 op} {
   if {$op == "read" } {
      global config $name1
      foreach {junk tractor implement} [split $name1 "_"] { break }

      # Check they are known to us
      if {[lsearch $config(tractors) $tractor] < 0} {
         set msg "tractor \"$tractor\" is unknown - I only know about $config(tractors)"
         error $msg
      }
      if {[lsearch $config(implements) $implement] < 0} {
         set msg "implement \"$implement\" is unknown - I only know about $config(implements)"
         error $msg
      }
      
      # Now see if they are busy
      set avail 1
      catch {
         global machinery:jobs
         foreach job ${machinery:jobs} {
            foreach {tid iid area paddock costtype} [split $job ","] {break}
            if {"$tractor" == "$tid" || "$implement" == "$iid"} {set avail 0}
         }
      } msg
      if {$msg != ""} {apsimWriteToSummaryFile $msg; error $msg}
           
      # Set the variable - this is what is returned to apsim.
      set $name1 $avail
   }  
}

# An event handler. 
proc machinery:operateHandler {args} {
  global incomingVariant
  foreach {name value} [unpack_Variant $incomingVariant] {
     regsub -all "'" $name {} name
     regsub -all "'" $value {} value
     set [string tolower $name] [string tolower $value]
  }
  if {![info exists tractor] || ![info exists implement] || ![info exists area]} {
     error "Must specify a tractor, implement, and area to operate over."
  }
  if { ![info exists paddock] } {set paddock {}}
  if { ![info exists costtype] } {set costtype unknown}
  machinery:operate $tractor $implement $area $paddock $costtype
}

# Now register the event handlers. 
apsimSubscribeVariant operate            "machinery:operateHandler"
apsimSubscribeNull process            "machinery:process"
apsimSubscribeNull end_financial_year "machinery:end_year"
########################## End apsim interface code

########################## Machinery configuration code
# Read in our configuration
proc machinery:initialise {} {
   global config
   if {![info exists config(tractors)]} {set config(tractors) {}}
   if {![info exists config(implements)]} {set config(implements) {}}
} 


# return the work rate for this combo can cover per hour
proc getCombo {tractor implement thing} {
   global config
   if {![info exists config(machinery,$tractor,$implement,$thing)]} {
      foreach {n v} [array get config machinery*] {apsimWriteToSummaryFile "$n=$v"}
      error "No $thing specified for $tractor and $implement"
   }
   return $config(machinery,$tractor,$implement,$thing)
}

proc getRate {tid iid} {
   return [getCombo $tid $iid fuelrate]
}

proc getValue {id thing} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (get)"
   }
   return $config(machinery,$id,$thing)
}

# Return the cost of fuel per liter
proc fuelCost {} {
   global config
   if {![info exists config(machinery,fuelcost)]} {
      error "No fuelcost specified"
   }
   return $config(machinery,fuelcost)
}

# return the fuel cost this combo uses per hour 
proc getFuelCost {tid iid} {
   return [expr [getCombo $tid $iid fuelrate] * [fuelCost]]
}

# Return the number of hours worked per day
proc getHoursPerDay {tid iid} {
   return [getCombo $tid $iid hoursperday]
}

proc setValue {id thing value} {
   global config
   if {![info exists config(machinery,$id,$thing)]} {
      error "No $thing for $id specified (set)"
   }
   set config(machinery,$id,$thing) $value
}

##############
# Operate a configuration over an area. Just add it to the job queue 
# and let process look after it.
proc machinery:operate {tractor implement area paddock costtype} {
   if {![string is double -strict $area]} {
      error "Area should be a number (not $area)"
   }
   global machinery:jobs
   lappend machinery:jobs $tractor,$implement,$area,$paddock,$costtype
   apsimWriteToSummaryFile "Machinery job \"$tractor + $implement\" is queued"
}

# The daily process routine. Manages the job queue
proc machinery:process {} {
   global machinery:jobs
   set tomorrowsJobs {}
   # Go through each job. If an item is in use in any prior job, we can't do it today. 
   for {set ijob 0} {$ijob < [llength ${machinery:jobs}]} {incr ijob} {
      set job [lindex ${machinery:jobs} $ijob]
      foreach {tid iid area paddock costtype} [split $job ","] {break}
      set inuse 0
      for {set j 0} {$j < $ijob} {incr j} {
         foreach {Ttid Tiid Tarea Tpaddock Tcosttype} [split [lindex ${machinery:jobs} $j] ","] {break}
         if {$tid == $Ttid || $iid == $Tiid} {set inuse 1}
      }
      if {!$inuse} {
        # The job is running today. Work out how many hours, and then the costs
        set maxHours [getHoursPerDay $tid $iid]
        set rate [getRate $tid $iid]

        if {$maxHours * $rate <= $area} {
           set hours $maxHours
           set areaToday [expr $maxHours * $rate]
        } else {   
           set hours [expr $area / $rate]
           set areaToday [expr $hours * $rate]
        }   
        #apsimWriteToSummaryFile "hours='$hours', rate='$rate',cost='[getFuelCost $tid $iid]',oil='[getValue $tid oil]',paddock='$paddock',costtype=$costtype"
        set cost [expr $hours * [getFuelCost $tid $iid] * (1.0 + [getValue $tid oil]/100.0)]
        apsimSendMessage "" expenditure [list cost $cost] [list comment "fuel & oil costs of $tid + $iid"] [list paddock $paddock] [list area $areaToday] [list $costtype {}]

        set cost [expr $hours * [getValue $tid newPrice] * ([getValue $tid repairs]/100.0)/ [getValue $tid lifeOfEquipment]] 
        apsimSendMessage "" expenditure [list cost $cost] [list comment "Repairs & maintenance of $tid"] [list paddock $paddock] [list area $areaToday] [list $costtype {}]

        set cost [expr $hours * [getValue $iid newPrice] * ([getValue $iid repairs]/100.0)/ [getValue $iid lifeOfEquipment]] 
        apsimSendMessage "" expenditure [list cost $cost] [list comment "Repairs & maintenance of $iid"] [list paddock $paddock] [list area $areaToday] [list $costtype {}]

        set rate [expr $hours * [getRate $tid $iid]]
        set area [expr $area - $rate]
        setValue $tid age [expr $hours + [getValue $tid age]]
        setValue $iid age [expr $hours + [getValue $iid age]]

        if {$area > 0} {
           lappend tomorrowsJobs $tid,$iid,$area,$paddock,$costtype
        } else {
           apsimWriteToSummaryFile "Machinery job '$tid + $iid' in $paddock has finished"
        }
      } else {
        lappend tomorrowsJobs $job
      } 
   }
   set machinery:jobs $tomorrowsJobs
}

# The "end_year" routine. Do loan payments and replacement
proc machinery:end_year {} {
   global config
   foreach id [concat $config(tractors) $config(implements)] {
     if {$config(machinery,$id,loanInterestRate) > 0.0} {
        if {$config(machinery,$id,loanDuration) > 0} {
           if {$config(machinery,$id,age) >= $config(machinery,$id,lifeOfEquipment)} {
              set newPrice $config(machinery,$id,newPrice)
              set salvage [expr $config(machinery,$id,tradeInValue)/100.0 * $newPrice]
              set loanValue [expr $newPrice - $salvage]
              apsimWriteToSummaryFile "Establishing new loan of \$$loanValue for $id (new price \$$newPrice, salvage \$$salvage)"
              set config(machinery,$id,loanValue) $loanValue
              set config(machinery,$id,age) 0
              set config(machinery,$id,loanPeriod) 1
           } else {
              if {$config(machinery,$id,loanPeriod) <=  $config(machinery,$id,loanDuration)} {
                 #A = P(i(1+i)^n)/((1+i)^n - 1)
                 set P $config(machinery,$id,newPrice) 
                 set i [expr $config(machinery,$id,loanInterestRate)/100.0]
                 set n $config(machinery,$id,loanDuration)
                 set A [expr $P * ($i*pow(1+$i,$n))/(pow(1.0+$i,$n) - 1.0) ]
                 apsimSendMessage "" expenditure [list cost $A] [list interest_paid $A] [list comment "Loan repayments for $id"]
                 
                 set config(machinery,$id,loanPeriod) [expr 1 + $config(machinery,$id,loanPeriod)]
                 if { $config(machinery,$id,loanPeriod) >  $config(machinery,$id,loanDuration) } {
                     apsimWriteToSummaryFile "Loan for $id is finished"
                 }
              }
           }
        }
     }    
   }  
}

lappend config(tractors) "tractor1"
set config(machinery,tractor1,newPrice) "100000.0"
set config(machinery,tractor1,tradeInValue) "15"
set config(machinery,tractor1,lifeOfEquipment) "3000"
set config(machinery,tractor1,insuranceRate) "6.2"
set config(machinery,tractor1,repairs) "30"
set config(machinery,tractor1,oil) "10"
set config(machinery,tractor1,loanInterestRate) "7"
set config(machinery,tractor1,loanDuration) "50"
set config(machinery,tractor1,age) "2"

set config(machinery,tractor1,sprayrig,fuelrate) "30.0"
set config(machinery,tractor1,sprayrig,workrate) "20.0"
set config(machinery,tractor1,sprayrig,hoursperday) "16"

set config(machinery,tractor1,planter,fuelrate) "40.0"
set config(machinery,tractor1,planter,workrate) "8.12"
set config(machinery,tractor1,planter,hoursperday) "16"


lappend config(implements) "planter"
set config(machinery,planter,newPrice) "150000.0"
set config(machinery,planter,tradeInValue) "20"
set config(machinery,planter,lifeOfEquipment) "1500"
set config(machinery,planter,insuranceRate) "2.3"
set config(machinery,planter,repairs) "30"
set config(machinery,planter,oil) "0"
set config(machinery,planter,loanInterestRate) "4.5"
set config(machinery,planter,loanDuration) "50"
set config(machinery,planter,age) "200"


lappend config(implements) "sprayrig"
set config(machinery,sprayrig,newPrice) "100000.0"
set config(machinery,sprayrig,tradeInValue) "20"
set config(machinery,sprayrig,lifeOfEquipment) "1500"
set config(machinery,sprayrig,insuranceRate) "2.3"
set config(machinery,sprayrig,repairs) "30"
set config(machinery,sprayrig,oil) "0"
set config(machinery,sprayrig,loanInterestRate) "4.5"
set config(machinery,sprayrig,loanDuration) "50"
set config(machinery,sprayrig,age) "200"


     --->Section: start_simulation


# Finally, load our configuration database and initialise states
machinery:initialise 
set machinery:jobs {}

# Set the current period of the loan to 1 past its end
foreach id [concat $config(tractors) $config(implements)] {
   set config(machinery,$id,loanPeriod) [expr 1 + $config(machinery,$id,loanDuration)]
}

# Now tell apsim we own it, set up the trace variable we use to trigger when the variable is read
foreach tid $config(tractors) {
  foreach iid $config(implements) {
     set v available_${tid}_${iid}
     set $v 0
     apsimRegisterGetSet $v
     trace add variable $v read "machinery:maProc"
  }
}

apsimWriteToSummaryFile "Machinery:\nTractors=$config(tractors)\nImplements=$config(implements)"


     --->End
Farm Manager: 
     --->Section: end_simulation

close_ef_stuff


closeLogging

     --->Section: init


# apsim 'strings' are returned as arrays of strings and may need this
proc unlist {list} {
   if {[llength $list] == 1} {return [lindex $list 0]}
   return $list
}

set simName  [unlist [apsimGet title]]
apsimWriteToSummaryFile "title = $simName"

# Initial conditions
set myName  "FarmManager"
source $apsuite/UserInterface/APSFarm/FarmManager.tcl

set paddocks [list toplevel p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 ]
set config(cropPaddocks)    [list p1 p2 p3 p4 p5 p6 p7 p8 p9 p10]
set config(foragePaddocks)  {}

set config(toplevel,graphNames)  {}

foreach p $config(cropPaddocks) {
   set config($p,graphNames)  stateGraph
   set config($p,area)        300.0
   set weeds($p,Events)       0                      ;# number of weed germination events
   set weeds($p,GermDay)      {}                     ;# date of next weed spraying

   foreach {accumulator} {runoff drain soil_loss es} {
      set $p.$accumulator 0.0
   }
}

set accRain 0.0

foreach p $paddocks {
  set config($p,watBal)   ".masterpm.$p.Soil Water"
  set config($p,nModule)  ".masterpm.$p.Soil Nitrogen"
}


# Initialisation for MCA

   # Delete any old logfile so we dont get confused..
   catch {file delete -force $simName.log}

   # The 10 day rainfall accumulator - should be the 10 days of rain prior to start of simulation
   set rainList {0.2 1.0 0 0 0 0 15 12 0 0 0 0}

   # A list of variables to report from each paddock on each "event"
   set reportVariables [list esw no3() ]

   # Crop variables - name/event/value triplets
   set reportCropVariables [list sorghum  harvest yield \
                                 wheat    harvest yield \
                                 chickpea harvest yield]

   # Manager variables to report from each paddock on each "event"
   set reportManagerVariables [list weeds(Events) annRunoff annDrain annSoil_loss annEvap annRain state]

# Defaults for a lot of things.
# we use this table to build a list of "name/value" pairs that get fed into
# sow/fertiliser commands etc.
# ***Check the summary file for what it uses, search other files for "gatherArgs"
   set defaults(sow,sowing_depth)              30
   set defaults(fertiliser,calcMethod)         targetN
   set defaults(fertiliser,depth)              50
   set defaults(fertiliser,type)               urea

   set defaults(wheat,sow,cultivar)              Sunvale
   set defaults(Sf_earlyWheat,sow,cultivar)      Sunbri
   set defaults(Lf_earlyWheat,sow,cultivar)      Sunbri
   set defaults(lateWheat,sow,cultivar)          Sunstate
   set defaults(wheat,sow,plants)                100       ;# plants per sq mt established
   set defaults(wheat,fertiliser,amount)         140       ;# kg urea/ha
   set defaults(Lf_earlyWheat,fertiliser,amount) 180       ;# kg urea/ha
   set defaults(Lf_Wheat,fertiliser,amount)      180       ;# kg urea/ha
    
   # (same as chickpea)
   set defaults(wheat,sowingCosts)             {{category seedcost    name Wheat            rate 60  comment  "Wheat seed"} 
                                                {category fertilisercost  name map              rate 20  comment  "Wheat MAP starter"} 
                                                {category herbicide name "MCPALVE"       rate 0.5 comment  "Wheat mcpa starter"}
                                                {category herbicide name "Ally"           rate 5   comment  "Wheat metsulfuran starter"}}

   set defaults(wheat,harvestingCosts)         {{category harvesting   name generic          rate 0.16666  comment  "Wheat contract harvest"} 
                                                {category fuelcosts  name fuelcosts        rate 8.1      comment  "Wheat contract harvest fuel"}}

   set defaults(sorghum,sow,cultivar)             medium
   set defaults(Lf_earlySorghum,sow,cultivar)     late
   set defaults(Sf_earlySorghum,sow,cultivar)     late
   
   set defaults(sorghum,sow,tiller_no_fertile)     0
   set defaults(sorghum,sow,skip)                  "single"
   set defaults(sorghum,sow,region)                "SQ"
   set defaults(sorghum,sow,row_spacing)            1.0
   set defaults(sorghum,sow,plants)                 4.0
   set defaults(Sf_earlySorghum,sow,plants)         4.5
   set defaults(Lf_earlySorghum,sow,plants)         4.5
   
   set defaults(Sf_Sorghum,fertiliser,amount)       140
   set defaults(Sf_earlySorghum,fertiliser,amount)  140
   set defaults(sorghum,fertiliser,amount)          180
   set defaults(sorghum,sowingCosts)           {{category seedcost   name sorghum   rate 4 comment "Sorghum seed"}
                                                 {category fertilisercost  name starter_z   rate 30  comment  "Sorghum Starter_z"}}
## NBNB needs atrazine @3.5lt/ha in wet seasons
   set defaults(sorghum,harvestingCosts)       {{category harvesting   name generic         rate 0.16666 comment  "Sorghum contract harvest"} 
                                                {category herbicide  name Roundup         rate 1.5     comment  "Sorghum spray out"} 
                                                {category fuelcosts  name fuelcosts       rate 8.1     comment  "Sorghum contract harvest fuel"}}

   set defaults(CoverCrop,fertiliser,amount)   0
   
   set defaults(chickpea,sow,cultivar)         amethyst
   set defaults(chickpea,sow,plants)           30
   set defaults(chickpea,fertiliser,amount)    0
   set defaults(chickpea,sowingCosts)          {{category seedcost    name Chickpea         rate 45   comment "Chickpea Seed"}              
                                                {category herbicide   name Roundup          rate 1.3  comment "Pre plant roundup"}
                                                {category herbicide   name Amicide625       rate 0.2  comment "Pre plant 2,4D"} 
                                                {category herbicide   name "simazine"     rate 1.1    comment "Post Simazine"}
                                                {category insecticide name "LarvinLV"    rate 0.75   comment "Insecticide"}
                                                {category fertilisercost  name starter_z   rate 50  comment  "Ckpea Starter_z"}}
                                                
   set defaults(chickpea,harvestingCosts)      {{category harvesting    name generic        rate 0.1851 comment  "Chickpea contract harvest"} 
                                                {category fuelcosts   name fuelcosts      rate 9.0    comment  "Chickpea contract harvest fuel"}}

   set defaults(weed,sow,cultivar)             late
   set defaults(weed,sow,plants)               15
   set defaults(weed,sow,crop_class)           summer_grass
   set defaults(weed,fertiliser,amount)        0

   set defaults(sow,tractor)                   'tractor_1'
   set defaults(sow,implement)                 'planter'
   set defaults(spray,tractor)                 'tractor_1'
   set defaults(spray,implement)               'spray_rig'  ;# this is spray rig
   set defaults(herbicide,spray,name)          "Roundup"

   set config(CoverCrop,alias) weed
   set config(Lf_earlySorghum,alias) sorghum
   set config(Sf_earlySorghum,alias) sorghum
   set config(Lf_Sorghum,alias) sorghum
   set config(Sf_Sorghum,alias) sorghum
   set config(Sf_earlyWheat,alias) wheat
   set config(Lf_earlyWheat,alias) wheat
   set config(Sf_Wheat,alias) wheat
   set config(Lf_Wheat,alias) wheat
   set config(lateWheat,alias) wheat

   set crops {sorghum wheat chickpea}

# Initial conditions for each paddock
set config(p1,initialState)         Fallow
set config(p1,history)              {sorghum sorghum}
set config(p1,daysSinceLastHarvest) 365              ;# A long time
set config(p2,initialState)         Fallow
set config(p2,history)              {wheat sorghum}
set config(p2,daysSinceLastHarvest) 365              ;# A long time
set config(p3,initialState)         Fallow
set config(p3,history)              {wheat wheat}
set config(p3,daysSinceLastHarvest) 365              ;# A long time
set config(p4,initialState)         Fallow
set config(p4,history)              {wheat maize}
set config(p4,daysSinceLastHarvest) 365              ;# A long time
set config(p5,initialState)         Fallow
set config(p5,history)              {maize maize}
set config(p5,daysSinceLastHarvest) 365              ;# A long time
set config(p6,initialState)         Fallow
set config(p6,history)              {sorghum sorghum}
set config(p6,daysSinceLastHarvest) 365              ;# A long time
set config(p7,initialState)         Fallow
set config(p7,history)              {wheat sorghum}
set config(p7,daysSinceLastHarvest) 365              ;# A long time
set config(p8,initialState)         Fallow
set config(p8,history)              {wheat wheat}
set config(p8,daysSinceLastHarvest) 365              ;# A long time
set config(p9,initialState)         Fallow
set config(p9,history)              {wheat maize}
set config(p9,daysSinceLastHarvest) 365              ;# A long time
set config(p10,initialState)         Fallow
set config(p10,history)              {maize maize}
set config(p10,daysSinceLastHarvest) 365              ;# A long time

foreach p $config(cropPaddocks) {
   set state($p)   $config($p,initialState)
   set history($p) $config($p,history)
   set daysSinceLastHarvest($p) 60
}

set state(toplevel) {}
set daysSinceLastHarvest(toplevel) 0



# Return our reluctance to plant sorghum in the current paddock
#  - no more than 3 in a row.
proc sorghumHistory {paddock} {
   global history 
   if {"[lindex $history($paddock) end]" == "sorghum" &&
       "[lindex $history($paddock) end-1]" == "sorghum"} {
      return 0 ;# 2 in a row - no more.
   }
   return 1
}

# Last crop was a failed sorghum crop
## XXX WRONG - should be 1 only if the last sorghum crop failed
proc covercropHistory {paddock} {
   global history
   if {"[lindex $history($paddock) end]" == "sorghum"} {return 1}
   return 0
}

# Return our "reluctance" to plant wheat
proc wheatHistory {paddock} {
   global history
   if {"[lindex $history($paddock) end]" == "wheat" &&
       "[lindex $history($paddock) end-1]" == "wheat"} {
       return 0   ;# 2 in a row - no more.
   }
   return 1
}
# Return our "reluctance" to plant chickpea
proc chickpeaHistory {paddock} {
   global history
   if {[lindex $history($paddock) end] == "chickpea" } {
      return 0   ;# no more than 1 crop
   }
   return 1
}

proc getEsw {paddock} {
   global config
   return [apsimGetOptional $config($paddock,watBal).esw]
}


proc mseek2 {paddock} {
   global config
   set ll2   [lindex [apsimGet $config($paddock,watBal).ll15] 1] 
   set swat2 [lindex [apsimGet $config($paddock,watBal).sw] 1]
   set dul2  [lindex [apsimGet $config($paddock,watBal).dul] 1]
   return [expr (($swat2-$ll2)/($dul2-$ll2))]
}


proc getCover {paddock} {
   global config
   return [apsimGetOptional "$paddock.surface organic matter.surfaceom_cover"]
}

proc sprayChickpeas {paddock} {
   global defaults config
   apsimWriteToSummaryFile "spraying Chickpeas"

   apsimSendMessage economics expenditure \
             {category insecticide} {name Steward} \
             "rate 0.3" "area $config($paddock,area)"  \
             "paddock $paddock" {incrop_cost {}} \
             "crop [currentState $paddock]"     
   apsimSendMessage economics operate \
             "tractor $defaults(spray,tractor)" "implement $defaults(spray,implement)" \
             {category insecticide} {name Steward} \
             "rate 0.3" "area $config($paddock,area)"  "paddock $paddock" {incrop_cost {}} 
}


proc genericCosts {args} {

   # {{category seedcost} {name cotton} {rate 3.5} {Comment "blah blah"}} ...
   foreach {junk items} [concat [array get defaults $crop,sowCosts] [array get defaults $realCrop,sowCosts]]  {
      foreach item $items {
         eval apsimSendMessage economics expenditure \
                    [mash [concat $item area $area  \
                    paddock $paddock incrop_cost {} 
      }
   }
}

proc machineryAvailable {what} {
   return [apsimGet available_$what]
}



proc do_end_financial_year {} {
   global config ef

   set year [apsimGet year]

   foreach {accumulator} {runoff drain soil_loss es} {
     foreach paddock $config(cropPaddocks) {
        global $paddock.$accumulator
        set ef($year,$paddock,$accumulator) [set $paddock.$accumulator]
     }
   }
   global accRain
   set ef($year,accRain) $accRain
   set ef($year,balance) [apsimGet balance]
   lappend ef(years) $year
}

# EF - used to be "end of financial" but has a lot more now.
proc open_ef_stuff {} {
   global ef

   set year [expr [apsimGet year] - 1 ]
   set ef(years) $year
   set ef($year,balance) [apsimGet balance] 
   set ef(states) {}
   set ef(rules) {}
}

proc close_ef_stuff {} {
   global simName config ef

   # Heading
   set fp [open $simName.financial.csv w]
   puts -nonewline $fp "year"
   foreach {accumulator} {runoff drain soil_loss es rain} {
      puts -nonewline $fp ",$accumulator"
   }
   foreach state $ef(states) {
      if {$state != {}} {
        puts -nonewline $fp ",$state"
      }
   }
   puts $fp ",profit"

   # Area weighted averages of environmental stuff
   set tfa 0.0
   foreach paddock $config(cropPaddocks) {set tfa [expr $tfa + $config($paddock,area)]}
   
   foreach year [lrange $ef(years) 2 end] {
      puts -nonewline $fp "$year"
      foreach {accumulator} {runoff drain soil_loss es} {
         set s 0.0
         foreach paddock $config(cropPaddocks) {
            set s [expr $s + $ef($year,$paddock,$accumulator) * $config($paddock,area) / $tfa]
         }
         puts -nonewline $fp ",$s"
      }
      puts -nonewline $fp ",$ef($year,accRain)"

      # Number of "state transitions" made in each year
      foreach state $ef(states) {
         if {$state != {}} {
            if {[info exists ef($year,$state)]} {
              puts -nonewline $fp ",$ef($year,$state)"
            } else {
              puts -nonewline $fp ",0"
            }  
         }
      }

      # profit = change in bank balance each year
      puts -nonewline $fp ",[expr $ef($year,balance) - $ef([expr $year-1],balance)]"
      puts $fp ""
   }
   close $fp
   
   # per-crop yields etc..
   foreach state $ef(states) {
     if {$state != {}} {
         set fp [open $simName.$state.csv w]
         if {[info exists ef($state,yield)]} {
            foreach yield $ef($state,yield) {
               puts $fp $yield
            }   
         }  
         close $fp
      }   
   }

   # Finally the rule "failures"
}
# Newer version of weed germination - spray 2 weeks after a {germination event & swCrit & temp}.
proc checkWeeds {} {
   global daysSinceLastHarvest weeds paddocks config

   foreach paddock $paddocks {
      if {$paddock != "toplevel" &&
          ([currentState $paddock] == "Fallow" ) && 
          $daysSinceLastHarvest($paddock) > 30} {

         if {$weeds($paddock,GermDay) == {} && [sumLastRain 4] >= 30} {
            set weeds($paddock,GermDay) [apsimGet day]
            set weeds($paddock,tt) 0.0
            apsimWriteToSummaryFile "Weeds germinating in $paddock"

         } elseif {$weeds($paddock,GermDay) != {}} {
            # Thermal time calc
            set weeds($paddock,tt) [expr $weeds($paddock,tt) + ([apsimGet maxt] + [apsimGet mint])/2.0]
         
            # Surface SW calc
            set ll [lindex [apsimGet $config($paddock,watBal).ll15] 0];
            set sw [lindex [apsimGet $config($paddock,watBal).sw] 0]
            set dul [lindex [apsimGet $config($paddock,watBal).dul] 0]
            set swf [expr (($sw-$ll)/($dul-$ll))]
            if {$swf < 0.5} {
               # kill off weeds
               set weeds($paddock,GermDay) {}
               apsimWriteToSummaryFile "Weeds die in $paddock"
         
            } elseif {$weeds($paddock,tt) > 250.0} {
               # Weeds are mature - spray them
               incr weeds($paddock,Events)
               eval apsimSendMessage economics operate [mash [concat [gatherArgs spray herbicide] \
                      area $config($paddock,area)  paddock $paddock  costtype fallow_cost]]

               apsimSendMessage economics expenditure "category herbicide" "name Roundup" \
                         "rate 5" "area $config($paddock,area)"  \
                         "paddock $paddock" {fallow_cost {}} \
                         {comment "Roundup weeds"}
               apsimWriteToSummaryFile "Weeds mature in $paddock - sprayed out."
         
               set weeds($paddock,GermDay) {}
               set weeds($paddock,tt)      0.0
            }
         }
      }   
   }
}
# Rug plotting facility

# 2 areas of interest:
# - logState - called when a graph is changing state, called just after the "actions" have been evaluated

# a logfile is used to generate the rugplots of farm activities. There are 2 parts:
# an xml of paddocks, states & times,
# a binary of decision rules on each evaluation cycle
proc log {msg} {
   #puts $msg
}

package require cdftcl
package require tdom

proc setupLogging {} {
   global simName config paddocks
   set config(paddocks) $paddocks

   # Find the number of graphs - 1 file for each. Delete each.
   set config(graphs) {}
   foreach paddock $config(paddocks) {
     foreach graph $config($paddock,graphNames) {
        if {[lsearch $config(graphs) $graph] < 0} {
           lappend config(graphs) $graph
        }
     }
  }
  foreach graph $config(graphs) {
    apsimWriteToSummaryFile "deleting $simName.$graph.\[xml,nc\]"
    file delete -force $simName.$graph.xml
    file delete -force $simName.$graph.nc
    foreach paddock $config(paddocks) {
       set config(history,$paddock,$graph) {}
    }
  }
  set config(states) {}
  set config(rules) {}
  set config(historyDays) {}
}

# Log a set of rule evaluations
proc logRules {paddock graph rules values } {
   global config

   set data {}
   for {set i 0} {$i < [llength $rules]} {incr i} {
      lappend data [lindex $rules $i] [lindex $values $i]
   }

   set today [apsimGet today]

   lappend config(history,$paddock,$graph,$today) $data

   if {[lsearch $config(historyDays) $today] < 0} {
       lappend config(historyDays) $today
       set config($today,ddmmyyyy) [apsimGet clock.dd/mm/yyyy]
   }
}

# Log a state transition
proc logState {graph paddock state} {
   global config
   set today [apsimGet today]
   lappend config(history,$paddock,$graph) $today $state
   if {[lsearch $config(states) $state] < 0} {lappend config(states) $state}
}

# Write the files. 
proc closeLogging {} {
   global config simName

   package require tdom
   set config(xmldoc) [dom parse [apsimGetComponentXML]]
   set config(docroot) [$config(xmldoc) documentElement]

   foreach graph $config(graphs) {
apsimWriteToSummaryFile "creating $simName.$graph.nc"
      set ncfp [ncdf create $simName.$graph.nc] 
      ncdfdim $ncfp create index [llength $config(historyDays)]
      ncdfdim $ncfp create time -1

      ncdfvar $ncfp create position long {index}
      ncdfvar $ncfp create daynum float {index}

      ncdfvar $ncfp create day     float {time}
      ncdfvar $ncfp create paddock short {time}
      ncdfvar $ncfp create rule    short {time}
      ncdfvar $ncfp create value   float {time}

      set day [lindex $config(historyDays) 0]
      ncdfatt $ncfp GLOBAL put startdate float $day
      ncdfatt $ncfp GLOBAL put startddmmyyyy char $config($day,ddmmyyyy)

      set day [lindex $config(historyDays) end]
      ncdfatt $ncfp GLOBAL put enddate float $day
      ncdfatt $ncfp GLOBAL put endddmmyyyy char $config($day,ddmmyyyy)

      ncdf enddef $ncfp
      set id 0
      foreach p $config(paddocks) {
         set pid($p) $id; incr id
      }   

      set i 0
      foreach day $config(historyDays) {
         foreach paddock $config(paddocks) {
            if {[info exists config(history,$paddock,$graph,$day)]} {
               set pos($paddock,$day) $i
               foreach data $config(history,$paddock,$graph,$day) {
                  foreach {rule value} $data {
                     ncdfvar $ncfp put day     $i $day
                     ncdfvar $ncfp put paddock $i $pid($paddock)
                     ncdfvar $ncfp put rule    $i $rule
                     ncdfvar $ncfp put value   $i $value
                     incr i
                  } 
               }
            }
         }
      }

      #Positions
      for {set i 0} {$i < [llength $config(historyDays)]} {incr i} {
         set day [lindex $config(historyDays) $i]
         set f 0
         foreach paddock $config(paddocks) {
            if {[info exists pos($paddock,$day)]} {
               ncdfvar $ncfp put position  $i $pos($paddock,$day)
               set f 1
               break
            } 
         }
         if {!$f} {
            ncdfvar $ncfp put position  $i -1
         }   
      }
      
      for {set j 0} {$j < [llength $config(historyDays)]} {incr j} {
         ncdfvar $ncfp put daynum $j [lindex $config(historyDays) $j]
      }   

      ncdf close $ncfp

      set fp [open $simName.$graph.xml w]
      puts $fp "<?xml version=\"1.0\" encoding=\"UTF-8\"?><simulation>"
      set id 0
      foreach paddock $config(paddocks) {
         puts $fp "<history id=\"$id\" name=\"$paddock\">"
         foreach {day state} $config(history,$paddock,$graph) {
            if {[info exists pos($paddock,$day)]} {
               puts $fp "<transition day=\"$day\" to=\"$state\" position=\"$pos($paddock,$day)\" />"
            } 
         }
         puts $fp "</history>"
         incr id
      }

      foreach paddock $config(paddocks) {
         puts $fp "<paddock id=\"$pid($paddock)\" name=\"$paddock\" />"
      }   
      set id 0
      foreach rule $config(rules) {
         set rule [string map {\< "&lt;"  \> "&gt;"     
                               \& "&amp;" \" "&quot;"  
                               \[ "&#91;" \] "&#93;"    } $rule]
         puts $fp "<rule id=\"$id\" name=\"$rule\" />"
         incr id
      }

      # Colours
      foreach node [$config(docroot) selectNodes //node] {
          set state [getValue $node "name"]
          set colour [getValue $node "fill"]
          puts $fp "<state name=\"$state\" colour=\"$colour\" />"
      }

      set day [lindex $config(historyDays) 0]
      puts $fp "<startdate ddmmyyyy=\"$config($day,ddmmyyyy)\" day=\"$day\" />"
      set day [lindex $config(historyDays) end]
      puts $fp "<enddate ddmmyyyy=\"$config($day,ddmmyyyy)\" day=\"$day\" />"

      puts $fp "</simulation>"
      close $fp
   }  
   # $config(xmldoc) delete
}

# Override the "standard" decision routine to keep track of state info
proc checkRules {thisPaddock} {
  global config 
  uplevel #0 set paddock $thisPaddock
  set bestScore -1.0; set bestTarget {}; set bestArc {}; set bestGraph {}
  foreach graph $config($thisPaddock,graphNames) {
     foreach arc [$graph arcs -out [currentState $thisPaddock]] {
        set values {}; set rules {}
        set target [$graph arc target $arc]
        if {[$graph arc keyexists $arc window]} {set inWindow [uplevel #0 expr [$graph arc get $arc window]]} else {set inWindow 0}
        foreach rule [$graph arc get $arc rules] {
           set value [uplevel #0 expr $rule]
           lappend values $value
           lappend rules [enCodeRule $target $rule]
        }
        logRules $thisPaddock $graph $rules $values
        if {[llength $values] > 0} {
           set score [expr [join $values "*"]]
           if {$score > $bestScore} {
              set bestScore  $score
              set bestTarget $target
              set bestArc    $arc
              set bestGraph  $graph
           }
        }
     }
  }   
  return [list  $bestScore $bestGraph $bestTarget $bestArc]
}

proc enCodeRule {target ruleText} {
  global config
  regsub -all "\," $ruleText "\-" ruleText

  for {set i 0} {$i < [llength $config(rules)]} {incr i} {
     set rule [lindex $config(rules) $i]
     if {[string equal $rule "$target,$ruleText"]} {
        return $i
     }
  }
  lappend config(rules) "$target,$ruleText"
  return [expr [llength $config(rules)] - 1]
}


# Get the value of an objects 'thing'
proc getValue {id thing} {
   foreach node [$id childNodes] {
      if {[string equal -nocase [$node nodeName] $thing]} {
         return [$node text]
      }
   }
   return ""
}

package require struct
::struct::graph stateGraph
stateGraph node insert "Sf_earlySorghum"
set colour(Sf_earlySorghum) "-6639379"
stateGraph node insert "CoverCrop"
set colour(CoverCrop) "-16744384"
stateGraph node insert "Sf_Sorghum"
set colour(Sf_Sorghum) "-8323073"
stateGraph node insert "Lf_Sorghum"
set colour(Lf_Sorghum) "-16744193"
stateGraph node insert "Sf_earlyWheat"
set colour(Sf_earlyWheat) "-128"
stateGraph node insert "Spray"
set colour(Spray) "-657956"
stateGraph node insert "lateWheat"
set colour(lateWheat) "-8355840"
stateGraph node insert "Chickpea"
set colour(Chickpea) "-12550016"
stateGraph node insert "Sf_Wheat"
set colour(Sf_Wheat) "-32768"
stateGraph node insert "Lf_Wheat"
set colour(Lf_Wheat) "-256"
stateGraph node insert "Lf_earlySorghum"
set colour(Lf_earlySorghum) "-16711681"
stateGraph node insert "Fallow"
set colour(Fallow) "-657956"
stateGraph node insert "Lf_earlyWheat"
set colour(Lf_earlyWheat) "-8323200"
stateGraph arc insert "Sf_earlyWheat" "Fallow" "arc11"
stateGraph arc lappend "arc11" actions {harvestAndEndCrop $paddock wheat}
stateGraph arc lappend "arc11" rules {[canHarvestCrop $paddock wheat]}
stateGraph arc insert "Fallow" "Chickpea" "arc12"
stateGraph arc lappend "arc12" actions {sowCrop $paddock chickpea}
stateGraph arc lappend "arc12" actions {lappend history($paddock) chickpea}
stateGraph arc lappend "arc12" actions {set chickPeaRain($paddock) 0.0}
stateGraph arc lappend "arc12" actions {set numChickSprays($paddock) 0}
stateGraph arc lappend "arc12" rules {[dayWithin 135 151]}
stateGraph arc lappend "arc12" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc12" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc12" rules {[areaPlanted Chickpea] <0.4}
stateGraph arc lappend "arc12" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc12" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc12" rules {[getEsw $paddock]}
stateGraph arc lappend "arc12" rules {[chickpeaHistory $paddock]}
stateGraph arc insert "Chickpea" "Fallow" "arc13"
stateGraph arc lappend "arc13" actions {harvestAndEndCrop $paddock chickpea}
stateGraph arc lappend "arc13" rules {[canHarvestCrop $paddock chickpea]}
stateGraph arc insert "Fallow" "Lf_earlyWheat" "arc14"
stateGraph arc lappend "arc14" actions {sowCrop $paddock Lf_earlyWheat; lappend history($paddock) wheat}
stateGraph arc lappend "arc14" rules {[dayWithin 116 128]}
stateGraph arc lappend "arc14" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc14" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc14" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc14" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc14" rules {[areaPlanted wheat] < 0.5}
stateGraph arc lappend "arc14" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc14" rules {[getEsw $paddock]}
stateGraph arc lappend "arc14" rules {[wheatHistory $paddock]}
stateGraph arc insert "Lf_earlyWheat" "Fallow" "arc15"
stateGraph arc lappend "arc15" actions {harvestAndEndCrop $paddock wheat}
stateGraph arc lappend "arc15" rules {[canHarvestCrop $paddock wheat]}
stateGraph arc insert "Chickpea" "Spray" "arc16"
stateGraph arc lappend "arc16" actions {sprayChickpeas $paddock}
stateGraph arc lappend "arc16" actions {set numChickSprays($paddock) 1}
stateGraph arc lappend "arc16" rules {[set chickPeaRain($paddock) [expr $chickPeaRain($paddock) + [apsimGet rain]]] > 150}
stateGraph arc lappend "arc16" rules {$numChickSprays($paddock) == 0}
stateGraph arc insert "Fallow" "Sf_Wheat" "arc0"
stateGraph arc lappend "arc0" actions {sowCrop $paddock Sf_Wheat; lappend history($paddock) wheat}
stateGraph arc lappend "arc0" rules {[dayWithin 129 152]}
stateGraph arc lappend "arc0" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc0" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc0" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc0" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc0" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc0" rules {[areaPlanted wheat]  <0.8}
stateGraph arc lappend "arc0" rules {[getEsw $paddock]}
stateGraph arc lappend "arc0" rules {[wheatHistory $paddock]}
stateGraph arc insert "Spray" "Chickpea" "arc17"
stateGraph arc lappend "arc17" actions {}
stateGraph arc lappend "arc17" rules {1}
stateGraph arc insert "Fallow" "Lf_Wheat" "arc18"
stateGraph arc lappend "arc18" actions {sowCrop $paddock Lf_Wheat; lappend history($paddock) wheat}
stateGraph arc lappend "arc18" rules {[dayWithin 129 152]}
stateGraph arc lappend "arc18" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc18" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc18" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc18" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc18" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc18" rules {[areaPlanted wheat]  <0.8}
stateGraph arc lappend "arc18" rules {[getEsw $paddock]}
stateGraph arc lappend "arc18" rules {[wheatHistory $paddock]}
stateGraph arc insert "Sf_Wheat" "Fallow" "arc1"
stateGraph arc lappend "arc1" actions {harvestAndEndCrop $paddock wheat}
stateGraph arc lappend "arc1" rules {[canHarvestCrop $paddock wheat]}
stateGraph arc insert "Fallow" "Sf_earlySorghum" "arc2"
stateGraph arc lappend "arc2" actions {sowCrop $paddock Sf_earlySorghum; lappend history($paddock) sorghum}
stateGraph arc lappend "arc2" rules {[dayWithin 244 350]}
stateGraph arc lappend "arc2" rules {[expr [sumLastRain 4] > 20 && [sumLastRain 1] == 0]}
stateGraph arc lappend "arc2" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc2" rules {$daysSinceLastHarvest($paddock) <200}
stateGraph arc lappend "arc2" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc2" rules {[getEsw $paddock] >  80}
stateGraph arc lappend "arc2" rules {[areaPlanted sorghum] <0.4}
stateGraph arc lappend "arc2" rules {[getEsw $paddock]}
stateGraph arc lappend "arc2" rules {[sorghumHistory $paddock]}
stateGraph arc insert "Lf_Wheat" "Fallow" "arc19"
stateGraph arc lappend "arc19" actions {harvestAndEndCrop $paddock wheat}
stateGraph arc lappend "arc19" rules {[canHarvestCrop $paddock wheat]}
stateGraph arc insert "Fallow" "Lf_earlySorghum" "arc20"
stateGraph arc lappend "arc20" actions {sowCrop $paddock Lf_earlySorghum; lappend history($paddock) sorghum}
stateGraph arc lappend "arc20" rules {[dayWithin 244 350]}
stateGraph arc lappend "arc20" rules {[expr [sumLastRain 4] > 20 && [sumLastRain 1] == 0]}
stateGraph arc lappend "arc20" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc20" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc20" rules {[getEsw $paddock] >80}
stateGraph arc lappend "arc20" rules {[areaPlanted sorghum] <0.8}
stateGraph arc lappend "arc20" rules {[getEsw $paddock]}
stateGraph arc lappend "arc20" rules {[sorghumHistory $paddock]}
stateGraph arc insert "Sf_earlySorghum" "Fallow" "arc3"
stateGraph arc lappend "arc3" actions {harvestAndEndCrop $paddock sorghum}
stateGraph arc lappend "arc3" rules {[canHarvestCrop $paddock sorghum]}
stateGraph arc insert "Lf_earlySorghum" "Fallow" "arc21"
stateGraph arc lappend "arc21" actions {harvestAndEndCrop $paddock sorghum}
stateGraph arc lappend "arc21" rules {[canHarvestCrop $paddock sorghum]}
stateGraph arc insert "Fallow" "Sf_Sorghum" "arc4"
stateGraph arc lappend "arc4" actions {sowCrop $paddock Sf_Sorghum; lappend history($paddock) sorghum}
stateGraph arc lappend "arc4" rules {[dayWithin 244 350] }
stateGraph arc lappend "arc4" rules {[expr [sumLastRain 4] > 20 && [sumLastRain 1] == 0]}
stateGraph arc lappend "arc4" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc4" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc4" rules {[getEsw $paddock] >80}
stateGraph arc lappend "arc4" rules {[areaPlanted sorghum] <0.8}
stateGraph arc lappend "arc4" rules {[getEsw $paddock]}
stateGraph arc lappend "arc4" rules {[sorghumHistory $paddock]}
stateGraph arc insert "Fallow" "Lf_Sorghum" "arc22"
stateGraph arc lappend "arc22" actions {sowCrop $paddock Lf_Sorghum; lappend history($paddock) sorghum}
stateGraph arc lappend "arc22" rules {[dayWithin 244  350] }
stateGraph arc lappend "arc22" rules {[expr [sumLastRain 4] > 20 && [sumLastRain 1] == 0]}
stateGraph arc lappend "arc22" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc22" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc22" rules {[getEsw $paddock] >80}
stateGraph arc lappend "arc22" rules {[areaPlanted sorghum] <0.8}
stateGraph arc lappend "arc22" rules {[getEsw $paddock]}
stateGraph arc lappend "arc22" rules {[sorghumHistory $paddock]}
stateGraph arc insert "Sf_Sorghum" "Fallow" "arc5"
stateGraph arc lappend "arc5" actions {harvestAndEndCrop $paddock sorghum}
stateGraph arc lappend "arc5" rules {[canHarvestCrop $paddock sorghum]}
stateGraph arc insert "Lf_Sorghum" "Fallow" "arc23"
stateGraph arc lappend "arc23" actions {harvestAndEndCrop $paddock sorghum}
stateGraph arc lappend "arc23" rules {[canHarvestCrop $paddock sorghum]}
stateGraph arc insert "Fallow" "lateWheat" "arc6"
stateGraph arc lappend "arc6" actions {sowCrop $paddock lateWheat; lappend history($paddock) wheat}
stateGraph arc lappend "arc6" rules {[dayWithin 153 160]}
stateGraph arc lappend "arc6" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc6" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc6" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc6" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc6" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc6" rules {[areaPlanted wheat]  <0.8}
stateGraph arc lappend "arc6" rules {[getEsw $paddock]}
stateGraph arc lappend "arc6" rules {[wheatHistory $paddock]}
stateGraph arc insert "lateWheat" "Fallow" "arc7"
stateGraph arc lappend "arc7" actions {harvestAndEndCrop $paddock wheat}
stateGraph arc lappend "arc7" rules {[canHarvestCrop $paddock wheat]}
stateGraph arc insert "Fallow" "CoverCrop" "arc8"
stateGraph arc lappend "arc8" actions {sowCrop $paddock weed; lappend history($paddock) weed}
stateGraph arc lappend "arc8" rules {[dayWithin 245 274]}
stateGraph arc lappend "arc8" rules {[expr [sumLastRain 1] == 0]}
stateGraph arc lappend "arc8" rules {[getCover $paddock] < 0.1}
stateGraph arc lappend "arc8" rules {[getEsw $paddock] >60}
stateGraph arc lappend "arc8" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc8" rules {[getEsw $paddock]}
stateGraph arc lappend "arc8" rules {$daysSinceLastHarvest($paddock) <14}
stateGraph arc insert "Fallow" "Sf_earlyWheat" "arc10"
stateGraph arc lappend "arc10" actions {sowCrop $paddock Sf_earlyWheat; lappend history($paddock) wheat}
stateGraph arc lappend "arc10" rules {[dayWithin 116 128]}
stateGraph arc lappend "arc10" rules {[getEsw $paddock] > 80}
stateGraph arc lappend "arc10" rules {[sumLastRain 1] == 0}
stateGraph arc lappend "arc10" rules {$daysSinceLastHarvest($paddock) >30}
stateGraph arc lappend "arc10" rules {[mseek2 $paddock] > 0.8}
stateGraph arc lappend "arc10" rules {[areaPlanted wheat] < 0.5}
stateGraph arc lappend "arc10" rules {[machineryAvailable tractor1_planter]}
stateGraph arc lappend "arc10" rules {[getEsw $paddock]}
stateGraph arc lappend "arc10" rules {[wheatHistory $paddock]}
stateGraph arc insert "CoverCrop" "Fallow" "arc9"
stateGraph arc lappend "arc9" actions {harvestAndEndCrop $paddock weed}
stateGraph arc lappend "arc9" rules {{[apsimGet $paddock.weed.das] == 60 ||  "[apsimGet $paddock.weed.plant_status]" == "dead"}}

     --->Section: post

   set accRain [expr $accRain + [apsimGet rain]]
   
   foreach {accumulator} {runoff drain es } {
      foreach paddock $paddocks {
         if {$paddock != "toplevel"} {
            set $paddock.$accumulator [expr [set $paddock.$accumulator] + [apsimGet $config($paddock,watBal).$accumulator]]
         }
      }   
   }
   foreach {accumulator} {soil_loss} {
      foreach paddock $paddocks {
         if {$paddock != "toplevel"} {
            set $paddock.$accumulator [expr [set $paddock.$accumulator] + [apsimGet .masterpm.$paddock.erosion.$accumulator]]
         }
      }   
   }

          
     --->Section: prepare


   if {[dayIs 181]} {
      do_end_financial_year

      set accRain 0.0
      foreach {accumulator} {runoff drain soil_loss es } {
         foreach paddock $paddocks {
            set $paddo