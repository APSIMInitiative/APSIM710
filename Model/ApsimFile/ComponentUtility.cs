
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;


namespace ApsimFile
   {

   public class ComponentUtility
      {

      public static string CalcFileName(Component Data)
         {
         // ----------------------------------- 
         // Get an autogenerated output/summary 
         // file name for specified node. 
         // NB The returned filename won't have 
         // a path. 
         // ----------------------------------- 

         string SimulationName = null;
         string PaddockName = null;
         Component D = Data;
         //temp component variable (set it to the parameter passed in [starting component]) 

         //loop back up the component datastructure until you get to the root component. 
         while ((D.Parent != null))
            {
            D = D.Parent;
            if (D.Type.ToLower() == "area")
               {
               PaddockName = D.Name;
               //store the paddock name for later 
               }
            else if (D.Type.ToLower() == "simulation")
               {
               SimulationName = D.Name;
               //store the simulation name for later 
               }
            }

         string FileName = SimulationName;
         //start out with the filename just being the simulation name 
         //if there was a paddock component and it had been renamed by the user. 
         if ((PaddockName != null) && PaddockName.ToLower() != "paddock")
            {
            FileName = FileName + " " + PaddockName;
            //add the paddock name to the simulation name 
            }
         //if the starting component (either an outputfile or summary file) has been renamed by the user 
         if (Data.Name.ToLower() != "outputfile" & Data.Name.ToLower() != "summaryfile")
            {
            FileName = FileName + " " + Data.Name;
            //add the starting component name to the simulation name 
            }
         //add the correct file suffix 
         if (Data.Type == "summaryfile")
            {
            FileName = FileName + ".sum";
            }
         else
            {
            FileName = FileName + ".out";
            }

         return FileName;
         }


      public static List<Component> FindPaddsInSim(Component Simulation)
         {
         //return a List of all the paddocks under a simulation. 
         //Usually just one paddock but some people have multiple paddocks.
         List<Component> Paddocks = new List<Component>();
         List<Component> Children;
         Children = Simulation.ChildNodes;

         foreach (Component Child in Children)
            {
            if (Child.Type.ToLower() == "area")
               {
               Paddocks.Add(Child);
               }
            }
         return Paddocks;
         }

      private static bool DoesAllowSameName(Component Child)
         {
         bool DoesAllow = false;
         //This component is allowed to have the same name;
         //You may have two ini files in the one paddock, for example one for a crop and another for micromet.
         switch (Child.Type.ToLower())
            {
            case "ini":
               DoesAllow = true;
               break;
            case "outputfile":
               DoesAllow = true;
               break;
            case "graph":
               DoesAllow = true;
               break;
            case "graph2":
               DoesAllow = true;
               break;
            }

         //Based on the Parent the children are allowed to have the same name;
         //Because soils have a "water" child component. This water component has child components for each crop.
         // so it is allowed to have the same name as a crop module. 2 output files will have children with the same name
         // reporting frequency and variables.
         switch (Child.Parent.Type.ToLower())
            {
            case "water":
               DoesAllow = true;
               break;
            case "outputfile":
               DoesAllow = true;
               break;
            }

         //Based on the Grandparent, Great Grandparent and higher are allowed to have the same name;
         //in the case of a graph component, if two or graphs are under a paddock, chances are their chldren will have the same name.
         //since graph components can have not just children, but grand children and great grand children etc. Can't just check one
         //level up.
         Component Current;
         Current = Child;
         while (Current.Parent != null)
            {
            switch (Current.Parent.Type.ToLower())
               {
               case "graph":
                  DoesAllow = true;
                  break;
               case "graph2":
                  DoesAllow = true;
                  break;
               case "ausfarmpasture":
                  DoesAllow = true;
                  break;
               }
            if (DoesAllow == true)
               {
               //break out of the while loop.
               break;
               }
            Current = Current.Parent;
            }


         //Return the result
         return DoesAllow;
         }


      public static string FindSameNameRecursively(Component Start)
         {
         //If the same name is used in more then one component anywhere below the Start component
         //then return the name of that has occured multiple times. If not return "".
         string SameName;
         List<Component> AllChildNodes = new List<Component>();
         Start.ChildNodesRecursively(AllChildNodes);     //load AllChildNodes with all the child nodes (Recursively) under the Start node.

         SameName = "";
         foreach (Component SearchChild in AllChildNodes)
            {
            foreach (Component Child in AllChildNodes)
               {
               //make sure the SearchChild did not find itself, also make sure either the SearchChild or Child's parent is not
               //allowed to have the same name. 
               if (!Child.Equals(SearchChild) && (Child.Name.ToLower() == SearchChild.Name.ToLower())
                   && !DoesAllowSameName(SearchChild) && !DoesAllowSameName(Child))
                  {
                  SameName = SearchChild.Name.ToLower();
                  }
               }
            }

         return SameName;

         }

      public static void GetComponentPathsWithinScopeOf(Component C, ref List<string> Paths)
         {
         if (C != null)
            {
            // Find the containing area, simulation or folder whichever comes first.
            Component Paddock = C;
            while (Paddock != null && Paddock.Type != "area" && Paddock.Type != "simulation" && Paddock.Type != "folder")
               Paddock = Paddock.Parent;

            List<Component> AllComponents = new List<Component>();
            Paddock.ChildNodesRecursively(AllComponents);

            foreach (Component Comp in AllComponents)
               Paths.Add(Comp.FullPath);
            }
         }

      }


   }

