
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;


namespace ApsimFile
{

    public class ComponentUtility
    {

        public static string CalcFileName(Component Data)
        {
            // ----------------------------------- 
            // Get an autogenerated output/summary 
            // file name for specified node. 
            // NB The returned filename won't have 
            // a path. 
            // ----------------------------------- 

            string SimulationName = null;
            string PaddockName = null;
            Component D = Data;
            //temp component variable (set it to the parameter passed in [starting component]) 

            //loop back up the component datastructure until you get to the root component. 
            while ((D.Parent != null))
            {
                D = D.Parent;
                if (D.Type.ToLower() == "area")
                {
                    PaddockName = D.Name;
                    //store the paddock name for later 
                }
                else if (D.Type.ToLower() == "simulation")
                {
                    SimulationName = D.Name;
                    //store the simulation name for later 
                }
            }

            string FileName = SimulationName;
            //start out with the filename just being the simulation name 
            //if there was a paddock component and it had been renamed by the user. 
            if ((PaddockName != null) && PaddockName.ToLower() != "paddock")
            {
                FileName = FileName + " " + PaddockName;
                //add the paddock name to the simulation name 
            }
            //if the starting component (either an outputfile or summary file) has been renamed by the user 
            if (Data.Name.ToLower() != "outputfile" & Data.Name.ToLower() != "summaryfile")
            {
                FileName = FileName + " " + Data.Name;
                //add the starting component name to the simulation name 
            }
            //add the correct file suffix 
            if (Data.Type == "summaryfile")
            {
                FileName = FileName + ".sum";
            }
            else
            {
                FileName = FileName + ".out";
            }

            return FileName;
        }


        public static List<Component> FindPaddsInSim(Component Simulation)
        {
            //return a List of all the paddocks under a simulation. 
            //Usually just one paddock but some people have multiple paddocks.
            List<Component> Paddocks = new List<Component>();
            List<Component> Children;
            Children = Simulation.ChildNodes;

            foreach (Component Child in Children)
            {
                if (Child.Type.ToLower() == "area")
                {
                    Paddocks.Add(Child);
                }
            }
            return Paddocks;
        }

        public static void GetComponentPathsWithinScopeOf(Component C, ref List<string> Paths)
        {
            if (C != null)
            {
                // Find the containing area, simulation or folder whichever comes first.
                Component Paddock = C;
                while (Paddock != null && Paddock.Type != "area" && Paddock.Type != "simulation" && Paddock.Type != "folder")
                    Paddock = Paddock.Parent;

                List<Component> AllComponents = new List<Component>();
                Paddock.ChildNodesRecursively(AllComponents);

                foreach (Component Comp in AllComponents)
                    Paths.Add(Comp.FullPath);
            }
        }


        public static Component FindComponentWithinScopeOf(Component C, string ComponentTypeToFind)
        {
            if (C != null)
            {
                // Find the containing area, simulation or folder whichever comes first.
                Component Parent = C;
                while (Parent != null)
                {
                    foreach (Component Child in Parent.ChildNodes)
                    {
                        if (Child.Type == ComponentTypeToFind)
                            return Child;
                    }
                    Parent = Parent.Parent;
                }
            }
            return null;
        }

    }


}

