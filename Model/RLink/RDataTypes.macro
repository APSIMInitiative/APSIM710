##################################################
[file RDataTypes.h]
#ifndef _RDataTypes_h
#define _RDataTypes_h

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
extern void componentCallback(const char *what, const char *e, char *t, void *payload);

#define max_array_size 100
[foreach types.type]
// ------ [type.name] ------
struct R[type.name]Type
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   int num[field.name];
   R[field.ctype]Type [field.name][max_array_size];
   [elseif [field.arrayandstring] = T]
   int num[field.name];
   char [field.name][max_array_size*max_array_size];
   [elseif [field.array] = T]
   int num[field.name];
   [field.ctype] [field.name][max_array_size];
   [elseif [field.structure] = T]
   R[field.cpptype] [field.name];
   [elseif [field.cpptype] = std::string]
   char [field.name][max_array_size];
   [else]
   [field.cpptype] [field.name];
   [endif]
   [if [field.array] = T]
   int num_[field.name];
   [endif]
   [endfor]
   };

extern "C" void onApsim[type.name]Event(const char *handler, R[type.name]Type *);

struct R[type.name]Type *MStoGCC(struct [type.name]Type *);
void GCCToMS(struct R[type.name]Type *payload, struct [type.name]Type *converted);
[endfor]

extern "C" void onApsimNullEvent(const char *handler);
#endif
[endfile]
##################################################
[file RDataTypes.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
#include <boost/algorithm/string.hpp>
#include <General/dll.h>
#include <General/string_functions.h>
#include <ComponentInterface2/ScienceAPI2.h>
#include <ComponentInterface2/DataTypes.h>
#include <ComponentInterface2/CMPData.h>
#include "RComponent.h"
#include "RDataTypes.h"

#ifdef __WIN32__
extern void *RDLLHandle;
#endif

// Handlers for subscribed events. These take a "MS" XXX structure (with std::XXX bits), unpack them into RXXX structures
// and call the embedded (gcc compiled) R routine that has no std:XXX arguments.
void myApsimNullEvent(const std::string &handler)
{
#ifdef __WIN32__
   typedef void (*EVT_HDLR)(const char* );
   EVT_HDLR e = (EVT_HDLR) dllProcAddress(RDLLHandle, "onApsimNullEvent");
   if (e == NULL)  throw std::runtime_error(std::string("missing symbol onApsimNullEvent in REmbed"));
   e
#else
   onApsimNullEvent
#endif
(handler.c_str());
}

[foreach types.type]
// [type.name]
void myApsim[type.name]Event(const std::string &handler, struct [type.name]Type &data)
{
 struct R[type.name]Type * rdata = MStoGCC(&data);
#ifdef __WIN32__
   typedef void (*EVT_HDLR)(const char*, R[type.name]Type *);
   EVT_HDLR e = (EVT_HDLR) dllProcAddress(RDLLHandle, "onApsim[type.name]Event");
   if (e == NULL)  throw std::runtime_error(std::string("missing symbol onApsim[type.name]Event in REmbed"));
   e
#else
   onApsim[type.name]Event
#endif
(handler.c_str(), rdata );
   delete rdata;
}
[endfor]

void RComponent::subscribe(const std::string &event, const std::string &type, const std::string &handler)
{
   if (boost::iequals(type, "Null")) {
     boost::function0<void > m = boost::bind(myApsimNullEvent, handler);
     apsimAPI.subscribe(event, m);
     return;
   }
[foreach types.type]  if (boost::iequals(type, "[type.name]")) {
     boost::function1<void, [type.name]Type&> [type.name]Ptr = boost::bind(myApsim[type.name]Event, handler, _1);
     apsimAPI.subscribe(event, [type.name]Ptr);
     return;
   }
[endfor]
   throw std::runtime_error(std::string("Unknown event type " + type + "in RComponent"));
}

// std::XXX converters
[foreach types.type]

struct R[type.name]Type *MStoGCC(struct [type.name]Type *data) {
  R[type.name]Type  *result = new R[type.name]Type;
[foreach type.field]
 [if [field.arrayandstring] = T]
   result->num[field.name] = data->[field.name].size();
   char *[field.name]Ptr = result->[field.name];
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     strcpy ([field.name]Ptr, data->[field.name][i].c_str());
     [field.name]Ptr += strlen([field.name]Ptr) + 1;
   }
 [elseif [field.arrayofstructures] = T]
   result->num[field.name] = data->[field.name].size();
   R[field.rawcpptype] *[field.name]Ptr = result->[field.name];
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     R[field.rawcpptype] *[field.name]Item = MStoGCC(&data->[field.name][i]);
     memcpy([field.name]Ptr, [field.name]Item, sizeof(R[field.rawcpptype]));
     delete [field.name]Item;
     [field.name]Ptr++;
   }
 [elseif [field.structure] = T]
   R[field.rawcpptype] *[field.name]Ptr = MStoGCC(&data->[field.name]);
   memcpy(&result->[field.name], [field.name]Ptr, sizeof(R[field.rawcpptype]));
   delete [field.name]Ptr;
 [elseif [field.array] = T]
   result->num[field.name] = data->[field.name].size();
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     result->[field.name][i] = data->[field.name][i];
   }
 [elseif [field.rawcpptype] = std::string]
   strcpy(result->[field.name], data->[field.name].c_str());
 [else]
   result->[field.name] = data->[field.name];
 [endif]
[endfor]
  return result;
}

void GCCToMS(struct R[type.name]Type *payload, struct [type.name]Type *converted) {
    [foreach type.field]
    [if [field.arrayofstructures] = T]
    R[field.rawcpptype] *[field.name]ptr = payload->[field.name];
    [field.rawcpptype] [field.name]scratch;
    for (int i = 0; i < payload->num[field.name]; i++) {
       GCCToMS([field.name]ptr, &[field.name]scratch);
       converted->[field.name].push_back([field.name]scratch);
      [field.name]ptr++;
    }
    [elseif [field.structure] = T]
      GCCToMS(&payload->[field.name], &converted->[field.name]);
    [elseif [field.arrayandstring] = T]
    converted->[field.name].clear();
    char *[field.name]Ptr = payload->[field.name];
    for (int i = 0; i < payload->num[field.name]; i++) {
       converted->[field.name].push_back([field.name]Ptr) ;
    [field.name]Ptr += strlen([field.name]Ptr) + 1;
    }
    [elseif [field.array] = T]
    converted->[field.name].clear();
    for (int i = 0; i < payload->num[field.name]; i++) {converted->[field.name].push_back(payload->[field.name][i]); }
    [else]
    converted->[field.name] = payload->[field.name];
    [endif]
    [endfor]
}
[endfor]

// The main dispatch routine from R to apsim.
extern RComponent *currentRComponent;
void componentCallback(const char *what, const char *e, char *t, void *payload)
{
	if (currentRComponent)
    {
	if (Str_i_Eq(what, "publish"))
	  {
	  // payload = void pointer to gcc (fortranish) style structure
      std::string type;
      if (t == NULL) type = "Null"; else type = t;
      if (boost::iequals(type, "Null"))
          {
          currentRComponent->apsimAPI.publish(std::string(e)); return;
          } [foreach types.type] if (boost::iequals(type, "[type.name]")) {
            [type.name]Type * converted = new [type.name]Type;
            GCCToMS((R[type.name]Type *) payload, converted);
            currentRComponent->apsimAPI.publish(std::string(e), *converted);
            delete converted;
            return;
          } [endfor]
      }
	else if (Str_i_Eq(what, "subscribe"))
	  {
	  // payload = name of handler routine
	  currentRComponent->subscribe(std::string(e), std::string(t), std::string((char *)payload));
	  }
	else if (Str_i_Eq(what, "expose"))
	  {
	  currentRComponent->expose(std::string(e), std::string(t));
	  }
        else if (Str_i_Eq(what, "query"))
          {
          std::vector<std::string> resultArray;
          currentRComponent->query(std::string(e), resultArray);
          * ((int *)payload) = resultArray.size();
          char *buf = ((char *) payload + sizeof(int));
          for (unsigned int i = 0; i <  resultArray.size(); i++) {strcpy(buf, resultArray[i].c_str()); buf += strlen(buf) + 1;}
          strcpy(t, "stringvec");
          }
	else if (Str_i_Eq(what, "get"))
      {
      std::vector<std::string> resultArray;
      currentRComponent->apsimAPI.get(std::string(e), "", 1, resultArray);

      if (resultArray.size() == 0) {strcpy(t, "na"); return;}

      bool isVector = resultArray.size() > 1;
      bool isNum = true;
      for (unsigned int i = 0; i < resultArray.size(); i++) {if (!isNumeric(resultArray[i])) { isNum = false; break; }}
      if (!isVector)
         {
         if (isNum) { * ((double *)payload) = std::strtod( resultArray[0].c_str(), NULL ); strcpy(t, "numeric"); }
         else  { strcpy( (char *)payload, resultArray[0].c_str()); strcpy(t, "string");}
         }
      else
         {
         * ((int *)payload) = resultArray.size();
         if (isNum)
            {
            double *buf = (double *) ((char *) payload + sizeof(int));
            for (unsigned int i = 0; i <  resultArray.size(); i++) {buf[i] = std::strtod(resultArray[i].c_str(), NULL );}
            strcpy(t, "numericvec");
            }
         else
            {
            char *buf = ((char *) payload + sizeof(int));
            for (unsigned int i = 0; i <  resultArray.size(); i++) {strcpy(buf, resultArray[i].c_str()); buf += strlen(buf) + 1;}
            strcpy(t, "stringvec");
            }
         }
      }
	else if (Str_i_Eq(what, "set"))
      {
      if (Str_i_Eq(t, "char"))
         {
         std::string value = std::string((char *) payload);
         currentRComponent->apsimAPI.set(std::string(e), std::string(""), value);
         }
      else if (Str_i_Eq(t, "numeric"))
         currentRComponent->apsimAPI.set(std::string(e), std::string(""), *(double *) payload);
      else if (Str_i_Eq(t, "charvec"))
         {
         std::vector<std::string> value;
         unsigned int num = *(int *)payload;
         char *buf = ((char *) payload + sizeof(int));
         for (unsigned int i = 0; i < num; i++) { value.push_back(std::string(buf)); buf += strlen(buf) + 1; }
         currentRComponent->apsimAPI.set(std::string(e), std::string(""), value);
         }
      else if (Str_i_Eq(t, "numericvec"))
         {
         std::vector<double> value;
         unsigned int num = *(int *)payload;
         double *buf = (double *) ((char*)payload + sizeof(int));
         for (unsigned int i = 0; i < num; i++) { value.push_back(*buf); buf++; }
         currentRComponent->apsimAPI.set(std::string(e), std::string(""), value);
         }
      else
         throw std::runtime_error(std::string("unknown set type") + t);
      }
	else if (Str_i_Eq(what, "fatal"))
	  {
         throw std::runtime_error(std::string(e));
      }
    }
 }

[endfile]
##################################################
[file RDataTypesRcpp.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <RInside.h>
#include "REmbedder.h"
#include "RDataTypes.h"

// https://github.com/kmcallister/embedded-breakpoints
#define EMBED_BREAKPOINT \
    asm("0:"                              \
        ".pushsection embed-breakpoints;" \
        ".quad 0b;"                       \
        ".popsection;")

void apsimFatalError( std::string message );

extern "C" void onApsimNullEvent(const char *handler) {
   Rcpp::Function f = Rcpp::Function(handler);
   try {
     f();
   } catch (std::exception e) {
     fprintf(stderr, "Rinside exception: %s.\n", e.what());
     std::string msg = ptrR->parseEval("paste(geterrmessage(), traceback())");
     fprintf(stderr, "%s", msg.c_str());
     apsimFatalError(msg.c_str());
   }
}

[foreach types.type]
Rcpp::List addToList(Rcpp::List &in, R[type.name]Type *data) {
 Rcpp::List result = in;
 [foreach type.field]
 [if [field.arrayandstring] = T]
   std::vector<std::string> [field.name](data->num[field.name]);
   char * [field.name]Ptr = data->[field.name];
   for (int i = 0; i < data->num[field.name]; i++) {
      [field.name][i] = std::string([field.name]Ptr);
      [field.name]Ptr += strlen([field.name]Ptr) + 1;
   }
   result["[field.name]"] = [field.name];
 [elseif [field.arrayofstructures] = T]
   Rcpp::List [field.name];
   R[field.rawcpptype] *[field.name]Ptr = data->[field.name];
   for (int i = 0; i < data->num[field.name]; i++)  {
      [field.name] = addToList([field.name], [field.name]Ptr);
      [field.name]Ptr++;
   }
   result["[field.name]"] = [field.name];
 [elseif [field.structure] = T]
   result = addToList(result, &data->[field.name]);
 [elseif [field.rawcpptype] = std::string]
   result["[field.name]"] = std::string(data->[field.name]);
 [elseif [field.array] = T]
   std::vector<[field.rawcpptype]> [field.name](data->num[field.name]);
   for (int i = 0; i < data->num[field.name]; i++) {
      [field.name][i] = [field.name][i];
   }
   result["[field.name]"] = [field.name];
 [else]
   result["[field.name]"] = data->[field.name];
 [endif]
 [endfor]
 return(result);
}

extern "C" void onApsim[type.name]Event(const char *handler , R[type.name]Type *data) {

   Rcpp::List args = Rcpp::List::create();
   args["handler"] = handler;
   args = addToList(args, data);
   Rcpp::Function f = Rcpp::Function(handler);
   try {
     f(args);
   } catch (std::exception e) {
     fprintf(stderr, "Rinside exception: %s.\n", e.what());
     std::string msg = ptrR->parseEval("paste(geterrmessage(), traceback())");
     fprintf(stderr, "%s", msg.c_str());
     apsimFatalError(msg.c_str());
   }
}
[endfor]
[endfile]
[file apsimPublish.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually. This file is #included from REmbedder.cpp
// ------------------------------------------------------------------
[foreach types.type]
struct R[type.name]Type *make[type.name]Type(Rcpp::List data) {
    R[type.name]Type *result = new R[type.name]Type;
    std::vector<std::string> names;
    if (data.size() > 0)
       names = data.names();
    [foreach type.field]
    if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
     [if [field.arrayofstructures] = T]
      Rcpp::List [field.name]List = Rcpp::as<Rcpp::List>(data["[field.name]"]);
 	  result->num[field.name] = [field.name]List.size();
	  R[field.rawcpptype] *bufPtr = result->[field.name];
	  for (int i = 0; i < result->num[field.name]; i++) {
	     Rcpp::List [field.name]SubList = [field.name]List[i];
         R[field.rawcpptype] *[field.name] = make[field.rawcpptype]([field.name]SubList);
         memcpy(bufPtr, [field.name], sizeof(R[field.rawcpptype]));
         delete [field.name];
		 bufPtr++;
	 }
     [elseif [field.structure] = T]
      Rcpp::List [field.name]List = Rcpp::as<Rcpp::List>(data["[field.name]"]);
      R[field.rawcpptype] *[field.name] = make[field.rawcpptype]([field.name]List);
      memcpy(&result->[field.name], [field.name], sizeof(R[field.rawcpptype]));
      delete [field.name];
     [elseif [field.cpptype] = std::vector<double>]
      std::vector<double> [field.name] = Rcpp::as<std::vector<double> >(data["[field.name]"]);
	  result->num[field.name] = [field.name].size();
	  for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	 [elseif [field.cpptype] = double]
      result->[field.name] = Rcpp::as<double>(data["[field.name]"]);
     [elseif [field.cpptype] = std::vector<float>]
      std::vector<float> [field.name] = Rcpp::as<std::vector<float> >(data["[field.name]"]);
	  result->num[field.name] = [field.name].size();
	  for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	 [elseif [field.cpptype] = float]
      result->[field.name] = Rcpp::as<float>(data["[field.name]"]);
     [elseif [field.cpptype] = std::vector<int>]
      std::vector<int> [field.name] = Rcpp::as<std::vector<int> >(data["[field.name]"]);
	  result->num[field.name] = [field.name].size();
	  for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	 [elseif [field.cpptype] = int]
      result->[field.name] = Rcpp::as<int>(data["[field.name]"]);
     [elseif [field.cpptype] = std::vector<bool>]
      std::vector<bool> [field.name] = Rcpp::as<std::vector<bool> >(data["[field.name]"]);
	  result->num[field.name] = [field.name].size();
	  for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	 [elseif [field.cpptype] = bool]
      result->[field.name] = Rcpp::as<bool>(data["[field.name]"]);
     [elseif [field.arrayandstring] = T]
	    Rcpp::CharacterVector [field.name] = data["[field.name]"];
	    result->num[field.name] = [field.name].size();
		char *bufPtr = result->[field.name];
        for (int i = 0; i < result->num[field.name]; i++) {
           strcpy(bufPtr, [field.name][i]);
		   bufPtr += strlen(bufPtr) + 1;
		}
     [elseif [field.rawcpptype] = std::string]
       std::string [field.name] = data["[field.name]"];
       strncpy(result->[field.name], [field.name].c_str(), max_array_size);
	 [else]
      /* unimplemented [field.cpptype] [field.name]*/
	 [endif]
     } else {
     [elseif [field.cpptype] = std::vector<double>]
	  result->num[field.name] = 0;
	 [elseif [field.cpptype] = double]
      result->[field.name] = 0.0;
     [elseif [field.cpptype] = std::vector<float>]
	  result->num[field.name] = 0;
	 [elseif [field.cpptype] = float]
      result->[field.name] = 0.0;
     [elseif [field.cpptype] = std::vector<int>]
	  result->num[field.name] = 0;
	 [elseif [field.cpptype] = int]
      result->[field.name] = 0;
     [elseif [field.cpptype] = std::vector<bool>]
	  result->num[field.name] = 0;
	 [elseif [field.cpptype] = bool]
        result->[field.name] = false;
     [elseif [field.arrayandstring] = T]
	    result->num[field.name] = 0;
     [elseif [field.rawcpptype] = std::string]
        result->[field.name][0] = '\0';
	 [else]
      /* unimplemented [field.cpptype] [field.name]*/
	 [endif]

     }
	[endfor]
    return result;
}
[endfor]

void apsimPublish( std::string eventName, std::string type, Rcpp::List data  )
  {
  if (apsimCallback == NULL) {return;}
  if (!strcasecmp(type.c_str(), "Null")) {
     apsimCallback("publish", eventName.c_str(), NULL, NULL);
     return;
  }
[foreach types.type]  if (!strcasecmp(type.c_str(), "[type.name]")) {
     R[type.name]Type *payload = make[type.name]Type(data);
     apsimCallback("publish", eventName.c_str(), "[type.name]", payload);
     delete payload;
     return;
  }
[endfor]
  apsimCallback("fatal", (type + std::string(" is an unknown type")).c_str(), NULL, NULL);
}
[endfile]
