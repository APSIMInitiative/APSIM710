##################################################
[file RDataTypes.h]
#ifndef _RDataTypes_h
#define _RDataTypes_h

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
#ifdef __WIN32__
  #ifdef BUILDING_APSIMDLL
   #define DLLEXPORT __declspec(dllexport)
  #else
   #define DLLEXPORT __declspec(dllexport)
  #endif
#else
  #define DLLEXPORT
  #define STDCALL 
#endif

#define max_array_size 100
[foreach types.type]
// ------ [type.name] ------
struct R[type.name]Type
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   int num[field.name];
   R[field.ctype]Type [field.name][max_array_size];
   [elseif [field.arrayandstring] = T]
   int num[field.name];
   char [field.name][max_array_size*max_array_size];
   [elseif [field.array] = T]
   int num[field.name];
   [field.ctype] [field.name][max_array_size];
   [elseif [field.structure] = T]
   R[field.cpptype] [field.name];
   [elseif [field.cpptype] = std::string]
   char [field.name][max_array_size];
   [else]
   [field.cpptype] [field.name];
   [endif]
   [if [field.array] = T]
   int num_[field.name];
   [endif]
   [endfor]
   };

extern "C" void DLLEXPORT onApsim[type.name]Event(const char *handler, R[type.name]Type *);

struct R[type.name]Type *MStoGCC(struct [type.name]Type *);
void GCCToMS(struct R[type.name]Type *payload, struct [type.name]Type *converted);

extern "C" void DLLEXPORT STDCALL apsimPublish[type.name](const char *e, R[type.name]Type *payload);
extern "C" void DLLEXPORT STDCALL apsimSet[type.name](const char *e, R[type.name]Type *payload);
extern "C" void DLLEXPORT * STDCALL apsimGet[type.name](const char *e);
[endfor]

extern "C" void DLLEXPORT STDCALL apsimGetNumeric(const char *e, int *numReturned, double**returned) ;
extern "C" void DLLEXPORT STDCALL apsimGetCharacter(const char *e, int *numReturned, char**returned) ;
extern "C" void DLLEXPORT STDCALL apsimSetNumeric(const char *e, int numSet, double*data) ;
extern "C" void DLLEXPORT STDCALL apsimSetCharacter(const char *e, int numSet, char*data) ;
extern "C" void DLLEXPORT STDCALL apsimPublishNull(const char *e);
extern "C" void DLLEXPORT onApsimNullEvent(const char *handler);
extern "C" void DLLEXPORT STDCALL apsimSubscribeRaw(const char *e, const char *t, const char *h);
extern "C" void DLLEXPORT STDCALL apsimExposeRaw(const char *e, const char *units);
extern "C" void DLLEXPORT STDCALL apsimQueryRaw(const char *e, int *numReturned, void **returned);
extern "C" void DLLEXPORT STDCALL apsimFatalErrorRaw(const char *msg);
extern "C" void DLLEXPORT STDCALL apsimFree(void *a);


#endif
[endfile]
##################################################
[file RDataTypes.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
#include <boost/algorithm/string.hpp>
#include <General/dll.h>
#include <General/string_functions.h>
#include <ComponentInterface2/ScienceAPI2.h>
#include <ComponentInterface2/DataTypes.h>
#include <ComponentInterface2/CMPData.h>
#include "RComponent.h"
#include "RDataTypes.h"

extern void *RDLLHandle;

// Handlers for subscribed events. These take a "MS" XXX structure (with std::XXX bits), unpack them into RXXX structures
// and call the embedded (gcc compiled) R routine that has no std:XXX arguments.
void myApsimNullEvent(const std::string &handler)
{
   typedef void (*EVT_HDLR)(const char* );
   EVT_HDLR onApsimNullEvent = (EVT_HDLR) dllProcAddress(RDLLHandle, "onApsimNullEvent");
   if (onApsimNullEvent == NULL)  throw std::runtime_error(std::string("missing symbol onApsimNullEvent in REmbed"));
   onApsimNullEvent(handler.c_str());
}

[foreach types.type]
// [type.name]
void myApsim[type.name]Event(const std::string &handler, struct [type.name]Type &data)
{
 struct R[type.name]Type * rdata = MStoGCC(&data);
   typedef void (*EVT_HDLR)(const char*, R[type.name]Type *);
   EVT_HDLR onApsim[type.name]Event = (EVT_HDLR) dllProcAddress(RDLLHandle, "onApsim[type.name]Event");
   if (onApsim[type.name]Event == NULL)  throw std::runtime_error(std::string("missing symbol onApsim[type.name]Event in REmbed"));
   onApsim[type.name]Event(handler.c_str(), rdata );
   delete rdata;
}
[endfor]

void RComponent::subscribe(const std::string &event, const std::string &type, const std::string &handler)
{
   if (boost::iequals(type, "Null")) {
     boost::function0<void > m = boost::bind(myApsimNullEvent, handler);
     apsimAPI.subscribe(event, m);
     return;
   }
[foreach types.type]  if (boost::iequals(type, "[type.name]")) {
     boost::function1<void, [type.name]Type&> [type.name]Ptr = boost::bind(myApsim[type.name]Event, handler, _1);
     apsimAPI.subscribe(event, [type.name]Ptr);
     return;
   }
[endfor]
   throw std::runtime_error(std::string("Unknown event type " + type + "in RComponent"));
}

// std::XXX converters
[foreach types.type]

struct R[type.name]Type *MStoGCC(struct [type.name]Type *data) {
  R[type.name]Type  *result = new R[type.name]Type;
[foreach type.field]
 [if [field.arrayandstring] = T]
   result->num[field.name] = data->[field.name].size();
   char *[field.name]Ptr = result->[field.name];
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     strcpy ([field.name]Ptr, data->[field.name][i].c_str());
     [field.name]Ptr += strlen([field.name]Ptr) + 1;
   }
 [elseif [field.arrayofstructures] = T]
   result->num[field.name] = data->[field.name].size();
   R[field.rawcpptype] *[field.name]Ptr = result->[field.name];
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     R[field.rawcpptype] *[field.name]Item = MStoGCC(&data->[field.name][i]);
     memcpy([field.name]Ptr, [field.name]Item, sizeof(R[field.rawcpptype]));
     delete [field.name]Item;
     [field.name]Ptr++;
   }
 [elseif [field.structure] = T]
   R[field.rawcpptype] *[field.name]Ptr = MStoGCC(&data->[field.name]);
   memcpy(&result->[field.name], [field.name]Ptr, sizeof(R[field.rawcpptype]));
   delete [field.name]Ptr;
 [elseif [field.array] = T]
   result->num[field.name] = data->[field.name].size();
   for (unsigned int i = 0; i <  data->[field.name].size(); i++) {
     result->[field.name][i] = data->[field.name][i];
   }
 [elseif [field.rawcpptype] = std::string]
   strncpy(result->[field.name], data->[field.name].c_str(),max_array_size);
 [else]
   result->[field.name] = data->[field.name];
 [endif]
[endfor]
  return result;
}

void GCCToMS(struct R[type.name]Type *payload, struct [type.name]Type *converted) {
    [foreach type.field]
    [if [field.arrayofstructures] = T]
    R[field.rawcpptype] *[field.name]ptr = payload->[field.name];
    [field.rawcpptype] [field.name]scratch;
    for (int i = 0; i < payload->num[field.name]; i++) {
       GCCToMS([field.name]ptr, &[field.name]scratch);
       converted->[field.name].push_back([field.name]scratch);
      [field.name]ptr++;
    }
    [elseif [field.structure] = T]
      GCCToMS(&payload->[field.name], &converted->[field.name]);
    [elseif [field.arrayandstring] = T]
    converted->[field.name].clear();
    char *[field.name]Ptr = payload->[field.name];
    for (int i = 0; i < payload->num[field.name]; i++) {
       converted->[field.name].push_back([field.name]Ptr) ;
    [field.name]Ptr += strlen([field.name]Ptr) + 1;
    }
    [elseif [field.array] = T]
    converted->[field.name].clear();
    for (int i = 0; i < payload->num[field.name]; i++) {converted->[field.name].push_back(payload->[field.name][i]); }
    [else]
    converted->[field.name] = payload->[field.name];
    [endif]
    [endfor]
}
[endfor]

extern RComponent *currentRComponent;

extern "C" void DLLEXPORT STDCALL apsimPublishNull(const char *e) {
  if (currentRComponent) currentRComponent->apsimAPI.publish(std::string(e));
}

[foreach types.type]
extern "C" void DLLEXPORT STDCALL apsimPublish[type.name](const char *e, R[type.name]Type *payload) {
 [type.name]Type * converted = new [type.name]Type;
 GCCToMS(payload, converted);
 if (currentRComponent) currentRComponent->apsimAPI.publish(std::string(e), *converted);
 delete converted;
}

extern "C" void DLLEXPORT * STDCALL apsimGet[type.name](const char *e) {
   [type.name]Type * gotten = new [type.name]Type;
   if (currentRComponent) currentRComponent->apsimAPI.get(std::string(e), false, *gotten);
   R[type.name]Type * converted = MStoGCC(gotten);
   delete gotten;
   return(converted);
}

extern "C" void DLLEXPORT STDCALL apsimSet[type.name](const char *e, R[type.name]Type *payload) {
   [type.name]Type * converted = new [type.name]Type;
   GCCToMS(payload, converted);
   if (currentRComponent) currentRComponent->apsimAPI.set(std::string(e), *converted);
   delete converted;
}

[endfor]

extern "C" void DLLEXPORT STDCALL apsimFree(void *a) {
   free(a);
}

extern "C" void DLLEXPORT STDCALL apsimFatalErrorRaw(const char *msg) {
   if (currentRComponent) currentRComponent->fatal(std::string(msg));
}

extern "C" void DLLEXPORT STDCALL apsimSubscribeRaw(const char *e, const char *t, const char *h) {
   if (currentRComponent) currentRComponent->subscribe(std::string(e), std::string(t), std::string(h));
}

extern "C" void DLLEXPORT STDCALL apsimExposeRaw(const char *e, const char *t) {
   if (currentRComponent) currentRComponent->expose(std::string(e), std::string(t));
}

extern "C" void DLLEXPORT STDCALL apsimQueryRaw(const char *e, int *numReturned, void **returned) {
   std::vector<QueryMatch> resultArray;
   if (currentRComponent) currentRComponent->apsimAPI.queryVariable(std::string(e), resultArray);
   *numReturned =  resultArray.size();

   int numBytes = 0;
   for (unsigned int i = 0; i < resultArray.size(); i++) {numBytes += 2 + resultArray[i].name.length() + resultArray[i].ddml.length();}

   *returned = (numBytes == 0) ? NULL : (char *) malloc(numBytes);
   char *buf = (char *) *returned;
   for (unsigned int i = 0; i <  resultArray.size(); i++)
   {
      strcpy(buf, resultArray[i].name.c_str()); buf += strlen(buf) + 1;
      strcpy(buf, resultArray[i].ddml.c_str()); buf += strlen(buf) + 1;
   }
}

extern "C" void DLLEXPORT STDCALL apsimGetNumeric(const char *e, int *numReturned, double **returned) {
   *returned = NULL;
   *numReturned = 0;

   std::vector<double> resultArray;
   currentRComponent->apsimAPI.get(std::string(e), "", 1, resultArray);

   *numReturned = resultArray.size();
   if (*numReturned == 0) { return;}

   *returned = (double *) malloc(*numReturned * sizeof(double));

   for (unsigned int i = 0; i <  resultArray.size(); i++) {(*returned)[i] = resultArray[i];}
}

extern "C" void DLLEXPORT STDCALL apsimGetCharacter(const char *e, int *numReturned, char **returned) {
   *returned = NULL;
   *numReturned = 0;

   std::vector<std::string> resultArray;
   currentRComponent->apsimAPI.get(std::string(e), "", 1, resultArray);

   *numReturned = resultArray.size();
   if (*numReturned == 0) { return ;}

   int numBytes = 0;
   for (int i = 0; i < *numReturned; i++) {numBytes += 1 + resultArray[i].length();}
   char *p = *returned = (char *) malloc(numBytes);
   for (unsigned int i = 0; i <  resultArray.size(); i++) {strcpy(p, resultArray[i].c_str()); p += strlen(p) + 1;}
}

extern "C" void DLLEXPORT STDCALL apsimSetNumeric(const char *e, int numSet, double* data)
{
   if (numSet == 1) {
      currentRComponent->apsimAPI.set(std::string(e), "", *data);
   } else if (numSet > 1) {
      std::vector<double> setArray;
      for (unsigned int i = 0; i <  setArray.size(); i++) {setArray.push_back(data[i]);}
      currentRComponent->apsimAPI.set(std::string(e), "", setArray);
   }
}

extern "C" void DLLEXPORT STDCALL apsimSetCharacter(const char *e, int numSet, char* data)
{
   if (numSet == 1) {
      std::string s(data);
      currentRComponent->apsimAPI.set(std::string(e), "", s);
   } else if (numSet > 1) {
      std::vector<std::string> setArray;
      char *p = data;
      for (unsigned int i = 0; i <  setArray.size(); i++) {setArray.push_back(p); p += strlen(p) + 1;}
      currentRComponent->apsimAPI.set(std::string(e), "", setArray);
   }
}

[endfile]
##################################################
[file RDataTypesEmbedded.h]
#ifndef _RDataTypesEmbedded_H
#define _RDataTypesEmbedded_H
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

extern "C" void DLLEXPORT onApsimNullEvent(const char *handler);

[foreach types.type]
extern "C" void DLLEXPORT onApsim[type.name]Event(const char *handler , R[type.name]Type *data);

Rcpp::List convertToList(R[type.name]Type *);
struct R[type.name]Type *make[type.name]Type(Rcpp::List data);
[endfor]

void apsimPublish( std::string eventName, std::string type, Rcpp::List data  );
SEXP apsimGet( std::string variableName );
void apsimSet( std::string variableName, SEXP value );

std::string getAttributeFromXML(const std::string& XML, const std::string& attributeName);
#endif

[endfile]
[file RDataTypesEmbedded.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <RInside.h>
#include <General/platform.h>
#include "REmbedder.h"
#include "RDataTypes.h"
#include "RDataTypesEmbedded.h"

#ifdef __WIN32__
extern void * myDllProcAddress(void *h, const char *sym);
#endif

extern void *RLinkDLLHandle;

[foreach types.type]
Rcpp::List convertToList(R[type.name]Type *data) {
 Rcpp::List result;
 [foreach type.field]
 [if [field.arrayandstring] = T]
   std::vector<std::string> [field.name](data->num[field.name]);
   char * [field.name]Ptr = data->[field.name];
   for (int i = 0; i < data->num[field.name]; i++) {
      [field.name][i] = std::string([field.name]Ptr);
      [field.name]Ptr += strlen([field.name]Ptr) + 1;
   }
   result["[field.name]"] = [field.name];
 [elseif [field.arrayofstructures] = T]
   R[field.rawcpptype] *[field.name]Ptr = data->[field.name];
   for (int i = 0; i < data->num[field.name]; i++)  {
      std::ostringstream elemName; elemName << "[field.name]." <<  i+1;
      result[elemName.str()] = convertToList([field.name]Ptr);
      [field.name]Ptr++;
   }
   result["num[field.name]"] = data->num[field.name];
 [elseif [field.structure] = T]
   result["[field.name]"] = convertToList(&data->[field.name]);
 [elseif [field.rawcpptype] = std::string]
   result["[field.name]"] = std::string(data->[field.name]);
 [elseif [field.array] = T]
   std::vector<[field.rawcpptype]> [field.name](data->num[field.name]);
   for (int i = 0; i < data->num[field.name]; i++) {
      [field.name][i] = [field.name][i];
   }
   result["[field.name]"] = [field.name];
 [else]
   result["[field.name]"] = data->[field.name];
 [endif]
 [endfor]
 return(result);
}
struct R[type.name]Type *make[type.name]Type(Rcpp::List data) {
    R[type.name]Type *result = new R[type.name]Type;
    std::vector<std::string> names;
    if (data.size() > 0)
       names = data.names();
    [foreach type.field]
     [if [field.arrayofstructures] = T]
      if (std::find(names.begin(), names.end(), "num[field.name]") != names.end()) {
       result->num[field.name] = Rcpp::as<int>(data["num[field.name]"]);
 	   R[field.rawcpptype] *bufPtr = result->[field.name];
	   for (int i = 0; i < result->num[field.name]; i++) {
         std::ostringstream elemName; elemName << "[field.name]." <<  i+1;
         Rcpp::List [field.name]SubList = Rcpp::as<Rcpp::List>(data[elemName.str()]);
         R[field.rawcpptype] *[field.name] = make[field.rawcpptype]([field.name]SubList);
         memcpy(bufPtr, [field.name], sizeof(R[field.rawcpptype]));
         delete [field.name];
         bufPtr++;
	    }
	   } else {
        result->num[field.name] = 0;
	   }
     [elseif [field.structure] = T]
      if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
        Rcpp::List [field.name]List = Rcpp::as<Rcpp::List>(data["[field.name]"]);
        R[field.rawcpptype] *[field.name] = make[field.rawcpptype]([field.name]List);
        memcpy(&result->[field.name], [field.name], sizeof(R[field.rawcpptype]));
        delete [field.name];
	   } else {
        memset(&result->[field.name], 0, sizeof(R[field.rawcpptype]));
	   }
     [elseif [field.cpptype] = std::vector<double>]
      if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
        std::vector<double> [field.name] = Rcpp::as<std::vector<double> >(data["[field.name]"]);
        result->num[field.name] = [field.name].size();
        for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	   } else {
        result->num[field.name] = 0;
	   }
     [elseif [field.cpptype] = double]
      if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
        result->[field.name] = Rcpp::as<double>(data["[field.name]"]);
	   } else {
        result->[field.name] = 0.0;
	   }
     [elseif [field.cpptype] = std::vector<float>]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
        std::vector<float> [field.name] = Rcpp::as<std::vector<float> >(data["[field.name]"]);
	    result->num[field.name] = [field.name].size();
	    for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	   } else {
        result->num[field.name] = 0;
	   }
     [elseif [field.cpptype] = float]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
         result->[field.name] = Rcpp::as<float>(data["[field.name]"]);
	   } else {
         result->[field.name] = 0.0;
	   }
     [elseif [field.cpptype] = std::vector<int>]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
         std::vector<int> [field.name] = Rcpp::as<std::vector<int> >(data["[field.name]"]);
         result->num[field.name] = [field.name].size();
         for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	   } else {
         result->num[field.name] = 0;
	   }
     [elseif [field.cpptype] = int]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
          result->[field.name] = Rcpp::as<int>(data["[field.name]"]);
	   } else {
         result->[field.name] = 0;
	   }
     [elseif [field.cpptype] = std::vector<bool>]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
         std::vector<bool> [field.name] = Rcpp::as<std::vector<bool> >(data["[field.name]"]);
         result->num[field.name] = [field.name].size();
	     for (unsigned int i = 0; i < [field.name].size(); i++) {result->[field.name][i] = [field.name][i]; }
	   } else {
         result->num[field.name] = 0;
	   }
     [elseif [field.cpptype] = bool]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
         result->[field.name] = Rcpp::as<bool>(data["[field.name]"]);
	   } else {
         result->[field.name] = false;
	   }
     [elseif [field.arrayandstring] = T]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
          Rcpp::CharacterVector [field.name] = data["[field.name]"];
	      result->num[field.name] = [field.name].size();
		  char *bufPtr = result->[field.name];
          for (int i = 0; i < result->num[field.name]; i++) {
             strcpy(bufPtr, [field.name][i]);
             bufPtr += strlen(bufPtr) + 1;
		  }
	   } else {
          result->num[field.name] = 0;
	   }
     [elseif [field.rawcpptype] = std::string]
       if (std::find(names.begin(), names.end(), "[field.name]") != names.end()) {
          std::string [field.name] = data["[field.name]"];
          strncpy(result->[field.name], [field.name].c_str(), max_array_size);
	   } else {
          result->[field.name][0] = '\0';
	   }
     [else]
       /* unimplemented [field.cpptype] [field.name]*/
     [endif]
	[endfor]
    return result;
}
[endfor]

// Apsim has called us to handle an event.
extern "C" void DLLEXPORT onApsimNullEvent(const char *handler) {
   Rcpp::Function f = Rcpp::Function(handler);
   try {
     f();
   } catch (std::exception e) {
     fprintf(stderr, "Rinside exception: %s.\n", e.what());
     std::string msg = ptrR->parseEval("paste(geterrmessage(), traceback())");
     fprintf(stderr, "%s", msg.c_str());
     apsimFatalError(msg);
   }
}
[foreach types.type]
extern "C" void DLLEXPORT onApsim[type.name]Event(const char *handler , R[type.name]Type *data) {

   Rcpp::List args = Rcpp::List::create();
   args["handler"] = handler;
   args = convertToList(data);
   Rcpp::Function f = Rcpp::Function(handler);
   try {
     f(args);
   } catch (std::exception e) {
     fprintf(stderr, "Rinside exception: %s.\n", e.what());
     std::string msg = ptrR->parseEval("paste(geterrmessage(), traceback())");
     fprintf(stderr, "%s", msg.c_str());
     apsimFatalError(msg);
   }
}

[endfor]

// We want to tell apsim about an event.
void apsimPublish( std::string eventName, std::string type, Rcpp::List data  )
  {
  if (!strcasecmp(type.c_str(), "Null")) {
#ifdef __WIN32__
   typedef void (*PUBLISH_HDLR)(const char *);
   PUBLISH_HDLR p = (PUBLISH_HDLR) myDllProcAddress(RLinkDLLHandle, "apsimPublishNull");
   if (p == NULL)  throw std::runtime_error(std::string("missing symbol apsimPublishNull in RLink"));
   p
#else
   apsimPublishNull
#endif
     (eventName.c_str());
   return;
  }
[foreach types.type]  if (!strcasecmp(type.c_str(), "[type.name]")) {
     R[type.name]Type *payload = make[type.name]Type(data);
#ifdef __WIN32__
     typedef void (*PUBLISH_[type.name]_HDLR)(const char *, R[type.name]Type *);
     PUBLISH_[type.name]_HDLR apsimPublish[type.name] = (PUBLISH_[type.name]_HDLR) myDllProcAddress(RLinkDLLHandle, "apsimPublish[type.name]");
     if (apsimPublish[type.name] == NULL)  throw std::runtime_error(std::string("missing symbol apsimPublish[type.name] in RLink"));
#endif
     apsimPublish[type.name](eventName.c_str(), payload);
     delete payload;
     return;
  }
[endfor]
  apsimFatalError(type + std::string(" is an unknown type"));
}

std::string getAttributeFromXML(const std::string& XML, const std::string& attributeName)
   {
   size_t posEnd = XML.find(">");
   size_t posAttribute = XML.find(attributeName);
   if (posAttribute != std::string::npos && posAttribute < posEnd)
      {
      size_t posOpenQuote = XML.find('\"', posAttribute);
      if (posOpenQuote != std::string::npos )
         {
         size_t posCloseQuote = XML.find('\"', posOpenQuote+1);
         if (posCloseQuote != std::string::npos)
            {
            return XML.substr(posOpenQuote+1, posCloseQuote-posOpenQuote-1);
            }
         }
      }
   else
      return "";
   return "";
   }

struct QueryMatch
   {
   std::string name;
   std::string ddml;
   };

bool isNumeric(const char *s) {
   char *term;
   double junk = strtod(s, &term);
   return (*term == '\0');
}
double asNumeric(const char *s) {
   return (strtod(s, NULL));
}
SEXP apsimGet( std::string variableName )
{
   SEXP result = Rcpp::wrap(NA_STRING);
   int nQ;
   char *Q, *p;
   apsimQueryRaw(variableName.c_str(), &nQ, (void **)&Q);
   p = Q;
   std::vector<QueryMatch> matches;
   for (int i = 0; i < nQ; i++) {
     QueryMatch queryMatch;
     queryMatch.name = p; p += strlen(p)+1;
     queryMatch.ddml = p; p += strlen(p)+1;
     matches.push_back(queryMatch);
   }
   if (Q) apsimFree(Q);
   for (unsigned int i = 0; i < matches.size(); i++)
      {
      int numGotten;
      std::string type = getAttributeFromXML(matches[i].ddml, "typename");
      if (type == "" || type == "string") {
         char *dataReturned = NULL;
         // Not all apsim modules will return numeric types, some will return a string
         // version of the same. Try to promote numeric types where possible.
         apsimGetCharacter(matches[i].name.c_str(), &numGotten, &dataReturned);
         if (numGotten == 1) {
            std::string s = dataReturned;
            if (isNumeric(s.c_str()))
              result = Rcpp::wrap(asNumeric(s.c_str()));
            else
              result = Rcpp::wrap(s);
         } else if (numGotten > 1 ) {
            bool allNumeric = true;
            char *p = dataReturned;
            for (int i = 0; i < numGotten; i++) { if(!isNumeric(p)) {allNumeric = false;} ; p += strlen(p); }
            if (allNumeric) 
            {
               std::vector<double> v(numGotten);
               p = dataReturned;
               for (int i = 0; i < numGotten; i++) { v[i] = asNumeric(p); p += strlen(p); }
               result = Rcpp::wrap(v);
            }
            else
            {
               std::vector<std::string> v(numGotten);
               p = dataReturned;
               for (int i = 0; i < numGotten; i++) { v[i] = p; p += strlen(p); }
               result = Rcpp::wrap(v);
            }
         }
         if (dataReturned) {apsimFree(dataReturned);}
      } else if (type == "boolean" || type == "integer4" || type == "single" || type == "double") {
         double *dataReturned = NULL;
         apsimGetNumeric(matches[i].name.c_str(), &numGotten, &dataReturned);
         if ( numGotten == 1) {
            result = Rcpp::wrap(* dataReturned);
         } else if ( numGotten > 1 ) {
            std::vector<double> v;
            for (int i = 0; i < numGotten; i++) { v.push_back(dataReturned[i]); }
            result = Rcpp::wrap(v);
         }
         if (dataReturned) {apsimFree(dataReturned);}
[foreach types.type]
      } else if (type == "[type.name]") {
         Rcpp::List l = Rcpp::List::create();
         l["name"] = matches[i].name;
         l["ddml"] = matches[i].ddml;
#ifdef __WIN32__
         typedef void* (*GET_[type.name]_HDLR)(const char *);
         GET_[type.name]_HDLR apsimGet[type.name] = (GET_[type.name]_HDLR) myDllProcAddress(RLinkDLLHandle, "apsimGet[type.name]");
         if (apsimGet[type.name] == NULL)  throw std::runtime_error(std::string("missing symbol apsimGet[type.name] in RLink"));
#endif
         R[type.name]Type *gotten = (R[type.name]Type *) apsimGet[type.name](matches[i].name.c_str());
         result = convertToList(gotten);
[endfor]
      } else {
         apsimFatalError("Dont know what to do with type " + type);
      }
   }
   return result;
}

void apsimSet( std::string variableName, SEXP value )
{
   Rcpp::Function f = Rcpp::Function("class");
   std::string className = Rcpp::as<std::string>( f(value));
   Rcpp::Function g = Rcpp::Function("length");
   int argLength = Rcpp::as<int>( g(value));
   if (argLength == 0)
     apsimFatalError("Cant set nil value to " + variableName);

   if (className == "character")
     if (argLength > 1)
       {
       std::vector<std::string> v = Rcpp::as< std::vector<std::string> >(value);
       int numbytes = 0;
       for (unsigned int i = 0; i < v.size(); i++) {numbytes += v[i].length() + 1; }
       char *buf = new char [numbytes] ;
       char *ptr = buf;
       for (unsigned int i = 0; i < v.size(); i++) { strcpy(ptr, v[i].c_str()); ptr += strlen(ptr) + 1; }
       apsimSetCharacter(variableName.c_str(), v.size(), buf);
       delete [] buf;
       }
     else
       {
       std::string v = Rcpp::as< std::string >(value);
       apsimSetCharacter(variableName.c_str(), 1, const_cast<char *>(v.c_str()));
       }
   else if (className == "numeric")
     if (argLength > 1)
       {
       std::vector<double> v = Rcpp::as< std::vector<double> >(value);
       double *buf = new double [v.size()] ;
       for (unsigned int i = 0; i < v.size(); i++) { buf[i] = v[i]; }
       apsimSetNumeric(variableName.c_str(), v.size(), buf);
       delete [] buf;
       }
     else
       {
       double v = Rcpp::as< double >(value);
       apsimSetNumeric(variableName.c_str(), 1, &v);
       }
   else if (className == "list")
       {
       Rcpp::List args( value );
       if (args.length() != 2) {apsimFatalError("Expected a two member list (type, data()) as second argument to apsimSet(" + variableName + ")");}
       std::string type = Rcpp::as< std::string >( args[0] );
       SEXP s = args[1];
       Rcpp::List data (s);
       if (type == "<undefined>")
          {
           // nothing
[foreach types.type]
          } else if (type == "[type.name]") {
            R[type.name]Type *d = make[type.name]Type(data);
#ifdef __WIN32__
            typedef void (*SET_[type.name]_HDLR)(const char *, R[type.name]Type *);
            SET_[type.name]_HDLR apsimSet[type.name] = (SET_[type.name]_HDLR) myDllProcAddress(RLinkDLLHandle, "apsimSet[type.name]");
            if (apsimSet[type.name] == NULL)  throw std::runtime_error(std::string("missing symbol apsimSet[type.name] in RLink"));
#endif
            apsimSet[type.name](variableName.c_str(), d);
            delete d;
[endfor]
          } else {
            apsimFatalError("Unknown type " + type + " when setting apsim variable");
          }
       }
   else
     apsimFatalError("Unknown class " + className);

   return;
}

[endfile]
[file RLink.def]
LIBRARY RLink.dll
EXPORTS
  createComponent = _createComponent@4
  _createcomponent = _createComponent@4
  _createcomponent@4 = _createComponent@4
  deleteComponent = _deleteComponent@4
  _deletecomponent = _deleteComponent@4
  _deletecomponent@4 = _deleteComponent@4
  getDescription = _getDescription@8
  _getdescription = _getDescription@8
  _getdescription@8 = _getDescription@8
  getDescriptionLength = _getDescriptionLength@8
  _getdescriptionlength = _getDescriptionLength@8
  _getdescriptionlength@8 = _getDescriptionLength@8
  wrapperDLL = _wrapperDLL@4
  _wrapperdll = _wrapperDLL@4
  _wrapperdll@4 = _wrapperDLL@4
  apsimFree@4 = _apsimFree@4
  apsimPublishNull = _apsimPublishNull@4
  apsimPublishNull@4 = _apsimPublishNull@4
  apsimGetCharacter = _apsimGetCharacter@12
  apsimGetCharacter@12 = _apsimGetCharacter@12
  apsimGetNumeric = _apsimGetNumeric@12
  apsimGetNumeric@12 = _apsimGetNumeric@12
  apsimSetCharacter = _apsimSetCharacter@12
  apsimSetCharacter@12 = _apsimSetCharacter@12
  apsimSetNumeric = _apsimSetNumeric@12
  apsimSetNumeric@12 = _apsimSetNumeric@12
 [foreach types.type]
  apsimPublish[type.name] = _apsimPublish[type.name]@8
  apsimGet[type.name] = _apsimGet[type.name]@4
  apsimSet[type.name] = _apsimSet[type.name]@8
 [endfor]
  apsimSubscribeRaw@12 = _apsimSubscribeRaw@12
  apsimExposeRaw@8 = _apsimExposeRaw@8
  apsimQueryRaw@12 = _apsimQueryRaw@12
  apsimFatalErrorRaw@4 = _apsimFatalErrorRaw@4
  apsimfatalerrorraw = _apsimFatalErrorRaw@4
  apsimfatalerrorraw@4 = _apsimFatalErrorRaw@4

[endfile]
[file REmbed.def]
LIBRARY REmbed.dll
EXPORTS

[endfile]
