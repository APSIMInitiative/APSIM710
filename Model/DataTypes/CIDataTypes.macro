##################################################
[file ../ComponentInterface/DataTypes.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef DataTypesH
#define DataTypesH
#include <General/stl_functions.h>
#include <General/TreeNodeIterator.h>
#include <General/xml.h>

#include <ComponentInterface/MessageData.h>
#include <ComponentInterface/MessageDataExt.h>
#include <ComponentInterface/Type.h>
#include <ComponentInterface/Interfaces.h>
#include <ComponentInterface/ApsimVariant.h>

// Maximum Array Size for fortran arrays
#define max_array_size 100

namespace protocol {

//-------------------- Built in types
#define nullTypeDDML "<type/>"
[foreach types.builtin]
   std::string EXPORT DDML(const [builtin.cpptype]& value);
[endfor]

[foreach types.type]
//-------------------- [type.name]Type
struct [type.name]Type
   {
   [foreach type.field]
   [field.cpptype] [field.name];
   [endfor]
   };
struct F[type.name]Type
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   F[field.ctype]Type [field.name][max_array_size];
   [elseif [field.arrayandstring] = T]
   char [field.name][max_array_size*max_array_size];
   [elseif [field.array] = T]
   [field.ctype] [field.name][max_array_size];
   [elseif [field.structure] = T]
   F[field.cpptype] [field.name];
   [elseif [field.cpptype] = std::string]
   char [field.name][max_array_size];
   [else]
   [field.cpptype] [field.name];
   [endif]
   [if [field.array] = T]
   unsigned num_[field.name];
   [endif]
   [endfor]
   };
inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const [type.name]Type& data)
   {
   [foreach type.field]
   messageData << data.[field.name];
   [endfor]
   return messageData;
   }
inline protocol::MessageData& operator>>(protocol::MessageData& messageData, [type.name]Type& data)
   {
   [foreach type.field]
   messageData >> data.[field.name];
   [endfor]
   return messageData;
   }
inline void unpack(protocol::ApsimVariant& apsimVar, [type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   throw runtime_error("Cannot unpack a complex structure from an APSIMVariant");
   [elseif [field.structure] = T]
   throw runtime_error("Cannot unpack a complex structure from an APSIMVariant");
   [else]
   apsimVar.get("[field.name]", data.[field.name]);
   [endif]
   [endfor]
   }   
std::string EXPORT DDML(const [type.name]Type& value);
std::string EXPORT DDML(const F[type.name]Type& value);
inline unsigned int memorySize(const [type.name]Type& data)
   {
   return 0
   [foreach type.field]
      + protocol::memorySize(data.[field.name])
   [endfor];
   }
inline unsigned int memorySize(const F[type.name]Type& data)
   {
   unsigned size = 0;
   [foreach type.field]
      [if [field.arrayandstring] = T]
      size += 4;
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         size += protocol::memorySize(FString(&data.[field.name][i*max_array_size], max_array_size, FORString));
      [elseif [field.array] = T]
      size += 4;
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         size += protocol::memorySize(data.[field.name][i]);
      [elseif [field.cpptype] = std::string]
      size += protocol::memorySize(FString(data.[field.name], max_array_size, FORString));
      [else]
      size += protocol::memorySize(data.[field.name]);
      [endif]
   [endfor];
   return size;
   }
void Init[type.name]([type.name]Type& data, const std::string& xml);

[endfor]
} // protocol
#endif


[endfile]


##################################################
[file ../ComponentInterface/DataTypes.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
#include <boost/lexical_cast.hpp>
#include <General/stl_functions.h>
#include <General/TreeNodeIterator.h>
#include <General/xml.h>
#include <General/platform.h>

#include <ComponentInterface/Messages.h>
#include "DataTypes.h"
#include <ComponentInterface/Component.h>

namespace protocol {
[foreach types.builtin]
std::string EXPORT DDML(const [builtin.cpptype]& value)
   {
   return [builtin.cddml];
   }
[endfor]
} // protocol

[foreach types.type]
namespace protocol {
void Init[type.name]([type.name]Type& data, const std::string& xml)
   {
   XMLDocument doc(xml, XMLDocument::xmlContents);
   XMLNode::iterator childI = doc.documentElement();
   [foreach type.field]
   childI = std::find_if(doc.documentElement().begin(),
                         doc.documentElement().end(),
                         EqualToName<XMLNode>("[field.name]"));

   [if [field.arrayofstructures] = T]
   // Don't know yet
   [elseif [field.array] = T]
   StringToContainer<[field.cpptype], [field.rawcpptype]> (childI->getValue(), data.[field.name]);

   [elseif [field.structure] = T]
   // Don't know yet
   [else]
   data.[field.name] = boost::lexical_cast<[field.cpptype]> (childI->getValue());
   [endif]
   [endfor]
   }

std::string EXPORT DDML(const [type.name]Type& value)
   {
   return [type.cddml];
   }
std::string EXPORT DDML(const F[type.name]Type& value)
   {
   return [type.cddml];
   }
}; // namespace protocol
[endfor]

[endfile]

##################################################
[file ../FortranInfrastructure/DataTypes.f90]
! ------------------------------------------------------------------
! NB: Autogenerated. Do not modify manually.
! ------------------------------------------------------------------
module dataTypes
   integer, parameter :: max_array_size = 100

   !-------------------- Built in types
   character(len=*), parameter :: nullTypeDDML = '<type/>'
[foreach types.builtin]
   character(len=*), parameter :: [builtin.name]TypeDDML = &
      [builtin.forddml]

[endfor]


[foreach types.type]
!-------------------- [type.name]Type
   character(len=*), parameter :: [type.name]TypeDDML = &
      [type.forddml]
   type [type.name]Type
      sequence
      [foreach type.field]
      [if [field.arrayofstructures] = T]
      type([field.fortype]Type):: [field.name](max_array_size)
      [elseif [field.structure] = T]
      type([field.fortype]Type) :: [field.name]
      [elseif [field.array] = T]
      [field.fortype] :: [field.name](max_array_size)
      [else]
      [field.fortype] :: [field.name]
      [endif]
      [if [field.array] = T]
      integer :: num_[field.name]
      [endif]
      [endfor]
   end type [type.name]Type

[endfor]
end module dataTypes
[endfile]



##################################################
[file ../FortranComponentInterface/FortranDataTypes.cpp]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
#include <boost/lexical_cast.hpp>
#include <General/stl_functions.h>
#include <General/TreeNodeIterator.h>
#include <General/xml.h>
#include <General/platform.h>

#include <ComponentInterface/Messages.h>
#include <ComponentInterface/DataTypes.h>
#include <ComponentInterface/Component.h>
#include <FortranComponentInterface/FORTRANComponentWrapper.h>

extern "C" void EXPORT STDCALL publish_null(unsigned* id)
   {
   FortranWrapper::currentInstance->publishNull(*id);
   }
[foreach types.type]
namespace protocol {
   inline protocol::MessageData& operator<<(protocol::MessageData& messageData, const F[type.name]Type& data)
      {
      [foreach type.field]
      [if [field.arrayandstring] = T]
      messageData << data.num_[field.name];
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         messageData << FString(&data.[field.name][i*max_array_size], max_array_size, FORString);
      [elseif [field.array] = T]
      messageData << data.num_[field.name];
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         messageData << data.[field.name][i];
      [elseif [field.rawcpptype] = std::string]
      messageData << FString(data.[field.name], max_array_size, FORString);
      [else]
      messageData << data.[field.name];
      [endif]
      [endfor]
      return messageData;
      }
   inline protocol::MessageData& operator>>(protocol::MessageData& messageData, F[type.name]Type& data)
      {
      [foreach type.field]
      [if [field.arrayandstring] = T]
      messageData >> data.num_[field.name];
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         {
         FString [field.name]String(&data.[field.name][i*max_array_size], max_array_size, EmptyString);
         FString [field.name]Alias;
         messageData >> [field.name]Alias;
         [field.name]String = [field.name]Alias;
         }
      [elseif [field.array] = T]
      messageData >> data.num_[field.name];
      for (unsigned i = 0; i != data.num_[field.name]; i++)
         messageData >> data.[field.name][i];
      [elseif [field.rawcpptype] = std::string]
      FString [field.name]String(data.[field.name], max_array_size, EmptyString);
      FString [field.name]Alias;
      messageData >> [field.name]Alias;
      [field.name]String = [field.name]Alias;
      [else]
      messageData >> data.[field.name];
      [endif]
      [endfor]
      return messageData;
      }
}
void unpack(protocol::ApsimVariant& apsimVar, protocol::F[type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   throw std::runtime_error("APSIMVariant cannot be used for complex types"); 	
   [elseif [field.structure] = T]
   throw std::runtime_error("APSIMVariant cannot be used for complex types"); 	
   [elseif [field.arrayandstring] = T]
   FStrings [field.name]Values(data.[field.name], max_array_size, max_array_size, EmptyString);  
   apsimVar.get("[field.name]", [field.name]Values);
   data.num_[field.name] = [field.name]Values.getNumElements();
   [elseif [field.array] = T]
   throw std::runtime_error("APSIMVariant array types not implemented"); 	
   [elseif [field.rawcpptype] = std::string]
   FString [field.name]String(data.[field.name], max_array_size, EmptyString);
   FString [field.name]Alias;
   apsimVar.get("[field.name]", [field.name]Alias);
   [field.name]String = [field.name]Alias;
   [else]
   apsimVar.get("[field.name]", data.[field.name]);
   [endif]
   [endfor]
   }
extern "C" void EXPORT STDCALL publish_[type.name](unsigned* id, const protocol::F[type.name]Type* data)
   {
   FortranWrapper::currentInstance->publish(*id, *data);
   }
extern "C" void EXPORT STDCALL unpack_[type.name](protocol::Variant* variant, protocol::F[type.name]Type* data)
   {
   memset(data, 0, sizeof(*data));
   if (variant->isApsimVariant())
      {
      protocol::ApsimVariant ApsimVar(*variant);
      unpack(ApsimVar, *data);
      }
   else
      variant->unpack(*data);
   }
[endfor]

[endfile]



##################################################
[file ../FortranInfrastructure/DataTypesInterface.f90]
! ------------------------------------------------------------------
! NB: Autogenerated. Do not modify manually.
! ------------------------------------------------------------------
module dataTypesInterface
   use DataTypes
   interface

   subroutine publish_null(id)
   ml_external publish_null
!STDCALL(publish_null)
   integer :: id
   end subroutine

   [foreach types.type]
   subroutine publish_[type.name](id, data)
   IMPORT :: [type.name]Type
   ml_external publish_[type.name]
!STDCALL(publish_[type.name])
   integer :: id
   type([type.name]Type) :: data
   end subroutine
   subroutine unpack_[type.name](variant, data)
   IMPORT :: [type.name]Type
   ml_external unpack_[type.name]
!STDCALL(unpack_[type.name])
   integer :: variant
   type([type.name]Type) :: data
   end subroutine
   [endfor]

   end interface
end module dataTypesInterface

[endfile]

##################################################
[file ../TclLink/CIDataTypes.tcl]
;# Automatically generated - do not edit

proc unpack_Variant {data} {
   array set result {}
   set ok [expr [string bytelength $data] > 0]
   while {$ok} {
      set nchar 0
      binary scan $data i nchar
      if {$nchar > 0} {
         set name [string range $data 4 [expr 4+$nchar-1]]         ;# Name
         set data [string range $data [expr 4+$nchar] end]
         binary scan $data iic nchar typeCode isArray              ;# type & array flag
         set data [string range $data 9 end]
         if {$isArray} {binary scan $data i nelem; set data [string range $data 4 end]} else {set nelem 1}
         set value {}
         if {$typeCode == 8} {
            for {set i 0} {$i < $nelem} {incr i} {
               binary scan $data i nchar                              ;# string value
               lappend value [string range $data 4 [expr 4+$nchar-1]]
               set data [string range $data [expr 4+$nchar] end]
            }  
         } elseif {$typeCode == 2} {
            for {set i 0} {$i < $nelem} {incr i} {
               binary scan $data i datum                              ;# integer
               lappend value $datum
               set data [string range $data 4 end]
            }   
         } elseif {$typeCode == 4} {
            for {set i 0} {$i < $nelem} {incr i} {
               binary scan $data f datum                              ;# float
               lappend value $datum
               set data [string range $data 4 end]
            }   
         } elseif {$typeCode == 5} {
            for {set i 0} {$i < $nelem} {incr i} {
               binary scan $data d datum                              ;# double
               lappend value $datum
               set data [string range $data 8 end]
            }   
         } else {
            ;#set value "<undef>"
            error "Unhandled variant typecode $typeCode"
         }
         set result($name) $value
         set ok [expr [string bytelength $data] > 0]
      } else {
         set ok 0
      }
   }
   return [array get result]
}


proc unpack_MessageData {data} {
   binary scan $data ii result(id) result(publishedByID)  ;# id, publishedByID
   set data [string range $data 8 end]

   set nchar 0
   binary scan $data i nchar                              ;# typeXML
   if {$nchar > 0} {
     set result(typeXML) [string range $data 4 [expr 4+$nchar-1]]
     set data [string range $data [expr 4+$nchar] end]
   } else {
     set result(typeXML) ""
   }

   set ok [expr [string bytelength $data] > 0]
   while {$ok} {
      set nchar 0
      binary scan $data i nchar
      if {$nchar > 0} {
         ;##//messageData << variableName << protocol::memorySize(value)+5 << typeCode << isArray << value;
         set name [string range $data 4 [expr 4+$nchar-1]]         ;# Name
         set data [string range $data [expr 4+$nchar] end]
         binary scan $data iic nchar5 typeCode isArray             ;# type & array flag
         set data [string range $data 9 end]
         if {$typeCode == 8} {
            binary scan $data i nchar                              ;# string value
            set value [string range $data 4 [expr 4+$nchar-1]]
            set data [string range $data [expr 4+$nchar] end]
         } elseif {$typeCode == 2} {
            binary scan $data i value                              ;# integer
            set data [string range $data 4 end]
         } elseif {$typeCode == 4} {
            binary scan $data f value                              ;# float
            set data [string range $data 4 end]
         } elseif {$typeCode == 5} {
            binary scan $data d value                              ;# double
            set data [string range $data 8 end]
         } else {
            ;#set value "<undef>"
            error "Unhandled variant typecode $typeCode"
         }
         set result($name) $value
         set ok [expr [string bytelength $data] > 0]
      } else {
         set ok 0
      }
   }
   return [array get result]
}

[foreach types.type]
proc unpack_[type.name] {data} {
[foreach type.field]
[if [field.array] = T]
   binary scan $data i n ; set data [string range $data 4 end]
   for {set i 0} {$i < $n} {incr i} {
      set idx ".$i"
[else]
      set idx ""
[endif]
 [if [field.rawcpptype] = double]
     binary scan $data d result([field.name]$idx); set data [string range $data 8 end]
 [elseif [field.rawcpptype] = bool]
     binary scan $data i result([field.name]$idx); set data [string range $data 4 end]
 [elseif [field.rawcpptype] = int]
     binary scan $data i result([field.name]$idx); set data [string range $data 4 end]
 [elseif [field.rawcpptype] = float]
     binary scan $data f result([field.name]$idx); set data [string range $data 4 end]
 [elseif [field.rawcpptype] = std::string]
     binary scan $data i stringlength ; set data [string range $data 4 end]
     binary scan $data a$stringlength result([field.name]$idx) ; set data [string range $data $stringlength end]
 [else]
     array set result [process_ddml [type.cddml] $data]
 [endif]
[if [field.array] = T]
   }
[endif]
[endfor]
   if {[string bytelength $data] != 0 && [info exists result(ddml)]} {
      array set result [process_ddml $result(ddml) $data]
   }
   return [array get result]
}

proc pack_[type.name] {args} {
   foreach {_name _value} $args { set ${_name} ${_value} }
[foreach type.field]
[if [field.array] = T]
   append _msg [binary format d [llength $[field.name]]]
   for {set i 0} {$i < [llength $[field.name]]} {incr i} {
     set _field [lindex $[field.name] $i]
[elseif [field.rawcpptype] = double]
     if {[info exists [field.name]] } {set _field $[field.name]} else { set _field  0.0 }
[elseif [field.rawcpptype] = bool]
     if {[info exists [field.name]] } {set _field $[field.name]} else { set _field  0 }
[elseif [field.rawcpptype] = int]
     if {[info exists [field.name]] } {set _field $[field.name]} else { set _field  0 }
[elseif [field.rawcpptype] = float]
     if {[info exists [field.name]] } {set _field $[field.name]} else { set _field  0.0 }
[elseif [field.rawcpptype] = std::string]
     if {[info exists [field.name]] } {set _field $[field.name]} else { set _field  "" }
[else]
     error "cant deal with [field.rawcpptype] yet"
[endif]
 [if [field.rawcpptype] = double]
     append _msg [binary format d ${_field}]
 [elseif [field.rawcpptype] = bool]
     append _msg [binary format i ${_field}] 
 [elseif [field.rawcpptype] = int]
     append _msg [binary format i ${_field}] 
 [elseif [field.rawcpptype] = float]
     append _msg [binary format f ${_field}]
 [elseif [field.rawcpptype] = std::string]
     append _msg [binary format i [string length ${_field}]]
     append _msg [binary format a[string length ${_field}] ${_field}]
 [endif]
 
[if [field.array] = T]
   }
[endif]
[endfor]
   return ${_msg}
}
[endfor]

package require tdom
proc process_ddml {ddml chunk} {
   set doc [dom parse $ddml]
   set docroot [$doc documentElement]
   array set result [list data $chunk]
   if {[catch {array set result [process_node $docroot $result(data)]} msg]} {
      lappend result(emsg) "Error:$msg"
      puts "Error:$msg"
   }
   if {[string bytelength $result(data)] > 0} {
      lappend result(emsg) "NB. unread data ([string bytelength $result(data)] bytes)"
   }
   return [array get result]
}

proc process_node {node chunk} {
   array set result [list data $chunk]
   if {[$node hasAttribute "name"]} {set name [$node getAttribute "name"]} else {set name "<anonymous>"}
   if {[$node hasAttribute "array"] && [$node getAttribute "array"] == "T"} {
     # Array types
     if {[$node hasAttribute "kind"]} {
        set kind [$node getAttribute "kind"]
        if {[binary scan $result(data) i n] == 1} {
           set result(data) [string range $result(data) 4 end]
        } else {
           set n 0
        }
        if {$kind == "double"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) d x]==1} {lappend arr $x; set result(data) [string range $result(data) 8 end]} else {error "error reading array double"}
          }
          lappend result($name) $arr
        } elseif {$kind == "boolean"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading array bool"}
          }
          lappend result($name) $arr
        } elseif {$kind == "integer4"} {
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading arrray int"}
          }
          lappend result($name) $arr
        } elseif {$kind == "single"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) f x]==1} {lappend arr $x; set result(data) [string range $result(data) 4 end]} else {error "error reading array float (at $i of $n)"}
          }
          lappend result($name) $arr
        } elseif {$kind == "string"} {
          set arr $name
          for {set i 0} {$i < $n} {incr i} {
             if {[binary scan $result(data) i stringlength] ==  1} {
                set result(data) [string range $result(data) 4 end]
                if {[binary scan $result(data) a$stringlength x]==1} {lappend arr $x; set result(data) [string range $result(data) $stringlength end]} else {error "error reading array string of $stringlength bytes"}
             }
          }
          lappend result($name) $arr
        } else {
          error "unimplemented array type kind=$kind"
        }
     } else {
        # an array of structures of some sort. Should probably do this $n times
        foreach child [$node childNodes] {
           array set result [process_node $child $result(data)]
        }
     }
  } else {
     if {[$node hasAttribute "kind"]} {
        set kind [$node getAttribute "kind"]
        # Scalar types
        if {$kind == "double"} {
          if {[binary scan $result(data) d x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 8 end]} else {error "error reading scalar double"}
        } elseif {$kind == "boolean"} {
          if {[binary scan $result(data) i x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar bool"}
        } elseif {$kind == "integer4"} {
          if {[binary scan $result(data) i x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar int"}
        } elseif {$kind == "single"} {
          if {[binary scan $result(data) f x]==1} {lappend result($name) $x; set result(data) [string range $result(data) 4 end]} else {error "error reading scalar float"}
        } elseif {$kind == "string"} {
          if {[binary scan $result(data) i stringlength]==1} {
             set result(data) [string range $result(data) 4 end]
             if {[binary scan $result(data) a$stringlength x]==1} {lappend result($name) $x; set result(data) [string range $result(data) $stringlength end]}  else {error "error reading scalar string ($stringlength bytes)"}
          } else {
             error "error reading scalar string length"
          }
        } else {
          error "unimplemented scalar type kind=$kind"
        }
     } else {
        # a structure of some sort
        foreach child [$node childNodes] {
           array set result [process_node $child $result(data)]
        }
     }
   }
   return [array get result]
}
[endfile]

[file ../FortranComponentInterface/FortranComponentInterface.def]
; ------------------------------------------------------------------
; NB: Autogenerated. Do not modify manually.
; ------------------------------------------------------------------
LIBRARY FortranComponentInterface.dll
EXPORTS
  Fatal = _Fatal@8
  _fatal = _Fatal@8
  _fatal@8 = _Fatal@8
  Warning = _Warning@8
  _warning = _Warning@8
  _warning@8 = _Warning@8
  add_reg = _add_reg@36
  _add_reg = _add_reg@36
  add_registration = _add_registration@28
  _add_registration = _add_registration@28
  add_registration_with_units = _add_registration_with_units@28
  _add_registration_with_units = _add_registration_with_units@28
  change_component_order = _change_component_order@12
  _change_component_order = _change_component_order@12
  collect_char_array = _collect_char_array@32
  _collect_char_array = _collect_char_array@32
  collect_char_array_optional = _collect_char_array_optional@32
  _collect_char_array_optional = _collect_char_array_optional@32
  collect_char_var = _collect_char_var@28
  _collect_char_var = _collect_char_var@28
  collect_char_var_optional = _collect_char_var_optional@28
  _collect_char_var_optional = _collect_char_var_optional@28
  collect_double_array = _collect_double_array@36
  _collect_double_array = _collect_double_array@36
  collect_double_var = _collect_double_var@32
  _collect_double_var = _collect_double_var@32
  collect_double_var_optional = _collect_double_var_optional@32
  _collect_double_var_optional = _collect_double_var_optional@32
  collect_integer_var = _collect_integer_var@32
  _collect_integer_var = _collect_integer_var@32
  collect_integer_var_optional = _collect_integer_var_optional@32
  _collect_integer_var_optional = _collect_integer_var_optional@32
  collect_real_array = _collect_real_array@36
  _collect_real_array = _collect_real_array@36
  collect_real_array_optional = _collect_real_array_optional@36
  _collect_real_array_optional = _collect_real_array_optional@36
  collect_real_var = _collect_real_var@32
  _collect_real_var = _collect_real_var@32
  collect_real_var_optional = _collect_real_var_optional@32
  _collect_real_var_optional = _collect_real_var_optional@32
  component_id_to_name = _component_id_to_name@12
  _component_id_to_name = _component_id_to_name@12
  component_name_to_id = _component_name_to_id@12
  _component_name_to_id = _component_name_to_id@12
  createInstance = _createInstance@24
  _createinstance = _createInstance@24
  _createinstance@24 = _createInstance@24
  deleteInstance = _deleteInstance@4
  _deleteinstance = _deleteInstance@4
  _deleteinstance@4 = _deleteInstance@4
  delete_postbox = _delete_postbox@0
  _delete_postbox = _delete_postbox@0
  event_send = _event_send@12
  _event_send = _event_send@12
  fast_index = _fast_index@16
  _fast_index = _fast_index@16
  float_to_string = _float_to_string@12
  _float_to_string = _float_to_string@12
  fci_getDescriptionInternal = _FCI_getDescriptionInternal@8
  _fci_getdescriptioninternal = _FCI_getDescriptionInternal@8
  _fci_getdescriptioninternal@8 = _FCI_getDescriptionInternal@8
  fci_getDescriptionLengthInternal = _FCI_getDescriptionLengthInternal@8
  _fci_getdescriptionlengthinternal = _FCI_getDescriptionLengthInternal@8
  _fci_getdescriptionlengthinternal@8 = _FCI_getDescriptionLengthInternal@8
  get_char_var = _get_char_var@32
  _get_char_var = _get_char_var@32
  get_char_var_optional = _get_char_var_optional@32
  _get_char_var_optional = _get_char_var_optional@32
  get_char_vars = _get_char_vars@32
  _get_char_vars = _get_char_vars@32
  get_componentData = _get_componentData@0
  _get_componentdata = _get_componentData@0
  _get_componentdata@0 = _get_componentData@0
  get_componentID = _get_componentID@0
  _get_componentid = _get_componentID@0
  _get_componentid@0 = _get_componentID@0
  get_double_array = _get_double_array@40
  _get_double_array = _get_double_array@40
  get_double_var = _get_double_var@36
  _get_double_var = _get_double_var@36
  get_double_var_optional = _get_double_var_optional@36
  _get_double_var_optional = _get_double_var_optional@36
  get_double_vars = _get_double_vars@36
  _get_double_vars = _get_double_vars@36
  get_fq_name = _get_fq_name@8
  _get_fq_name = _get_fq_name@8
  get_integer_var = _get_integer_var@36
  _get_integer_var = _get_integer_var@36
  get_integer_vars = _get_integer_vars@36
  _get_integer_vars = _get_integer_vars@36
  get_name = _get_name@8
  _get_name = _get_name@8
  get_parentID = _get_parentID@0
  _get_parentid = _get_parentID@0
  _get_parentid@0 = _get_parentID@0
  get_posting_module = _get_posting_module@0
  _get_posting_module = _get_posting_module@0
  get_real_array = _get_real_array@40
  _get_real_array = _get_real_array@40
  get_real_array_optional = _get_real_array_optional@40
  _get_real_array_optional = _get_real_array_optional@40
  get_real_arrays = _get_real_arrays@40
  _get_real_arrays = _get_real_arrays@40
  get_real_var = _get_real_var@36
  _get_real_var = _get_real_var@36
  get_real_var_optional = _get_real_var_optional@36
  _get_real_var_optional = _get_real_var_optional@36
  get_real_vars = _get_real_vars@36
  _get_real_vars = _get_real_vars@36
  get_setVariableSuccess = _get_setVariableSuccess@0
  _get_setvariablesuccess = _get_setVariableSuccess@0
  _get_setvariablesuccess@0 = _get_setVariableSuccess@0
  messageToLogic = _messageToLogic@12
  _messagetologic = _messageToLogic@12
  _messagetologic@12 = _messageToLogic@12
  message_unused = _message_unused@0
  _message_unused = _message_unused@0
  new_postbox = _new_postbox@0
  _new_postbox = _new_postbox@0
  pop_routine = _pop_routine@8
  _pop_routine = _pop_routine@8
  post_char_array = _post_char_array@28
  _post_char_array = _post_char_array@28
  post_char_var = _post_char_var@24
  _post_char_var = _post_char_var@24
  post_double_array = _post_double_array@24
  _post_double_array = _post_double_array@24
  post_double_var = _post_double_var@20
  _post_double_var = _post_double_var@20
  post_integer_var = _post_integer_var@20
  _post_integer_var = _post_integer_var@20
  post_real_array = _post_real_array@24
  _post_real_array = _post_real_array@24
  post_real_var = _post_real_var@20
  _post_real_var = _post_real_var@20
  publish_null = _publish_null@4
  _publish_null = _publish_null@4
  push_routine = _push_routine@8
  _push_routine = _push_routine@8
  read_parameter = _read_parameter@28
  _read_parameter = _read_parameter@28
  respond2get_char_array = _respond2get_char_array@28
  _respond2get_char_array = _respond2get_char_array@28
  respond2get_char_var = _respond2get_char_var@24
  _respond2get_char_var = _respond2get_char_var@24
  respond2get_double_array = _respond2get_double_array@24
  _respond2get_double_array = _respond2get_double_array@24
  respond2get_double_var = _respond2get_double_var@20
  _respond2get_double_var = _respond2get_double_var@20
  respond2get_integer_array = _respond2get_integer_array@24
  _respond2get_integer_array = _respond2get_integer_array@24
  respond2get_integer_var = _respond2get_integer_var@20
  _respond2get_integer_var = _respond2get_integer_var@20
  respond2get_logical_var = _respond2get_logical_var@20
  _respond2get_logical_var = _respond2get_logical_var@20
  respond2get_real_array = _respond2get_real_array@24
  _respond2get_real_array = _respond2get_real_array@24
  respond2get_real_var = _respond2get_real_var@20
  _respond2get_real_var = _respond2get_real_var@20
  respond2get_time_var = _respond2get_time_var@20
  _respond2get_time_var = _respond2get_time_var@20
  send_message = _send_message@4
  _send_message = _send_message@4
  set_char_array = _set_char_array@32
  _set_char_array = _set_char_array@32
  set_char_var = _set_char_var@28
  _set_char_var = _set_char_var@28
  set_char_var_optional = _set_char_var_optional@32
  _set_char_var_optional = _set_char_var_optional@32
  set_double_array = _set_double_array@28
  _set_double_array = _set_double_array@28
  set_double_var = _set_double_var@24
  _set_double_var = _set_double_var@24
  set_real_array = _set_real_array@28
  _set_real_array = _set_real_array@28
  set_real_var = _set_real_var@24
  _set_real_var = _set_real_var@24
  set_variable_error = _set_variable_error@4
  _set_variable_error = _set_variable_error@4
  store_in_postbox = _store_in_postbox@8
  _store_in_postbox = _store_in_postbox@8
  string_to_float = _string_to_float@12
  _string_to_float = _string_to_float@12
  strings_equal = _strings_equal@16
  _strings_equal = _strings_equal@16
  terminate_simulation = _terminate_simulation@0
  _terminate_simulation = _terminate_simulation@0
  writeStdErr = _writeStdErr@8
  _writestderr = _writeStdErr@8
  _writestderr@8 = _writeStdErr@8
  write_string = _write_string@8
  _write_string = _write_string@8
[foreach types.type]
  publish_[type.name] = _publish_[type.name]@8
[tolower]  _publish_[type.name][endtolower] = _publish_[type.name]@8
[tolower]  _publish_[type.name][endtolower]@8 = _publish_[type.name]@8
  unpack_[type.name] = _unpack_[type.name]@8
[tolower]  _unpack_[type.name][endtolower] = _unpack_[type.name]@8
[tolower]  _unpack_[type.name][endtolower]@8 = _unpack_[type.name]@8
[endfor]
[endfile]

[file ../FortranComponentInterface/FortranComponentInterface.ldscript]
/* ------------------------------------------------------------------ */
/* NB: Autogenerated. Do not modify manually.                         */
/* ------------------------------------------------------------------ */
SECTIONS {
  .data :
  {
    fatal = Fatal;
    warning = Warning;
    createinstance = createInstance;
    deleteinstance = deleteInstance;
    fci_getdescriptioninternal = FCI_getDescriptionInternal;
    fci_getdescriptionlengthinternal = FCI_getDescriptionLengthInternal;
    get_componentdata = get_componentData;
    get_componentid = get_componentID;
    get_parentid = get_parentID;
    get_setvariablesuccess = get_setVariableSuccess;
    messagetologic = messageToLogic;
[foreach types.type]
[tolower]    publish_[type.name][endtolower] = publish_[type.name];
[tolower]    unpack_[type.name][endtolower] = unpack_[type.name];
[endfor]
    writestderr = writeStdErr;
  }
}
[endfile]
