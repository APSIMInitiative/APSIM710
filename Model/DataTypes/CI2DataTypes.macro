##################################################
[file ../ComponentInterface2/DataTypes.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef DataTypesH
#define DataTypesH
#include <General/platform.h>
#include <string>
#include <vector>

class MessageData;

   //------ Null ------
   struct Null
      {
      int i;
      };

   void EXPORT pack(MessageData& messageData, const Null& data);
   void EXPORT unpack(MessageData& messageData, Null& data);
   void EXPORT unpack(MessageData& messageData, Null& data, const std::string& sourceDDML);
   unsigned EXPORT memorySize(const Null& data);
   std::string EXPORT DDML(const Null& data);

[foreach types.type]
   //------ [type.name] ------
   struct [type.name]Type
      {
      [foreach type.field]
      [field.cpptype] [field.name];
      [endfor]
      };

   void EXPORT pack(MessageData& messageData, const [type.name]Type& data);
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data);
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data, const std::string& sourceDDML);
   unsigned EXPORT memorySize(const [type.name]Type& data);
   std::string EXPORT DDML(const [type.name]Type& data);

[endfor]

#endif
[endfile]
##################################################
[file ../ComponentInterface2/DataTypes.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include "DataTypes.h"
#include "Interfaces.h"
#include "BuiltIns.h"
#include "StructureConverter.h"

   //------ Null ------
   void EXPORT pack(MessageData& messageData, const Null& data) { }
   void EXPORT unpack(MessageData& messageData, Null& data) { }
   void EXPORT unpack(MessageData& messageData, Null& data, const std::string& sourceDDML) { }
   unsigned EXPORT memorySize(const Null& data) {return 0;}
   std::string EXPORT DDML(const Null& data) {return "<type/>";}


[foreach types.type]
   //------ [type.name] ------

   void EXPORT pack(MessageData& messageData, const [type.name]Type& data)
      {
      [foreach type.field]
      pack(messageData, data.[field.name]);
      [endfor]
      }
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data)
      {
      [foreach type.field]
      unpack(messageData, data.[field.name]);
      [endfor]
      }
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data, const std::string& sourceDDML)
      {
      [foreach type.field]
      [if [field.arrayandstring] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.arrayofstructures] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.rawcpptype] = std::string]
      unpackField(messageData, sourceDDML, data.[field.name], "[field.name]");
      [elseif [field.array] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.structure] = T]
      unpack(messageData, data.[field.name], sourceDDML);
      [else]
      unpackField(messageData, sourceDDML, data.[field.name], "[field.name]");
      [endif]
      [endfor]
      }
   unsigned EXPORT memorySize(const [type.name]Type& data)
      {
      return 0
       [foreach type.field]              + ::memorySize(data.[field.name])
       [endfor]              ;
      }
   std::string EXPORT DDML(const [type.name]Type& data)
      {return [type.cddml];}

[endfor]
[endfile]

##################################################
[file ../ComponentInterface2/ScienceAPI2.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include "ScienceAPI2.h"

ScienceAPI2::ScienceAPI2() {} ;
ScienceAPI2::~ScienceAPI2() {} ;

[endfile]
##################################################
[file ../ComponentInterface2/ScienceAPI2.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef ScienceAPI2H
#define ScienceAPI2H
#include <General/platform.h>
#include <string>
#include <vector>
#include <map>
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <ComponentInterface2/DataTypes.h>
#include <ComponentInterface2/Variant.h>

// ------------------------------------------------------------------
// Interface for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

struct QueryMatch
   {
   std::string name;
   std::string ddml;
   };


class EXPORT ScienceAPI2
   {
   public:
      ScienceAPI2();
      virtual ~ScienceAPI2();

      virtual void write(const std::string& msg) = 0;
      virtual std::string name(void) = 0;
      virtual std::string FQName(void) = 0;
      virtual std::string getExecutableFileName(void) = 0;
      virtual const std::string getInitData(void) = 0;
      virtual void notifyFutureEvent(const std::string& name) = 0;

      // -----------------------------------------------------------------------
      // Return a list of all variables or components (fully qualified)
      // that match the specified pattern.
      // e.g. * will return a list of all components.
      //      wheat.* will return a list of all variables for the wheat module
      //      *.lai will return a list of all lai variables for all modules.
      // -----------------------------------------------------------------------
      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;

      // Methods for doing "search orders" when reading parameters:
      virtual void setSearchOrder(const std::vector<std::string> &)=0;
      virtual void getSearchOrder(std::vector<std::string> &)=0;

      // Methods for reading raw strings
      virtual bool readFiltered(const std::string& filterName, std::vector<std::string> &values) = 0;
      virtual bool readAll(std::vector<std::string>& names, std::vector<std::string> &values) = 0;
      virtual bool readScripts(std::map<std::string, std::string> &scripts) = 0;

      // null
      #define nullFunction(address) boost::function0<void>(boost::bind(address, this))
      #define namedNullFunction(name, address) boost::function1<void, const std::string &>(boost::bind(address, this, _1))
      virtual void subscribe(const std::string& name, boost::function0<void> handler) = 0;
      virtual void subscribe(const std::string& name, boost::function1<void, const std::string &> handler) = 0;
      virtual void publish(const std::string& name) = 0;

      [foreach types.builtin]
      // [builtin.cpptype]
      #define [builtin.name]Function(address) boost::function1<void, [builtin.cpptype]& >(boost::bind(address, this, _1))
      #define [builtin.name]Function2(name, address) boost::function2<void, const std::string &, [builtin.cpptype]& >(boost::bind(address, this, _1, _2))
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data) = 0;
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter) = 0;
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description, 
                                  boost::function2<void, const std::string &, [builtin.cpptype]&> fn) = 0;
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description, 
                                  boost::function2<void, const std::string &, [builtin.cpptype]&> getter,
                                  boost::function2<void, const std::string &, [builtin.cpptype]&> setter) = 0;

      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler) = 0;
      virtual void publish(const std::string& name, [builtin.cpptype]& data) = 0;

      [endfor]
      [foreach types.type]
      // [type.name]
      #define [type.name]Function(address) boost::function1<void, [type.name]Type& >(boost::bind(address, this, _1))
      virtual void subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler) = 0;
      virtual void publish(const std::string& name, [type.name]Type& data) = 0;

      [endfor]

      #define VariantFunction(address) boost::function1<void, Variant& >(boost::bind(address, this, _1))
      virtual void subscribe(const std::string& name, boost::function1<void, Variant&> handler) = 0;
      
      #define VariantFunction2(name, address) boost::function2<void, const std::string &, Variant& >(boost::bind(address, this, _1, _2))
      virtual void subscribe(const std::string& name, boost::function2<void, const std::string &, Variant&> handler) = 0;

      virtual void publish(const std::string& name, Variant& data) = 0;
   };
#endif
[endfile]

##################################################
[file ../ComponentInterface2/ScienceAPI2Impl.h]
#ifndef ScienceAPI2ImplH
#define ScienceAPI2ImplH
#include <General/platform.h>
#include <ComponentInterface2/ScienceAPI2.h>

class CMPComponentInterface;

// ------------------------------------------------------------------
// CMP Implementation for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class EXPORT ScienceAPI2Impl : public ScienceAPI2
   {
   private:
      CMPComponentInterface& componentInterface;
   public:
      ScienceAPI2Impl(CMPComponentInterface& componentinterface);
      virtual ~ScienceAPI2Impl();

      virtual void write(const std::string& msg);
      virtual std::string name(void);
      virtual std::string FQName(void);
      virtual std::string getExecutableFileName(void);
      virtual const std::string getInitData(void);


      virtual void setSearchOrder(const std::vector<std::string> &list);
      virtual void getSearchOrder(std::vector<std::string> &list);

      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches);

      // Methods for reading raw strings
      virtual bool readFiltered(const std::string& filterName, std::vector<std::string> &values);
      virtual bool readAll(std::vector<std::string>& names, std::vector<std::string> &values);
      virtual bool readScripts(std::map<std::string, std::string> &scripts);

      virtual void notifyFutureEvent(const std::string& name);

      // null
      virtual void subscribe(const std::string& name, boost::function0<void> handler);
      virtual void subscribe(const std::string& name, boost::function1<void, const std::string &> handler);
      virtual void publish(const std::string& name);

      [foreach types.builtin]
      // [builtin.cpptype]
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data);
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> method);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                  boost::function1<void, [builtin.cpptype]&> getter,
                                  boost::function1<void, [builtin.cpptype]&> setter);
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description, 
                                   boost::function2<void, const std::string&, [builtin.cpptype]&> method);
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                   boost::function2<void, const std::string&, [builtin.cpptype]&> getter,
                                   boost::function2<void, const std::string&, [builtin.cpptype]&> setter);
      virtual void subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler);
      virtual void publish(const std::string& name, [builtin.cpptype]& data);

      [endfor]
      [foreach types.type]
      virtual void subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler);
      virtual void publish(const std::string& name, [type.name]Type& data);

      [endfor]
      void subscribe(const std::string& name, boost::function1<void, Variant&> handler);
      void subscribe(const std::string& name, boost::function2<void, const std::string &, Variant&> handler);
      void publish(const std::string& name, Variant& data);
   };
#endif
[endfile]


##################################################
[file ../ComponentInterface2/ScienceAPI2Impl.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------


#include <ComponentInterface2/ScienceAPI2Impl.h>
#include <ComponentInterface2/CMPData.h>
#include <ComponentInterface2/CMPComponentInterface.h>

using namespace std;
ScienceAPI2Impl::ScienceAPI2Impl(CMPComponentInterface& componentinterface)
   : componentInterface(componentinterface)  {}

ScienceAPI2Impl::~ScienceAPI2Impl() {}

string ScienceAPI2Impl::name(void)
   {return componentInterface.getName();}
string ScienceAPI2Impl::FQName(void)
   {return componentInterface.getFQName();}
string ScienceAPI2Impl::getExecutableFileName(void)
   {return componentInterface.getExecutableFileName();}
const std::string ScienceAPI2Impl::getInitData(void) 
   {return componentInterface.getInitData();}
void ScienceAPI2Impl::write(const string& msg)
   {
   componentInterface.write(msg);
   }

void ScienceAPI2Impl::query(const string& pattern, vector<QueryMatch>& matches)
   {
   componentInterface.query(pattern, matches);
   }

void ScienceAPI2Impl::setSearchOrder(const std::vector<string> &list) {componentInterface.setSearchOrder(list);};
void ScienceAPI2Impl::getSearchOrder(std::vector<string> &list) {componentInterface.getSearchOrder(list);};

bool ScienceAPI2Impl::readFiltered(const string& filterName, vector<string> &values)
   {return componentInterface.readFiltered(filterName, values);}
bool ScienceAPI2Impl::readAll(std::vector<std::string>& names, std::vector<std::string> &values)
   {return componentInterface.readAll(names, values);}
bool ScienceAPI2Impl::readScripts(std::map<std::string, std::string> &scripts)
   {return componentInterface.readScripts(scripts);}

void ScienceAPI2Impl::notifyFutureEvent(const std::string& name)
   {
   return componentInterface.notifyFutureEvent(name);
   }

// null
void ScienceAPI2Impl::subscribe(const std::string& name, boost::function0<void> handler)
   {componentInterface.subscribe(name, new NullMethod(handler));}
void ScienceAPI2Impl::subscribe(const std::string& name, boost::function1<void, const std::string &> handler)
   {componentInterface.subscribe(name, new NamedNullMethod(name, handler));}
void ScienceAPI2Impl::publish(const std::string& name)
   {
   Null dummy;
   componentInterface.publish(name, new PackableWrapper<Null>(dummy));
   }

[foreach types.builtin]
// [builtin.cpptype]
[if [builtin.boundable] = T]
bool ScienceAPI2Impl::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   Convertable* temp = new CMPBuiltIn<[builtin.cpptype]& >(data);
   bool ok = componentInterface.read(name, temp, optional);
   delete temp;
   return ok;
   }
[endif]
bool ScienceAPI2Impl::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   Convertable* temp = new CMPBuiltInBounded<[builtin.cpptype]&, [builtin.ctype] >(name, data, lower, upper);
   bool ok = componentInterface.read(name, temp, optional);
   [else]
   Convertable* temp = new CMPBuiltIn<[builtin.cpptype]& >(data);
   bool ok = componentInterface.read(name, temp, optional);
   [endif]
   delete temp;
   return ok;
   }
[if [builtin.boundable] = T]
bool ScienceAPI2Impl::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype]& >(data));
   }
[endif]
bool ScienceAPI2Impl::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   return componentInterface.get(name, units, optional, new CMPBuiltInBounded<[builtin.cpptype]&, [builtin.ctype] >(name, data, lower, upper));
   [else]
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype]& >(data));
   [endif]
   }

void ScienceAPI2Impl::set(const std::string& name, const std::string& units, [builtin.cpptype]& data)
   {componentInterface.set(name, units, new CMPBuiltIn<[builtin.cpptype]& >(data));}
void ScienceAPI2Impl::expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable)
   {componentInterface.expose(name, units, description, writable, new CMPBuiltIn<[builtin.cpptype]& >(variable));}
void ScienceAPI2Impl::exposeFunction(const std::string& name, const std::string& units, const std::string& description, boost::function1<void, [builtin.cpptype]&> fn)
   {componentInterface.expose(name, units, description, false, new Method<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] >(fn));}
void ScienceAPI2Impl::exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                   boost::function1<void, [builtin.cpptype]&> getter,
                                   boost::function1<void, [builtin.cpptype]&> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new DualMethod<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (getter, setter));
   }
void ScienceAPI2Impl::exposeFunction2(const std::string& name, const std::string& units, const std::string& description, 
                                     boost::function2<void, const std::string &, [builtin.cpptype]&> fn)
   {
   componentInterface.expose(name, units, description, false, 
                             new NamedMethod<boost::function2<void, const std::string &, [builtin.cpptype]&>, [builtin.cpptype] >(name, fn));
   }
void ScienceAPI2Impl::exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                     boost::function2<void, const std::string&, [builtin.cpptype]&> getter,
                                     boost::function2<void, const std::string&, [builtin.cpptype]&> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new NamedDualMethod<boost::function2<void, const std::string&, [builtin.cpptype]&>, [builtin.cpptype] > (name, getter, setter));
   }
   
void ScienceAPI2Impl::subscribe(const std::string& name, boost::function1<void, [builtin.cpptype]&> handler)
   {componentInterface.subscribe(name, new Method<boost::function1<void, [builtin.cpptype]&>, [builtin.cpptype] > (handler));}
void ScienceAPI2Impl::publish(const std::string& name, [builtin.cpptype]& data)
   {componentInterface.publish(name, new CMPBuiltIn<[builtin.cpptype]& >(data));}

[endfor]
[foreach types.type]
void ScienceAPI2Impl::subscribe(const std::string& name, boost::function1<void, [type.name]Type&> handler)
     {componentInterface.subscribe(name, new MethodWithStructureConverter<boost::function1<void, [type.name]Type&>, [type.name]Type > (handler));}
void ScienceAPI2Impl::publish(const std::string& name, [type.name]Type& data)
     {componentInterface.publish(name, new PackableWrapper< [type.name]Type& >(data));}

[endfor]

void ScienceAPI2Impl::subscribe(const string& name, boost::function1<void, Variant&> handler)
     {componentInterface.subscribe(name, new Method<boost::function1<void, Variant&>, Variant > (handler));}
void ScienceAPI2Impl::subscribe(const string& name, boost::function2<void, const std::string&, Variant&> handler)
     {componentInterface.subscribe(name, new NamedMethod<boost::function2<void, const std::string &, Variant&>, Variant > (name, handler));}
void ScienceAPI2Impl::publish(const string& name, Variant& data)
     {componentInterface.publish(name, new PackableWrapper< Variant& >(data));}
[endfile]

##################################################
[file ../FortranComponentInterface2/DataTypes.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef FortranDataTypesH
#define FortranDataTypesH

#include <string>
class MessageData;
#define max_array_size 100

[foreach types.type]
// ------ [type.name] ------
struct F[type.name]Type
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   F[field.ctype]Type [field.name][max_array_size];
   [elseif [field.arrayandstring] = T]
   char [field.name][max_array_size*max_array_size];
   [elseif [field.array] = T]
   [field.ctype] [field.name][max_array_size];
   [elseif [field.structure] = T]
   F[field.cpptype] [field.name];
   [elseif [field.cpptype] = std::string]
   char [field.name][max_array_size];
   [else]
   [field.cpptype] [field.name];
   [endif]
   [if [field.array] = T]
   int num_[field.name];
   [endif]
   [endfor]
   };
void pack(MessageData& messageData, const F[type.name]Type& data);
void unpack(MessageData& messageData, const std::string& , F[type.name]Type& data);
unsigned memorySize(const F[type.name]Type& data);
std::string EXPORT DDML(const F[type.name]Type& value);

[endfor]
#endif
[endfile]

##################################################
[file ../FortranComponentInterface2/DataTypes.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <General/platform.h>
#include <ComponentInterface2/BuiltIns.h>
#include <FortranComponentInterface2/DataTypes.h>
#include <ComponentInterface2/StructureConverter.h>
#include <ComponentInterface2/FortranString.h>

[foreach types.type]
// ------ [type.name] ------
void pack(MessageData& messageData, const F[type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayandstring] = T]
   pack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      pack(messageData, FortranString(&data.[field.name][i*max_array_size], max_array_size));
   [elseif [field.array] = T]
   pack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      pack(messageData, data.[field.name][i]);
   [elseif [field.rawcpptype] = std::string]
   pack(messageData, FortranString(data.[field.name], max_array_size));
   [else]
   pack(messageData, data.[field.name]);
   [endif]
   [endfor]
   }
void unpack(MessageData& messageData, const std::string& ddml, F[type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayandstring] = T]
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      {
      FortranString [field.name]String(&data.[field.name][i*max_array_size], max_array_size);
      FortranString [field.name]Alias;
      unpack(messageData, [field.name]Alias);
      [field.name]String = [field.name]Alias;
      }
   [elseif [field.arrayofstructures] = T]
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      unpack(messageData, ddml, data.[field.name][i]);
   [elseif [field.rawcpptype] = std::string]
   std::string [field.name]String;
   unpackField(messageData, ddml, [field.name]String, "[field.name]");
   memset(data.[field.name], ' ', sizeof(data.[field.name]));
   FortranString(data.[field.name], max_array_size) = [field.name]String;
   [elseif [field.array] = T]
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      unpack(messageData, data.[field.name][i]);
   [elseif [field.structure] = T]
   unpack(messageData, ddml, data.[field.name]);
   [else]
   unpackField(messageData, ddml, data.[field.name], "[field.name]");
   [endif]
   [endfor]
   }
unsigned memorySize(const F[type.name]Type& data)
   {
   unsigned size = 0;
   [foreach type.field]
      [if [field.array] = T]
      size += 4;
      for (int i = 0; i != data.num_[field.name]; i++)
         size += memorySize(data.[field.name][i]);
      [elseif [field.cpptype] = std::string]
      size += memorySize(FortranString(data.[field.name], max_array_size));
      [else]
      size += memorySize(data.[field.name]);
      [endif]
   [endfor];
   return size;
   }
std::string EXPORT DDML(const F[type.name]Type& value)
   {
   return [type.cddml];
   }


[endfor]
[endfile]

##################################################
[file ../FortranComponentInterface2/ScienceAPI2.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <General/platform.h>
#include <FortranComponentInterface2/DataTypes.h>
#include <FortranComponentInterface2/FortranComponentWrapper.h>
#include <ComponentInterface2/FortranString.h>
#include <ComponentInterface2/CMPComponentInterface.h>
#include "FortranTemplates.h"

extern FortranComponentWrapper* currentWrapper;

// ------ NullType ------
typedef void (STDCALL FNullTypeFunction)();
extern "C" void EXPORT STDCALL SubscribeNullType(const char* EventName,
                                                 FNullTypeFunction* F,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().subscribe(FortranString(EventName, EventNameLength).toString(),
                                                  new FortranNullMethod<FNullTypeFunction > (currentWrapper, F));
   }

extern "C" void EXPORT STDCALL PublishNull(const char* EventName, unsigned EventNameLength)
   {
   currentWrapper->componentInterface().publish(FortranString(EventName, EventNameLength).toString(), NULL);
   }

[foreach types.type]
// ------ [type.name] ------
typedef  void (STDCALL F[type.name]TypeFunction)(F[type.name]Type* Data);
extern "C" void EXPORT STDCALL Subscribe[type.name]Type(const char* EventName,
                                                 F[type.name]TypeFunction* F,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().subscribe(FortranString(EventName, EventNameLength).toString(),
                                                  new FortranMethod<F[type.name]TypeFunction, F[type.name]Type > (currentWrapper, F));
   }
extern "C" void EXPORT STDCALL Publish[type.name]Type(const char* EventName,
                                                 F[type.name]Type* Data,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().publish(FortranString(EventName, EventNameLength).toString(),
                                                new PackableWrapper2< F[type.name]Type >(*Data));
   }
[endfor]
[endfile]

##################################################
[file ../FortranInfrastructure/ScienceAPI2.f90]

! ------------------------------------------------------------------
! NB: Autogenerated. Do not modify manually.
! ------------------------------------------------------------------

module ScienceAPI2
   implicit none

   interface
      subroutine WriteLine(Msg)
      ml_external WriteLine
      character (len=*) :: Msg
      end subroutine
      subroutine SetSearchOrder(SectionName)
      ml_external SetSearchOrder
      character (len=*) :: SectionName
      end subroutine

   end interface

   ! Optional / Non optional flag.
   integer, parameter :: NotOptional = 0
   integer, parameter :: IsOptional = 1

   interface ReadParam
      subroutine ReadInteger(Name, Units, OptionalFlag, Value)
      ml_external ReadInteger
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value
      end subroutine
      subroutine ReadReal(Name, Units, OptionalFlag, Value)
      ml_external ReadReal
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value
      end subroutine
      subroutine ReadDouble(Name, Units, OptionalFlag, Value)
      ml_external ReadDouble
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value
      end subroutine
      subroutine ReadString(Name, Units, OptionalFlag, Value)
      ml_external ReadString
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value
      end subroutine
      subroutine ReadIntegerArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadIntegerArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      integer           :: Lower
      integer           :: Upper
      end subroutine
      subroutine ReadRealArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadRealArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      real              :: Lower
      real              :: Upper
      end subroutine
      subroutine ReadDoubleArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadDoubleArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      double precision  :: Lower
      double precision  :: Upper
      end subroutine
      subroutine ReadStringArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues)
      ml_external ReadStringArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      end subroutine
   end interface

   interface Get
      function GetInteger(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetInteger
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value
      integer           :: Lower
      integer           :: Upper
      logical           :: GetInteger
      end function
      function GetReal(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetReal
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value
      real              :: Lower
      real              :: Upper
      logical           :: GetReal
      end function
      function GetDouble(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetDouble
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value
      double precision  :: Lower
      double precision  :: Upper
      logical           :: GetDouble
      end function
      function GetString(Name, Units, OptionalFlag, Value)
      ml_external GetString
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value
      logical           :: GetString
      end function
      function GetIntegerArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetIntegerArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      integer           :: Lower
      integer           :: Upper
      logical           :: GetIntegerArray
      end function
      function GetRealArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetRealArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      real              :: Lower
      real              :: Upper
      logical           :: GetRealArray
      end function
      function GetDoubleArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetDoubleArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      double precision  :: Lower
      double precision  :: Upper
      logical           :: GetDoubleArray
      end function
      function GetStringArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues)
      ml_external GetStringArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      logical           :: GetStringArray
      end function
   end interface

   interface Set
      subroutine SetInteger(Name, Units, Value)
      ml_external SetInteger
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: Value
      end subroutine
      subroutine SetReal(Name, Units, Value)
      ml_external SetReal
      character (len=*) :: Name
      character (len=*) :: Units
      real              :: Value
      end subroutine
      subroutine SetDouble(Name, Units, Value)
      ml_external SetDouble
      character (len=*) :: Name
      character (len=*) :: Units
      double precision  :: Value
      end subroutine
      subroutine SetString(Name, Units, Value)
      ml_external SetString
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Value
      end subroutine
      subroutine SetIntegerArray(Name, Units, Value, NumValues)
      ml_external SetIntegerArray
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetRealArray(Name, Units, Value, NumValues)
      ml_external SetRealArray
      character (len=*) :: Name
      character (len=*) :: Units
      real              :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetDoubleArray(Name, Units, Value, NumValues)
      ml_external SetDoubleArray
      character (len=*) :: Name
      character (len=*) :: Units
      double precision  :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetStringArray(Name, Units, Value, NumValues)
      ml_external SetStringArray
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Value(*)
      integer           :: NumValues
      end subroutine
   end interface

   interface Expose
      subroutine ExposeInteger(Name, Units, Description, Writable, Data)
      ml_external ExposeInteger
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      integer           :: Data
      end subroutine
      subroutine ExposeReal(Name, Units, Description, Writable, Data)
      ml_external ExposeReal
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      real           :: Data
      end subroutine
      subroutine ExposeDouble(Name, Units, Description, Writable, Data)
      ml_external ExposeDouble
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      double precision  :: Data
      end subroutine
      subroutine ExposeString(Name, Units, Description, Writable, Data)
      ml_external ExposeString
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      character (len=*) :: Data
      end subroutine
      subroutine ExposeIntegerArray(Name, Units, Description, Writable, Data)
      ml_external ExposeIntegerArray
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      integer           :: Data(*)
      end subroutine
      subroutine ExposeRealArray(Name, Units, Description, Writable, Data)
      ml_external ExposeRealArray
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      real              :: Data(*)
      end subroutine
      subroutine ExposeDoubleArray(Name, Units, Description, Writable, Data)
      ml_external ExposeDoubleArray
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      double precision  :: Data(*)
      end subroutine
      subroutine ExposeStringArray(Name, Units, Description, Writable, Data)
      ml_external ExposeStringArray
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      character (len=*) :: Data(*)
      end subroutine
   end interface

   interface
      subroutine SubscribeNullType(name, proc)
      ml_external SubscribeNullType
      character (len=*), intent(in) :: name
      external :: proc
      end subroutine SubscribeNullType

      [foreach types.type]
      ! ------ [type.name] ------
      subroutine Subscribe[type.name]Type(Name, F)
      Use DataTypes
      ml_external Subscribe[type.name]Type
      character (len=*), intent(in) :: Name
      external :: F
      end subroutine

      [endfor]
   end interface

   interface Publish
      [foreach types.type]
      ! ------ [type.name] ------
      subroutine Publish[type.name]Type(Name, Data)
      Use DataTypes
      ml_external Publish[type.name]Type
      character (len=*), intent(in) :: Name
      type([type.name]Type) :: Data
      end subroutine

      [endfor]
   end interface
end module ScienceAPI2

[endfile]
