##################################################
[file ../ComponentInterface2/DataTypes.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef DataTypesH
#define DataTypesH
#include <General/platform.h>
#include <string>
#include <vector>
#include <stdexcept>

class MessageData;

   //------ Null ------
   struct Null
      {
      int i;
      };

   void EXPORT pack(MessageData& messageData, const Null& data);
   void EXPORT unpack(MessageData& messageData, Null& data);
   void EXPORT unpack(MessageData& messageData, Null& data, const std::string& sourceDDML);
   unsigned EXPORT memorySize(const Null& data);
   std::string EXPORT DDML(const Null& data);

[foreach types.type]
   //------ [type.name] ------
   struct [type.name]Type
      {
      [foreach type.field]
      [field.cpptype] [field.name];
      [endfor]
      };

   void EXPORT pack(MessageData& messageData, const [type.name]Type& data);
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data);
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data, const std::string& sourceDDML);
   unsigned EXPORT memorySize(const [type.name]Type& data);
   std::string EXPORT DDML(const [type.name]Type& data);
   inline void Convert(bool , [type.name]Type&) {throw std::runtime_error("Cannot convert from a scalar to a structure");};
   inline void Convert(int , [type.name]Type&)  {throw std::runtime_error("Cannot convert from a scalar to a structure");};
   inline void Convert(const std::string& , [type.name]Type&)  {throw std::runtime_error("Cannot convert from a scalar to a structure");};
   inline void Convert(float , [type.name]Type&) {throw std::runtime_error("Cannot convert from a scalar to a structure");};
   inline void Convert(double , [type.name]Type&) {throw std::runtime_error("Cannot convert from a scalar to a structure");};
   inline void Convert(std::string&, [type.name]Type&) {throw std::runtime_error("Cannot convert from a scalar to a structure");};

[endfor]

#endif
[endfile]
##################################################
[file ../ComponentInterface2/DataTypes.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include "DataTypes.h"
#include "Interfaces.h"
#include "BuiltIns.h"
#include "StructureConverter.h"

   //------ Null ------
   void EXPORT pack(MessageData& messageData, const Null& data) { }
   void EXPORT unpack(MessageData& messageData, Null& data) { }
   void EXPORT unpack(MessageData& messageData, Null& data, const std::string& sourceDDML) { }
   unsigned EXPORT memorySize(const Null& data) {return 0;}
   std::string EXPORT DDML(const Null& data) {return "<type/>";}


[foreach types.type]
   //------ [type.name] ------

   void EXPORT pack(MessageData& messageData, const [type.name]Type& data)
      {
      [foreach type.field]
      pack(messageData, data.[field.name]);
      [endfor]
      }
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data)
      {
      [foreach type.field]
      unpack(messageData, data.[field.name]);
      [endfor]
      }
   void EXPORT unpack(MessageData& messageData, [type.name]Type& data, const std::string& sourceDDML)
      {
      [foreach type.field]
      [if [field.arrayandstring] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.arrayofstructures] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.rawcpptype] = std::string]
      unpackField(messageData, sourceDDML, data.[field.name], "[field.name]");
      [elseif [field.array] = T]
      unpack(messageData, data.[field.name]);
      [elseif [field.structure] = T]
      unpack(messageData, data.[field.name], sourceDDML);
      [else]
      unpackField(messageData, sourceDDML, data.[field.name], "[field.name]");
      [endif]
      [endfor]
      }
   unsigned EXPORT memorySize(const [type.name]Type& data)
      {
      return 0
       [foreach type.field]              + ::memorySize(data.[field.name])
       [endfor]              ;
      }
   std::string EXPORT DDML(const [type.name]Type& data)     { return [type.cddml]; }

[endfor]
[endfile]

##################################################
[file ../ComponentInterface2/ScienceAPI2.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include "ScienceAPI2.h"

ScienceAPI2::ScienceAPI2() {} ;
ScienceAPI2::~ScienceAPI2() {} ;

[endfile]
##################################################
[file ../ComponentInterface2/ScienceAPI2.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef ScienceAPI2H
#define ScienceAPI2H
#include <General/platform.h>
#include <string>
#include <vector>
#include <map>
#include <functional>
#include <ComponentInterface2/DataTypes.h>
#include <ComponentInterface2/Variant.h>

// ------------------------------------------------------------------
// Interface for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

struct QueryMatch
   {
   std::string name;
   std::string ddml;
   };


class EXPORT ScienceAPI2
   {
   public:
      ScienceAPI2();
      virtual ~ScienceAPI2();

      virtual void write(const std::string& msg) = 0;
      virtual std::string name(void) = 0;
      virtual std::string FQName(void) = 0;
      virtual std::string getExecutableFileName(void) = 0;
      virtual const std::string getInitData(void) = 0;
      virtual void notifyFutureEvent(const std::string& name) = 0;

      // -----------------------------------------------------------------------
      // Return a list of all variables or components (fully qualified)
      // that match the specified pattern.
      // e.g. * will return a list of all components.
      //      wheat.* will return a list of all variables for the wheat module
      //      *.lai will return a list of all lai variables for all modules.
      // -----------------------------------------------------------------------
      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;
      virtual void queryVariable(const std::string& pattern, std::vector<QueryMatch>& matches) = 0;

      // Methods for doing "search orders" when reading parameters:
      virtual void setSearchOrder(const std::vector<std::string> &)=0;
      virtual void getSearchOrder(std::vector<std::string> &)=0;

      // Methods for reading raw strings
      virtual bool readFiltered(const std::string& filterName, std::vector<std::string> &values) = 0;
      virtual bool readAll(std::vector<std::string>& names, std::vector<std::string> &values) = 0;
      virtual bool readScripts(std::map<std::string, std::string> &scripts) = 0;

      // null
      #define nullFunction(address) std::function<void()>(std::bind(address, this))
      #define namedNullFunction(name, address) std::function<void(const std::string &)>(std::bind(address, this, _1))
      virtual void subscribe(const std::string& name, std::function<void()> handler) = 0;
      virtual void subscribe(const std::string& name, std::function<void(const std::string &)> handler) = 0;
      virtual void publish(const std::string& name) = 0;

      [foreach types.builtin]
      // [builtin.cpptype]
      #define [builtin.name]Function(address) std::function<void([builtin.cpptype]&) >(std::bind(address, this, _1))
      #define [builtin.name]Function2(name, address) std::function<void(const std::string &, [builtin.cpptype]&) >(std::bind(address, this, _1, _2))
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data) = 0;
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]) = 0;
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data) = 0;
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, std::function<void([builtin.cpptype]&)> fn) = 0;
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, std::function<void([builtin.cpptype]&)> getter,
                                  std::function<void([builtin.cpptype]&)> setter) = 0;
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                  std::function<void(const std::string &, [builtin.cpptype]&)> fn) = 0;
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                  std::function<void(const std::string &, [builtin.cpptype]&)> getter,
                                  std::function<void(const std::string &, [builtin.cpptype]&)> setter) = 0;

      virtual void subscribe(const std::string& name, std::function<void([builtin.cpptype]&)> handler) = 0;
      virtual void publish(const std::string& name, [builtin.cpptype]& data) = 0;

      [endfor]
      [foreach types.type]
      // [type.name]
      virtual bool get(const std::string& name, bool optional, [type.name]Type& data) = 0;
      virtual void set(const std::string& name, [type.name]Type& data) = 0;
      virtual void expose(const std::string& name, const std::string &description, bool writeable, [type.name]Type& data) = 0;
      #define [type.name]Function(address) std::function<void([type.name]Type&) >(std::bind(address, this, _1))
      virtual void expose(const std::string& name, const std::string &description, std::function<void([type.name]Type&)> getter, std::function<void([type.name]Type&)> setter) = 0;
      virtual void subscribe(const std::string& name, std::function<void([type.name]Type&)> handler) = 0;
      virtual void publish(const std::string& name, [type.name]Type& data) = 0;

      [endfor]

      #define VariantFunction(address) std::function<void(Variant&) >(std::bind(address, this, _1))
      virtual void subscribe(const std::string& name, std::function<void(Variant&)> handler) = 0;

      #define VariantFunction2(name, address) std::function<void(const std::string &, Variant&) >(std::bind(address, this, _1, _2))
      virtual void subscribe(const std::string& name, std::function<void(const std::string &, Variant&)> handler) = 0;

      virtual void publish(const std::string& name, Variant& data) = 0;
   };
#endif
[endfile]

##################################################
[file ../ComponentInterface2/ScienceAPI2Impl.h]
#ifndef ScienceAPI2ImplH
#define ScienceAPI2ImplH
#include <General/platform.h>
#include <ComponentInterface2/ScienceAPI2.h>

class CMPComponentInterface;

// ------------------------------------------------------------------
// CMP Implementation for interacting with simulation
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
class EXPORT ScienceAPI2Impl : public ScienceAPI2
   {
   private:
      CMPComponentInterface& componentInterface;
   public:
      ScienceAPI2Impl(CMPComponentInterface& componentinterface);
      virtual ~ScienceAPI2Impl();

      virtual void write(const std::string& msg);
      virtual std::string name(void);
      virtual std::string FQName(void);
      virtual std::string getExecutableFileName(void);
      virtual const std::string getInitData(void);


      virtual void setSearchOrder(const std::vector<std::string> &list);
      virtual void getSearchOrder(std::vector<std::string> &list);

      virtual void query(const std::string& pattern, std::vector<QueryMatch>& matches);
      virtual void queryVariable(const std::string& pattern, std::vector<QueryMatch>& matches);

      // Methods for reading raw strings
      virtual bool readFiltered(const std::string& filterName, std::vector<std::string> &values);
      virtual bool readAll(std::vector<std::string>& names, std::vector<std::string> &values);
      virtual bool readScripts(std::map<std::string, std::string> &scripts);

      virtual void notifyFutureEvent(const std::string& name);

      // null
      virtual void subscribe(const std::string& name, std::function<void()> handler);
      virtual void subscribe(const std::string& name, std::function<void(const std::string &)> handler);
      virtual void publish(const std::string& name);

      [foreach types.builtin]
      // [builtin.cpptype]
[if [builtin.boundable] = T]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
[if [builtin.boundable] = T]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data);
[endif]
      virtual bool get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif]);
      virtual void set(const std::string& name, const std::string& units, [builtin.cpptype]& data);
      virtual void expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description, std::function<void([builtin.cpptype]&)> method);
      virtual void exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                  std::function<void([builtin.cpptype]&)> getter,
                                  std::function<void([builtin.cpptype]&)> setter);
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                   std::function<void(const std::string&, [builtin.cpptype]&)> method);
      virtual void exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                   std::function<void(const std::string&, [builtin.cpptype]&)> getter,
                                   std::function<void(const std::string&, [builtin.cpptype]&)> setter);
      virtual void subscribe(const std::string& name, std::function<void([builtin.cpptype]&)> handler);
      virtual void publish(const std::string& name, [builtin.cpptype]& data);

      [endfor]
      [foreach types.type]
      virtual bool get(const std::string& name,  bool optional, [type.name]Type& data);
      virtual void set(const std::string& name, [type.name]Type& data);
      virtual void expose(const std::string& name, const std::string &description, bool writeable, [type.name]Type& data);
      virtual void expose(const std::string& name, const std::string &description, std::function<void([type.name]Type&)> getter, std::function<void([type.name]Type&)> setter);
      virtual void subscribe(const std::string& name, std::function<void([type.name]Type&)> handler);
      virtual void publish(const std::string& name, [type.name]Type& data);

      [endfor]
      void subscribe(const std::string& name, std::function<void(Variant&)> handler);
      void subscribe(const std::string& name, std::function<void(const std::string &, Variant&)> handler);
      void publish(const std::string& name, Variant& data);
   };
#endif
[endfile]


##################################################
[file ../ComponentInterface2/ScienceAPI2Impl.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------


#include <ComponentInterface2/ScienceAPI2Impl.h>
#include <ComponentInterface2/CMPData.h>
#include <ComponentInterface2/CMPComponentInterface.h>

using namespace std;
ScienceAPI2Impl::ScienceAPI2Impl(CMPComponentInterface& componentinterface)
   : componentInterface(componentinterface)  {}

ScienceAPI2Impl::~ScienceAPI2Impl() {}

string ScienceAPI2Impl::name(void)
   {return componentInterface.getName();}
string ScienceAPI2Impl::FQName(void)
   {return componentInterface.getFQName();}
string ScienceAPI2Impl::getExecutableFileName(void)
   {return componentInterface.getExecutableFileName();}
const std::string ScienceAPI2Impl::getInitData(void)
   {return componentInterface.getInitData();}
void ScienceAPI2Impl::write(const string& msg)
   {
   componentInterface.write(msg);
   }

void ScienceAPI2Impl::query(const string& pattern, vector<QueryMatch>& matches)
   {
   componentInterface.query(pattern, matches);
   }
void ScienceAPI2Impl::queryVariable(const string& pattern, vector<QueryMatch>& matches)
   {
   componentInterface.queryVariable(pattern, matches);
   }

void ScienceAPI2Impl::setSearchOrder(const std::vector<string> &list) {componentInterface.setSearchOrder(list);};
void ScienceAPI2Impl::getSearchOrder(std::vector<string> &list) {componentInterface.getSearchOrder(list);};

bool ScienceAPI2Impl::readFiltered(const string& filterName, vector<string> &values)
   {return componentInterface.readFiltered(filterName, values);}
bool ScienceAPI2Impl::readAll(std::vector<std::string>& names, std::vector<std::string> &values)
   {return componentInterface.readAll(names, values);}
bool ScienceAPI2Impl::readScripts(std::map<std::string, std::string> &scripts)
   {return componentInterface.readScripts(scripts);}

void ScienceAPI2Impl::notifyFutureEvent(const std::string& name)
   {
   return componentInterface.notifyFutureEvent(name);
   }

// null
void ScienceAPI2Impl::subscribe(const std::string& name, std::function<void()> handler)
   {componentInterface.subscribe(name, new NullMethod(handler));}
void ScienceAPI2Impl::subscribe(const std::string& name, std::function<void(const std::string &)> handler)
   {componentInterface.subscribe(name, new NamedNullMethod(name, handler));}
void ScienceAPI2Impl::publish(const std::string& name)
   {
   Null dummy;
   componentInterface.publish(name, new PackableWrapper<Null>(dummy));
   }

[foreach types.builtin]
// [builtin.cpptype]
[if [builtin.boundable] = T]
bool ScienceAPI2Impl::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   Convertable* temp = new CMPBuiltIn<[builtin.cpptype]& >(data);
   bool ok = componentInterface.read(name, temp, optional);
   delete temp;
   return ok;
   }
[endif]
bool ScienceAPI2Impl::read(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   Convertable* temp = new CMPBuiltInBounded<[builtin.cpptype]&, [builtin.ctype] >(name, data, lower, upper);
   bool ok = componentInterface.read(name, temp, optional);
   [else]
   Convertable* temp = new CMPBuiltIn<[builtin.cpptype]& >(data);
   bool ok = componentInterface.read(name, temp, optional);
   [endif]
   delete temp;
   return ok;
   }
[if [builtin.boundable] = T]
bool ScienceAPI2Impl::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data)
   {
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype]& >(data));
   }
[endif]
bool ScienceAPI2Impl::get(const std::string& name, const std::string& units, bool optional, [builtin.cpptype]& data[if [builtin.boundable] = T], [builtin.ctype] lower, [builtin.ctype] upper[endif])
   {
   [if [builtin.boundable] = T]
   return componentInterface.get(name, units, optional, new CMPBuiltInBounded<[builtin.cpptype]&, [builtin.ctype] >(name, data, lower, upper));
   [else]
   return componentInterface.get(name, units, optional, new CMPBuiltIn<[builtin.cpptype]& >(data));
   [endif]
   }

void ScienceAPI2Impl::set(const std::string& name, const std::string& units, [builtin.cpptype]& data)
   {componentInterface.set(name, units, new CMPBuiltIn<[builtin.cpptype]& >(data));}
void ScienceAPI2Impl::expose(const std::string& name, const std::string& units, const std::string& description, bool writable, [builtin.cpptype]& variable)
   {componentInterface.expose(name, units, description, writable, new CMPBuiltIn<[builtin.cpptype]& >(variable));}
void ScienceAPI2Impl::exposeFunction(const std::string& name, const std::string& units, const std::string& description, std::function<void([builtin.cpptype]&)> fn)
   {componentInterface.expose(name, units, description, false, new Method<std::function<void([builtin.cpptype]&)>, [builtin.cpptype] >(fn));}
void ScienceAPI2Impl::exposeFunction(const std::string& name, const std::string& units, const std::string& description,
                                   std::function<void([builtin.cpptype]&)> getter,
                                   std::function<void([builtin.cpptype]&)> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new DualMethod<std::function<void([builtin.cpptype]&)>, [builtin.cpptype] > (getter, setter));
   }
void ScienceAPI2Impl::exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                     std::function<void(const std::string &, [builtin.cpptype]&)> fn)
   {
   componentInterface.expose(name, units, description, false,
                             new NamedMethod<std::function<void(const std::string &, [builtin.cpptype]&)>, [builtin.cpptype] >(name, fn));
   }
void ScienceAPI2Impl::exposeFunction2(const std::string& name, const std::string& units, const std::string& description,
                                     std::function<void(const std::string&, [builtin.cpptype]&)> getter,
                                     std::function<void(const std::string&, [builtin.cpptype]&)> setter)
   {
   componentInterface.expose(name, units, description, true,
                             new NamedDualMethod<std::function<void(const std::string&, [builtin.cpptype]&)>, [builtin.cpptype] > (name, getter, setter));
   }

void ScienceAPI2Impl::subscribe(const std::string& name, std::function<void([builtin.cpptype]&)> handler)
   {componentInterface.subscribe(name, new Method<std::function<void([builtin.cpptype]&)>, [builtin.cpptype] > (handler));}
void ScienceAPI2Impl::publish(const std::string& name, [builtin.cpptype]& data)
   {componentInterface.publish(name, new CMPBuiltIn<[builtin.cpptype]& >(data));}

[endfor]
[foreach types.type]
bool ScienceAPI2Impl::get(const std::string& name, bool optional, [type.name]Type& data)
   {std::string units = ""; return componentInterface.get(name, units, optional, new PackableWrapper<[type.name]Type& >(data));}
void ScienceAPI2Impl::set(const std::string& name, [type.name]Type& data)
   {std::string units = ""; componentInterface.set(name, units, new PackableWrapper<[type.name]Type& >(data));}
void ScienceAPI2Impl::expose(const std::string& name, const std::string& description, bool writable, [type.name]Type & variable)
   {componentInterface.expose(name, "", description, writable, new PackableWrapper<[type.name]Type& >(variable));}
void ScienceAPI2Impl::expose(const std::string& name, const std::string& description, std::function<void([type.name]Type&)> getter, std::function<void([type.name]Type&)> setter)
   {componentInterface.expose(name, "", description, 1,
                              new DualMethod<std::function<void([type.name]Type&)>, [type.name]Type > (getter, setter));}
void ScienceAPI2Impl::subscribe(const std::string& name, std::function<void([type.name]Type&)> handler)
     {componentInterface.subscribe(name, new MethodWithStructureConverter<std::function<void([type.name]Type&)>, [type.name]Type > (handler));}
void ScienceAPI2Impl::publish(const std::string& name, [type.name]Type& data)
     {componentInterface.publish(name, new PackableWrapper< [type.name]Type& >(data));}

[endfor]

void ScienceAPI2Impl::subscribe(const string& name, std::function<void(Variant&)> handler)
     {componentInterface.subscribe(name, new Method<std::function<void(Variant&)>, Variant > (handler));}
void ScienceAPI2Impl::subscribe(const string& name, std::function<void(const std::string&, Variant&)> handler)
     {componentInterface.subscribe(name, new NamedMethod<std::function<void(const std::string &, Variant&)>, Variant > (name, handler));}
void ScienceAPI2Impl::publish(const string& name, Variant& data)
     {componentInterface.publish(name, new PackableWrapper< Variant& >(data));}
[endfile]

##################################################
[file ../FortranComponentInterface2/DataTypes.h]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#ifndef FortranDataTypesH
#define FortranDataTypesH

#include <string>
class MessageData;
#define max_array_size 100

[foreach types.type]
// ------ [type.name] ------
struct F[type.name]Type
   {
   [foreach type.field]
   [if [field.arrayofstructures] = T]
   F[field.ctype]Type [field.name][max_array_size];
   [elseif [field.arrayandstring] = T]
   char [field.name][max_array_size*max_array_size];
   [elseif [field.array] = T]
   [field.ctype] [field.name][max_array_size];
   [elseif [field.structure] = T]
   F[field.cpptype] [field.name];
   [elseif [field.cpptype] = std::string]
   char [field.name][max_array_size];
   [else]
   [field.cpptype] [field.name];
   [endif]
   [if [field.array] = T]
   int num_[field.name];
   [endif]
   [endfor]
   };
void pack(MessageData& messageData, const F[type.name]Type& data);
void unpack(MessageData& messageData, const std::string& , F[type.name]Type& data);
unsigned memorySize(const F[type.name]Type& data);
std::string EXPORT DDML(const F[type.name]Type& value);

[endfor]
#endif
[endfile]

##################################################
[file ../FortranComponentInterface2/DataTypes.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <General/platform.h>
#include <ComponentInterface2/BuiltIns.h>
#include <FortranComponentInterface2/DataTypes.h>
#include <ComponentInterface2/StructureConverter.h>
#include <ComponentInterface2/FortranString.h>

[foreach types.type]
// ------ [type.name] ------
void pack(MessageData& messageData, const F[type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayandstring] = T]
   pack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      pack(messageData, FortranString(&data.[field.name][i*max_array_size], max_array_size));
   [elseif [field.array] = T]
   pack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      pack(messageData, data.[field.name][i]);
   [elseif [field.rawcpptype] = std::string]
   pack(messageData, FortranString(data.[field.name], max_array_size));
   [else]
   pack(messageData, data.[field.name]);
   [endif]
   [endfor]
   }
void unpack(MessageData& messageData, const std::string& ddml, F[type.name]Type& data)
   {
   [foreach type.field]
   [if [field.arrayandstring] = T]
   memset(data.[field.name], ' ', sizeof(data.[field.name]));
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      {
      std::string [field.name]Alias;
      unpack(messageData, [field.name]Alias);
      FortranString [field.name]String(&data.[field.name][i*max_array_size], max_array_size);
      [field.name]String = [field.name]Alias;
      }
   [elseif [field.arrayofstructures] = T]
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      unpack(messageData, ddml, data.[field.name][i]);
   [elseif [field.rawcpptype] = std::string]
   std::string [field.name]String;
   unpackField(messageData, ddml, [field.name]String, "[field.name]");
   memset(data.[field.name], ' ', sizeof(data.[field.name]));
   FortranString(data.[field.name], max_array_size) = [field.name]String;
   [elseif [field.array] = T]
   unpack(messageData, data.num_[field.name]);
   for (int i = 0; i != data.num_[field.name]; i++)
      unpack(messageData, data.[field.name][i]);
   [elseif [field.structure] = T]
   unpack(messageData, ddml, data.[field.name]);
   [else]
   unpackField(messageData, ddml, data.[field.name], "[field.name]");
   [endif]
   [endfor]
   }
unsigned memorySize(const F[type.name]Type& data)
   {
   unsigned size = 0;
   [foreach type.field]
      [if [field.arrayandstring] = T]
      size += 4;
      for (int i = 0; i != data.num_[field.name]; i++)
         size += memorySize(FortranString(&data.[field.name][i*max_array_size], max_array_size));
      [elseif [field.array] = T]
      size += 4;
      for (int i = 0; i != data.num_[field.name]; i++)
         size += memorySize(data.[field.name][i]);
      [elseif [field.cpptype] = std::string]
      size += memorySize(FortranString(data.[field.name], max_array_size));
      [else]
      size += memorySize(data.[field.name]);
      [endif]
   [endfor]
   return size;
   }
std::string EXPORT DDML(const F[type.name]Type& value)
   {
   return [type.cddml];
   }

[endfor]
[endfile]

##################################################
[file ../FortranComponentInterface2/ScienceAPI2.cpp]

// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------

#include <General/platform.h>
#include <FortranComponentInterface2/DataTypes.h>
#include <FortranComponentInterface2/FortranComponentWrapper.h>
#include <ComponentInterface2/FortranString.h>
#include <ComponentInterface2/CMPComponentInterface.h>
#include <ComponentInterface2/CMPComponentInterface.h>
#include "FortranTemplates.h"

extern FortranComponentWrapper* currentWrapper;

// ------ NullType ------
typedef void (STDCALL FNullTypeFunction)();
extern "C" void EXPORT STDCALL SubscribeNullType(const char* EventName,
                                                 FNullTypeFunction* F,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().subscribe(FortranString(EventName, EventNameLength).toString(),
                                                  new FortranNullMethod<FNullTypeFunction > (currentWrapper, F));
   }

extern "C" void EXPORT STDCALL PublishNullType(const char* EventName, unsigned EventNameLength)
   {
   currentWrapper->componentInterface().publish(FortranString(EventName, EventNameLength).toString(), NULL);
   }

[foreach types.type]
// ------ [type.name] ------
typedef  void (STDCALL F[type.name]TypeFunction)(F[type.name]Type* Data);
extern "C" void EXPORT STDCALL Set[type.name]Type(const char* variableName,
                                                  F[type.name]Type* Data,
                                                  unsigned variableNameLength)
   {
   string units = "";
   currentWrapper->componentInterface().set(FortranString(variableName, variableNameLength).toString(), units, new PackableWrapper2< F[type.name]Type & >(*Data));
   }
extern "C" void EXPORT STDCALL Get[type.name]Type(const char* variableName,
                                                  bool optional,
                                                  F[type.name]Type* Data,
                                                  unsigned variableNameLength)
   {
   string units = "";
   currentWrapper->componentInterface().get(FortranString(variableName, variableNameLength).toString(), units, optional, new PackableWrapper2< F[type.name]Type & >(*Data));
   }
extern "C" void EXPORT STDCALL Expose[type.name]Type(const char* variableName,
                                                     const char* description,
                                                     bool writeable,
                                                     F[type.name]Type* Data,
                                                     unsigned variableNameLength,
                                                     unsigned descriptionLength)
   {
   currentWrapper->componentInterface().expose(FortranString(variableName, variableNameLength).toString(),
                                               "",
                                               FortranString(description, descriptionLength).toString(),
                                               writeable,
                                               new PackableWrapper2< F[type.name]Type & >(*Data));
   }
extern "C" void EXPORT STDCALL Expose[type.name]TypeFunction(const char* variableName,
                                                     const char* description,
                                                     F[type.name]TypeFunction* Getter,
                                                     F[type.name]TypeFunction* Setter,
                                                     unsigned variableNameLength,
                                                     unsigned descriptionLength)
   {
   currentWrapper->componentInterface().expose(FortranString(variableName, variableNameLength).toString(),
                                               "",
                                               FortranString(description, descriptionLength).toString(),
                                               Setter != NULL,
                                               new FortranDualMethod<F[type.name]TypeFunction, F[type.name]Type > (currentWrapper, Getter, Setter));

   }

extern "C" void EXPORT STDCALL Subscribe[type.name]Type(const char* EventName,
                                                 F[type.name]TypeFunction* F,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().subscribe(FortranString(EventName, EventNameLength).toString(),
                                                  new FortranMethod<F[type.name]TypeFunction, F[type.name]Type > (currentWrapper, F));
   }
extern "C" void EXPORT STDCALL Publish[type.name]Type(const char* EventName,
                                                 F[type.name]Type* Data,
                                                 unsigned EventNameLength)
   {
   currentWrapper->componentInterface().publish(FortranString(EventName, EventNameLength).toString(),
                                                new PackableWrapper2< F[type.name]Type & >(*Data));
   }
[endfor]
[endfile]

##################################################
[file ../FortranInfrastructure/ScienceAPI2.f90]

! ------------------------------------------------------------------
! NB: Autogenerated. Do not modify manually.
! ------------------------------------------------------------------

module ScienceAPI2
   use DataTypes
   implicit none

   interface
      subroutine WriteLine(Msg)
      ml_external WriteLine
!STDCALL(WriteLine)
      character (len=*) :: Msg
      end subroutine

      subroutine SetSearchOrder(SectionName)
      ml_external SetSearchOrder
!STDCALL(SetSearchOrder)
      character (len=*) :: SectionName
      end subroutine

      subroutine AppendSearchOrder(SectionName)
      ml_external AppendSearchOrder
!STDCALL(AppendSearchOrder)
      character (len=*) :: SectionName
      end subroutine

      subroutine GetComponentName(name)
      ml_external GetComponentName
!STDCALL(GetComponentName)
      character (len=*) :: name
      end subroutine

   end interface

   ! Optional / Non optional flag.
   integer, parameter :: NotOptional = 0
   integer, parameter :: IsOptional = 1

   interface ReadParam
      function ReadInteger(Name, Units, OptionalFlag, Value, lower, upper)
      ml_external ReadInteger
!STDCALL(ReadInteger)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value
      integer           :: lower, upper
	  integer           :: ReadInteger
      end function
      function ReadReal(Name, Units, OptionalFlag, Value, lower, upper)
      ml_external ReadReal
!STDCALL(ReadReal)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value
      real              :: lower, upper
	  integer           :: ReadReal
      end function
      function ReadDouble(Name, Units, OptionalFlag, Value, lower, upper)
      ml_external ReadDouble
!STDCALL(ReadDouble)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value
      double precision  :: lower, upper
	  integer           :: ReadDouble
      end function
      function ReadString(Name, Units, OptionalFlag, Value)
      ml_external ReadString
!STDCALL(ReadString)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value
	  integer           :: ReadString
      end function
      function ReadIntegerArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadIntegerArray
!STDCALL(ReadIntegerArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      integer           :: Lower
      integer           :: Upper
	  integer           :: ReadIntegerArray
      end function
      function ReadRealArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadRealArray
!STDCALL(ReadRealArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      real              :: Lower
      real              :: Upper
	  integer           :: ReadRealArray
      end function
      function ReadDoubleArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external ReadDoubleArray
!STDCALL(ReadDoubleArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      double precision  :: Lower
      double precision  :: Upper
	  integer           :: ReadDoubleArray
      end function
      function ReadStringArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues)
      ml_external ReadStringArray
!STDCALL(ReadStringArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
	  integer           :: ReadStringArray
      end function
   end interface

   interface Get
      function GetInteger(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetInteger
!STDCALL(GetInteger)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value
      integer           :: Lower
      integer           :: Upper
      logical           :: GetInteger
      end function
      function GetReal(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetReal
!STDCALL(GetReal)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value
      real              :: Lower
      real              :: Upper
      logical           :: GetReal
      end function
      function GetDouble(Name, Units, OptionalFlag, Value, Lower, Upper)
      ml_external GetDouble
!STDCALL(GetDouble)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value
      double precision  :: Lower
      double precision  :: Upper
      logical           :: GetDouble
      end function
      function GetString(Name, Units, OptionalFlag, Value)
      ml_external GetString
!STDCALL(GetString)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value
      logical           :: GetString
      end function
      function GetIntegerArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetIntegerArray
!STDCALL(GetIntegerArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      integer           :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      integer           :: Lower
      integer           :: Upper
      logical           :: GetIntegerArray
      end function
      function GetRealArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetRealArray
!STDCALL(GetRealArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      real              :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      real              :: Lower
      real              :: Upper
      logical           :: GetRealArray
      end function
      function GetDoubleArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues, Lower, Upper)
      ml_external GetDoubleArray
!STDCALL(GetDoubleArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      double precision  :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      double precision  :: Lower
      double precision  :: Upper
      logical           :: GetDoubleArray
      end function
      function GetStringArray(Name, Units, OptionalFlag, Value, NumValues, MaxValues)
      ml_external GetStringArray
!STDCALL(GetStringArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: OptionalFlag
      character (len=*) :: Value(*)
      integer           :: NumValues
      integer           :: MaxValues
      logical           :: GetStringArray
      end function
    [foreach types.type]
      ! ------ [type.name] ------
      function Get[type.name]Type(Name, OptionalFlag, F)
      IMPORT :: [type.name]Type
      ml_external Get[type.name]Type
!STDCALL(Get[type.name]Type)
      character (len=*), intent(in) :: Name
      integer       :: OptionalFlag
      type([type.name]Type) :: F
      logical       :: Get[type.name]Type
      end function
     [endfor]
   end interface

   interface Set
      subroutine SetInteger(Name, Units, Value)
      ml_external SetInteger
!STDCALL(SetInteger)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: Value
      end subroutine
      subroutine SetReal(Name, Units, Value)
      ml_external SetReal
!STDCALL(SetReal)
      character (len=*) :: Name
      character (len=*) :: Units
      real              :: Value
      end subroutine
      subroutine SetDouble(Name, Units, Value)
      ml_external SetDouble
!STDCALL(SetDouble)
      character (len=*) :: Name
      character (len=*) :: Units
      double precision  :: Value
      end subroutine
      subroutine SetString(Name, Units, Value)
      ml_external SetString
!STDCALL(SetString)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Value
      end subroutine
      subroutine SetIntegerArray(Name, Units, Value, NumValues)
      ml_external SetIntegerArray
!STDCALL(SetIntegerArray)
      character (len=*) :: Name
      character (len=*) :: Units
      integer           :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetRealArray(Name, Units, Value, NumValues)
      ml_external SetRealArray
!STDCALL(SetRealArray)
      character (len=*) :: Name
      character (len=*) :: Units
      real              :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetDoubleArray(Name, Units, Value, NumValues)
      ml_external SetDoubleArray
!STDCALL(SetDoubleArray)
      character (len=*) :: Name
      character (len=*) :: Units
      double precision  :: Value(*)
      integer           :: NumValues
      end subroutine
      subroutine SetStringArray(Name, Units, Value, NumValues)
      ml_external SetStringArray
!STDCALL(SetStringArray)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Value(*)
      integer           :: NumValues
      end subroutine
   [foreach types.type]
      ! ------ [type.name] ------
      subroutine Set[type.name]Type(Name, F)
      IMPORT :: [type.name]Type
      ml_external Set[type.name]Type
!STDCALL(Set[type.name]Type)
      character (len=*), intent(in) :: Name
      type([type.name]Type) :: F
      end subroutine
   [endfor]
   end interface

   interface Expose
      subroutine ExposeInteger(Name, Units, Description, Writable, Data)
      ml_external ExposeInteger
!STDCALL(ExposeInteger)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      integer           :: Data
      end subroutine
      subroutine ExposeReal(Name, Units, Description, Writable, Data)
      ml_external ExposeReal
!STDCALL(ExposeReal)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      real           :: Data
      end subroutine
      subroutine ExposeDouble(Name, Units, Description, Writable, Data)
      ml_external ExposeDouble
!STDCALL(ExposeDouble)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      double precision  :: Data
      end subroutine
      subroutine ExposeString(Name, Units, Description, Writable, Data)
      ml_external ExposeString
!STDCALL(ExposeString)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      character (len=*) :: Data
      end subroutine
      subroutine ExposeIntegerArray(Name, Units, Description, Writable, Data, numvalues, maxvalues)
      ml_external ExposeIntegerArray
!STDCALL(ExposeIntegerArray)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      integer           :: Data(*)
      integer           :: numvalues
      integer           :: maxvalues
      end subroutine
      subroutine ExposeRealArray(Name, Units, Description, Writable, Data, numvalues, maxvalues)
      ml_external ExposeRealArray
!STDCALL(ExposeRealArray)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      real              :: Data(*)
      integer           :: numvalues
      integer           :: maxvalues
      end subroutine
      subroutine ExposeDoubleArray(Name, Units, Description, Writable, Data, numvalues, maxvalues)
      ml_external ExposeDoubleArray
!STDCALL(ExposeDoubleArray)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      double precision  :: Data(*)
      integer           :: numvalues
      integer           :: maxvalues
      end subroutine
      subroutine ExposeStringArray(Name, Units, Description, Writable, Data, numvalues, maxvalues)
      ml_external ExposeStringArray
!STDCALL(ExposeStringArray)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      logical           :: Writable
      character (len=*) :: Data(*)
      integer           :: numvalues
      integer           :: maxvalues
      end subroutine
!!! Ugh. This is a blight. Assumes it will call a fortran function with 2 arguments - variable name and value.
      subroutine ExposeRealFunction(Name, Units, Description, Getter, Setter)
!STDCALL(ExposeRealFunction)
      character (len=*) :: Name
      character (len=*) :: Units
      character (len=*) :: Description
      external :: Getter
      external :: Setter
      end subroutine
!!! Ugh. This is a blight ^^^^^^^^^
    [foreach types.type]
      ! ------ [type.name] ------
      subroutine Expose[type.name]Type(Name, Desc, WriteableFlag, F)
      IMPORT :: [type.name]Type
!STDCALL(Expose[type.name]Type)
      character (len=*), intent(in) :: Name
      character (len=*), intent(in) :: Desc
      logical       :: WriteableFlag
      type([type.name]Type) :: F
!      external :: F
      end subroutine
     [endfor]
   end interface

   interface
    [foreach types.type]
      ! ------ [type.name] ------
      subroutine Expose[type.name]TypeFunction(Name, Desc, Getter, Setter)
!STDCALL(Expose[type.name]TypeFunction)
      character (len=*), intent(in) :: Name
      character (len=*), intent(in) :: Desc
      external :: Getter, Setter
      end subroutine
     [endfor]
   end interface

   interface
      subroutine SubscribeNullType(name, proc)
      ml_external SubscribeNullType
!STDCALL(SubscribeNullType)
      character (len=*), intent(in) :: name
      external :: proc
      end subroutine SubscribeNullType

      [foreach types.type]
      ! ------ [type.name] ------
      subroutine Subscribe[type.name]Type(Name, F)
!      IMPORT :: [type.name]Type
!STDCALL(Subscribe[type.name]Type)
      character (len=*), intent(in) :: Name
!      type([type.name]Type) :: F
      external :: F
      end subroutine

      [endfor]
   end interface

   interface Publish
      subroutine PublishNullType(name)
      ml_external PublishNullType
!STDCALL(PublishNullType)
      character (len=*), intent(in) :: name
      end subroutine PublishNullType
      [foreach types.type]
      ! ------ [type.name] ------
      subroutine Publish[type.name]Type(Name, Data)
      IMPORT :: [type.name]Type
      ml_external Publish[type.name]Type
!STDCALL(Publish[type.name]Type)
      character (len=*), intent(in) :: Name
      type([type.name]Type) :: Data
      end subroutine

      [endfor]
   end interface
end module ScienceAPI2

[endfile]

[file ../FortranComponentInterface2/FortranComponentInterface2.def]
; ------------------------------------------------------------------
; NB: Autogenerated. Do not modify manually.
; ------------------------------------------------------------------
LIBRARY FortranComponentInterface2.dll
EXPORTS
  AppendSearchOrder = _AppendSearchOrder@8
  _appendsearchorder = _AppendSearchOrder@8
  _appendsearchorder@8 = _AppendSearchOrder@8
  ExposeDouble = _ExposeDouble@32
  _exposedouble = _ExposeDouble@32
  _exposedouble@32 = _ExposeDouble@32
  ExposeDoubleArray = _ExposeDoubleArray@40
  _exposedoublearray = _ExposeDoubleArray@40
  _exposedoublearray@40 = _ExposeDoubleArray@40
  ExposeInteger = _ExposeInteger@32
  _exposeinteger = _ExposeInteger@32
  _exposeinteger@32 = _ExposeInteger@32
  ExposeIntegerArray = _ExposeIntegerArray@40
  _exposeintegerarray = _ExposeIntegerArray@40
  _exposeintegerarray@40 = _ExposeIntegerArray@40
  ExposeReal = _ExposeReal@32
  _exposereal = _ExposeReal@32
  _exposereal@32 = _ExposeReal@32
  ExposeRealFunction = _ExposeRealFunction@32
  _exposerealfunction = _ExposeRealFunction@32
  _exposerealfunction@32 = _ExposeRealFunction@32
  ExposeRealArray = _ExposeRealArray@40
  _exposerealarray = _ExposeRealArray@40
  _exposerealarray@40 = _ExposeRealArray@40
  ExposeString = _ExposeString@36
  _exposestring = _ExposeString@36
  _exposestring@36 = _ExposeString@36
  ExposeStringArray = _ExposeStringArray@44
  _exposestringarray = _ExposeStringArray@44
  _exposestringarray@44 = _ExposeStringArray@44
  Fatal = _Fatal@8
  _fatal = _Fatal@8
  _fatal@8 = _Fatal@8
  GetComponentName = _GetComponentName@8
  _getcomponentname = _GetComponentName@8
  _getcomponentname@8 = _GetComponentName@8
  GetDouble = _GetDouble@32
  _getdouble = _GetDouble@32
  _getdouble@32 = _GetDouble@32
  GetDoubleArray = _GetDoubleArray@40
  _getdoublearray = _GetDoubleArray@40
  _getdoublearray@40 = _GetDoubleArray@40
  GetInteger = _GetInteger@32
  _getinteger = _GetInteger@32
  _getinteger@32 = _GetInteger@32
  GetIntegerArray = _GetIntegerArray@40
  _getintegerarray = _GetIntegerArray@40
  _getintegerarray@40 = _GetIntegerArray@40
  GetReal = _GetReal@32
  _getreal = _GetReal@32
  _getreal@32 = _GetReal@32
  GetRealArray = _GetRealArray@40
  _getrealarray = _GetRealArray@40
  _getrealarray@40 = _GetRealArray@40
  GetString = _GetString@28
  _getstring = _GetString@28
  _getstring@28 = _GetString@28
  GetStringArray = _GetStringArray@36
  _getstringarray = _GetStringArray@36
  _getstringarray@36 = _GetStringArray@36
  ReadDouble = _ReadDouble@32
  _readdouble = _ReadDouble@32
  _readdouble@32 = _ReadDouble@32
  ReadDoubleArray = _ReadDoubleArray@40
  _readdoublearray = _ReadDoubleArray@40
  _readdoublearray@40 = _ReadDoubleArray@40
  ReadInteger = _ReadInteger@32
  _readinteger = _ReadInteger@32
  _readinteger@32 = _ReadInteger@32
  ReadIntegerArray = _ReadIntegerArray@40
  _readintegerarray = _ReadIntegerArray@40
  _readintegerarray@40 = _ReadIntegerArray@40
  ReadReal = _ReadReal@32
  _readreal = _ReadReal@32
  _readreal@32 = _ReadReal@32
  ReadRealArray = _ReadRealArray@40
  _readrealarray = _ReadRealArray@40
  _readrealarray@40 = _ReadRealArray@40
  ReadString = _ReadString@28
  _readstring = _ReadString@28
  _readstring@28 = _ReadString@28
  ReadStringArray = _ReadStringArray@36
  _readstringarray = _ReadStringArray@36
  _readstringarray@36 = _ReadStringArray@36
  SetDouble = _SetDouble@20
  _setdouble = _SetDouble@20
  _setdouble@20 = _SetDouble@20
  SetDoubleArray = _SetDoubleArray@24
  _setdoublearray = _SetDoubleArray@24
  _setdoublearray@24 = _SetDoubleArray@24
  SetInteger = _SetInteger@20
  _setinteger = _SetInteger@20
  _setinteger@20 = _SetInteger@20
  SetIntegerArray = _SetIntegerArray@24
  _setintegerarray = _SetIntegerArray@24
  _setintegerarray@24 = _SetIntegerArray@24
  SetReal = _SetReal@20
  _setreal = _SetReal@20
  _setreal@20 = _SetReal@20
  SetRealArray = _SetRealArray@24
  _setrealarray = _SetRealArray@24
  _setrealarray@24 = _SetRealArray@24
  SetSearchOrder = _SetSearchOrder@8
  _setsearchorder = _SetSearchOrder@8
  _setsearchorder@8 = _SetSearchOrder@8
  SetString = _SetString@24
  _setstring = _SetString@24
  _setstring@24 = _SetString@24
  SetStringArray = _SetStringArray@28
  _setstringarray = _SetStringArray@28
  _setstringarray@28 = _SetStringArray@28
  Warning = _Warning@8
  _warning = _Warning@8
  _warning@8 = _Warning@8
  WriteLine = _WriteLine@8
  _writeline = _WriteLine@8
  _writeline@8 = _WriteLine@8
  createInstance = _createInstance@24
  _createinstance = _createInstance@24
  _createinstance@24 = _createInstance@24
  deleteInstance = _deleteInstance@4
  _deleteinstance = _deleteInstance@4
  _deleteinstance@4 = _deleteInstance@4
  fci2_getDescriptionInternal = _FCI2_getDescriptionInternal@8
  _fci2_getdescriptioninternal = _FCI2_getDescriptionInternal@8
  _fci2_getdescriptioninternal@8 = _FCI2_getDescriptionInternal@8
  fci2_getDescriptionLengthInternal = _FCI2_getDescriptionLengthInternal@8
  _fci2_getdescriptionlengthinternal = _FCI2_getDescriptionLengthInternal@8
  _fci2_getdescriptionlengthinternal@8 = _FCI2_getDescriptionLengthInternal@8
  messageToLogic = _messageToLogic@12
  _messagetologic = _messageToLogic@12
  _messagetologic@12 = _messageToLogic@12
  PublishNullType = _PublishNullType@8
  _publishnulltype = _PublishNullType@8
  _publishnulltype@8 = _PublishNullType@8
  publish_null = _publish_null@8
  _publish_null = _publish_null@8
  string_to_float = _string_to_float@12
  _string_to_float = _string_to_float@12
  SubscribeNullType = _SubscribeNullType@12
  _subscribenulltype = _SubscribeNullType@12
  _subscribenulltype@12 = _SubscribeNullType@12
[foreach types.type]
  Get[type.name]Type = _Get[type.name]Type@16
[tolower]  _get[type.name]type[endtolower] = _Get[type.name]Type@16
[tolower]  _get[type.name]type[endtolower]@12 = _Get[type.name]Type@16
  Set[type.name]Type = _Set[type.name]Type@12
[tolower]  _set[type.name]type[endtolower] = _Set[type.name]Type@12
[tolower]  _set[type.name]type[endtolower]@12 = _Set[type.name]Type@12
  Expose[type.name]Type = _Expose[type.name]Type@24
[tolower]  _expose[type.name]type[endtolower] = _Expose[type.name]Type@24
[tolower]  _expose[type.name]type[endtolower]@24 = _Expose[type.name]Type@24
  Expose[type.name]TypeFunction = _Expose[type.name]TypeFunction@24
[tolower]  _expose[type.name]typefunction[endtolower] = _Expose[type.name]TypeFunction@24
[tolower]  _expose[type.name]typefunction[endtolower]@24 = _Expose[type.name]TypeFunction@24
  Publish[type.name]Type = _Publish[type.name]Type@12
[tolower]  _publish[type.name]type[endtolower] = _Publish[type.name]Type@12
[tolower]  _publish[type.name]type[endtolower]@12 = _Publish[type.name]Type@12
  Subscribe[type.name]Type = _Subscribe[type.name]Type@12
[tolower]  _subscribe[type.name]type[endtolower] = _Subscribe[type.name]Type@12
[tolower]  _subscribe[type.name]type[endtolower]@12 = _Subscribe[type.name]Type@12
[endfor]
[endfile]

[file ../FortranComponentInterface2/FortranComponentInterface2.ldscript]
/* ------------------------------------------------------------------ */
/* NB: Autogenerated. Do not modify manually.                         */
/* ------------------------------------------------------------------ */
SECTIONS {
  .data :
  {
    appendsearchorder = AppendSearchOrder;
    exposedouble = ExposeDouble;
    exposedoublearray = ExposeDoubleArray;
    exposeinteger = ExposeInteger;
    exposeintegerarray = ExposeIntegerArray;
    exposereal = ExposeReal;
    exposerealarray = ExposeRealArray;
    exposerealfunction = ExposeRealFunction;
    exposestring = ExposeString;
    exposestringarray = ExposeStringArray;
    fatal = Fatal;
    getcomponentname = GetComponentName;
    getdouble = GetDouble;
    getdoublearray = GetDoubleArray;
    getinteger = GetInteger;
    getintegerarray = GetIntegerArray;
    getreal = GetReal;
    getrealarray = GetRealArray;
    getstring = GetString;
    getstringarray = GetStringArray;
    readdouble = ReadDouble;
    readdoublearray = ReadDoubleArray;
    readinteger = ReadInteger;
    readintegerarray = ReadIntegerArray;
    readreal = ReadReal;
    readrealarray = ReadRealArray;
    readstring = ReadString;
    readstringarray = ReadStringArray;
    setdouble = SetDouble;
    setdoublearray = SetDoubleArray;
    setinteger = SetInteger;
    setintegerarray = SetIntegerArray;
    setreal = SetReal;
    setrealarray = SetRealArray;
    setsearchorder = SetSearchOrder;
    setstring = SetString;
    setstringarray = SetStringArray;
    warning = Warning;
    writeline = WriteLine;
    createinstance = createInstance;
    deleteinstance = deleteInstance;
    fci2_getdescriptioninternal = FCI2_getDescriptionInternal;
    fci2_getdescriptionlengthinternal = FCI2_getDescriptionLengthInternal;
    messagetologic = messageToLogic;
    publishnulltype = PublishNullType;
    subscribenulltype = SubscribeNullType;
[foreach types.type]
[tolower]    get[type.name]type[endtolower] = Get[type.name]Type;
[tolower]    set[type.name]type[endtolower] = Set[type.name]Type;
[tolower]    expose[type.name]type[endtolower] = Expose[type.name]Type;
[tolower]    expose[type.name]typefunction[endtolower] = Expose[type.name]TypeFunction;
[tolower]    publish[type.name]type[endtolower] = Publish[type.name]Type;
[tolower]    subscribe[type.name]type[endtolower] = Subscribe[type.name]Type;
[endfor]
  }
}
[endfile]

