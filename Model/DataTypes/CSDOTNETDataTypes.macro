##################################################
[file DOTNETDataTypes.cs]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
using System;
using System.Collections;
using System.Runtime.InteropServices;
using CMPServices;

    //------ ApsimType ------
    public interface ApsimType
    {
        void pack(out byte[] messageData);
        void pack(TTypedValue dest);
        void unpack(byte[] messageData);
        void unpack(TTypedValue src);
        uint memorySize();
        String DDML();
    }
    /// <summary>
    /// This class is used for generic access to pack and
    /// unpack methods for all descendant types.
    /// </summary>
    public class TypeInterpreter : ApsimType
    {
        protected TDDMLValue DDMLValue;
        public TypeInterpreter()
        {
            DDMLValue = new TDDMLValue(DDML(), "");
        }
        public TypeInterpreter(ref TDDMLValue template)
        {
            // Parsing the DDML can be a relatively slow operation, so as an optimisation
            // we do the XML parsing only the first time we create an object of a given
            // type, and save it as a template. New TDDMLValue objects are then created
            // via the copy constructor, which is relatively fast.
            if (template == null)
                template = new TDDMLValue(DDML(), "");
            DDMLValue = new TDDMLValue(template);
        }
        public virtual String DDML() { return "<type/>"; }
        public virtual void setValue(TTypedValue typedValue)
        {
            unpack(typedValue);
        }
        public virtual void pack(out byte[] messageData)
        {
            messageData = new byte[DDMLValue.sizeBytes()];
            DDMLValue.getData(ref messageData);
        }
        public virtual void pack(TTypedValue typedValue)
        {
            byte[] data = new byte[0];
            pack(out data);
            typedValue.setData(data, data.Length, 0);
        }
        public virtual void packArrayOfStructures(TypeInterpreter[] items, TTypedValue typedValue)
        {
            typedValue.setElementCount((uint)items.Length);
            for (uint i = 1; i <= items.Length; i++)
            {
                items[i - 1].pack(typedValue.item(i));
            }
        }
        public virtual void unpack(TTypedValue src)
        {
            DDMLValue.setValue(src);
        }
        public virtual void unpack(byte[] messageData)
        {
            DDMLValue.setData(messageData, messageData.Length, 0);
        }
        public virtual void unpackStructure(TTypedValue typedValue)
        {
            byte[] b = new byte[typedValue.sizeBytes()];
            typedValue.getData(ref b);
            unpack(b);
        }
        public virtual uint memorySize()
        {
            return DDMLValue.sizeBytes();
        }
    }
    //------ NullType ------
    public class NullType : ApsimType
    {
        public void pack(out byte[] MessageData)
        {
            MessageData = null;
        }
        public void pack(TTypedValue dest)
        {
            dest = null; 
        }
        public void unpack(TTypedValue src)
        {
        }
        public void unpack(byte[] MessageData)
        {
        }
        public uint memorySize()
        {
            return 0;
        }
        public String DDML()
        {
            return "<type/>";
        }
    }

[foreach types.builtin]
   //------ [builtin.name] ------
   public class [builtin.dotnettypename]Type : TypeInterpreter
   {
      public [builtin.cstype] Value;
      public [builtin.dotnettypename]Type() {}
      public [builtin.dotnettypename]Type([builtin.cstype] value)
      {
         Value = value;
      }

      public override void pack(out byte[] messageData)
      {
         DDMLValue.setValue(Value);
         messageData = new byte[DDMLValue.sizeBytes()];
         DDMLValue.getData(ref messageData);
      }
      public override void unpack(TTypedValue src)
      {
         Value = src.as[builtin.cstypename]();
      }
      public override void unpack(byte[] messageData)
      {
         DDMLValue.setData(messageData, messageData.Length, 0);
         unpack(DDMLValue);
      }
      public override String DDML()
      {
         return [builtin.csddml];
      }
   }
   public delegate void [builtin.dotnettypename]Delegate([builtin.dotnettypename]Type Data);
[endfor]

[foreach types.type]

      //------ [type.name] ------
      public class [type.name]Type : TypeInterpreter
      {
         private static TDDMLValue typeTemplate;
         public [type.name]Type() : base (ref typeTemplate) {}
         [foreach type.field]
         public [field.cstype] [field.name][if [field.cstype] = String] = ""[endif];
         [endfor]
         public override void pack(out byte[] messageData)
         {
            [if [type.array] = T]
            packArrayOfStructures([foreach type.field][field.name][endfor], DDMLValue);
            [else]
            uint i = 0;
            [foreach type.field]
            [if [field.arrayofstructures] = T]
            packArrayOfStructures([field.name], DDMLValue.item(++i));
            [elseif [field.structure] = T]
            [field.name].pack(DDMLValue.item(++i));
            [else]
            DDMLValue.item(++i).setValue([field.name]);
            [endif]
            [endfor]
            [endif]
            messageData = new byte[DDMLValue.sizeBytes()];
            DDMLValue.getData(ref messageData);
         }
         public override void unpack(TTypedValue src)
         {
            [if [type.array] = T]
            [foreach type.field]
            [field.name] = new [field.cstypebase][src.count()];
            for (uint i = 1; i <= [field.name].Length; i++ )
            {
                [field.name][i-1] = new [field.cstypebase]();
                [field.name][i-1].unpackStructure(src.item(i));
            }
            [endfor]
            [else]
            uint idx = 0;
            [foreach type.field]
            [if [field.arrayofstructures] = T]
            TTypedValue [field.name]_member = src.item(++idx);
            [field.name] = new [field.cstypebase][[field.name]_member.count()];
            for (uint i = 1; i <= [field.name].Length; i++ )
            {
                [field.name][i-1] = new [field.cstypebase]();
                [field.name][i-1].unpackStructure([field.name]_member.item(i));
            }
            [elseif [field.structure] = T]
            [field.name] = new [field.cstypebase]();
            [field.name].unpackStructure(src.item(++idx));
            [else]
            [field.name] = src.item(++idx).as[field.cstypename]();
            [endif]
            [endfor]
            [endif]
         }
         public override void unpack(byte[] messageData)
         {
            DDMLValue.setData(messageData, messageData.Length, 0);
            unpack(DDMLValue);
         }
         public override String DDML()
         {
            return [type.csddml];
         }
      }
      public delegate void [type.name]Delegate([type.name]Type Data);
[endfor]
[endfile]
