##################################################
[file DOTNETDataTypes.cs]
// ------------------------------------------------------------------
// NB: Autogenerated. Do not modify manually.
// ------------------------------------------------------------------
using System;
using System.Collections;
using System.Runtime.InteropServices;
using CMPServices;

    //------ ApsimType ------
    public interface ApsimType
    {
        void pack(out byte[] messageData);
        void unpack(byte[] messageData);
        uint memorySize();
        String DDML();
    }
    /// <summary>
    /// This class is used for generic access to pack and
    /// unpack methods for all descendant types.
    /// </summary>
    public class TypeInterpreter : ApsimType
    {
        protected TDDMLValue DDMLValue;
        public TypeInterpreter()
        {
            DDMLValue = new TDDMLValue(DDML(), "");
        }
        public TypeInterpreter(ref TDDMLValue template)
        {
		    // Parsing the DDML can be a relatively slow operation, so as an optimisation
			// we do the XML parsing only the first time we create an object of a given
			// type, and save it as a template. New TDDMLValue objects are then created 
			// via the copy constructor, which is relatively fast.
            if (template == null)
                template = new TDDMLValue(DDML(), "");
            DDMLValue = new TDDMLValue(template);
        }
        public virtual String DDML() { return "<type/>"; }
		public virtual void setValue(TTypedValue typedValue)
		{
		    DDMLValue.setValue(typedValue);
			byte[] data = new byte[DDMLValue.sizeBytes()];
			DDMLValue.getData(ref data);
			unpack(data);
		}
        public virtual void pack(out byte[] messageData)
        {
            messageData = new byte[DDMLValue.sizeBytes()];
            DDMLValue.getData(ref messageData);
        }
        public virtual void pack(TTypedValue typedValue)
        {
            byte[] data = new byte[0];
            pack(out data);
            typedValue.setData(data, data.Length, 0);
        }
        public virtual void packArrayOfStructures(TypeInterpreter[] items, TTypedValue typedValue)
        {
            typedValue.setElementCount((uint)items.Length);
            for (uint i = 1; i <= items.Length; i++)
            {
                items[i - 1].pack(typedValue.item(i));
            }
        }
        public virtual void unpack(byte[] messageData)
        {
            DDMLValue.setData(messageData, messageData.Length, 0);
        }
        public virtual void unpackStructure(TTypedValue typedValue)
        {
            byte[] b = new byte[typedValue.sizeBytes()];
            typedValue.getData(ref b);
            unpack(b);
        }
        public virtual uint memorySize()
        {
            return DDMLValue.sizeBytes();
        }
    }
    //------ NullType ------
    public class NullType : ApsimType
    {
        public void pack(out byte[] MessageData)
        {
            MessageData = null;
        }
        public void unpack(byte[] MessageData)
        {
        }
        public uint memorySize()
        {
            return 0;
        }
        public String DDML()
        {
            return "<type/>";
        }
    }
     
[foreach types.builtin]
   //------ [builtin.name] ------
   public class [builtin.dotnettypename]Type : TypeInterpreter
      {
      public [builtin.cstype] Value;

      public [builtin.dotnettypename]Type([builtin.cstype] value) 
      {
      Value = value;
      }

      public override void pack(out byte[] messageData)
      {
         DDMLValue.setValue(Value);
         messageData = new byte[DDMLValue.sizeBytes()];
         DDMLValue.getData(ref messageData);
      }
      public override void unpack(byte[] messageData)
      {
         DDMLValue.setData(messageData, messageData.Length, 0);        
         Value = DDMLValue.as[builtin.cstypename]();
      }   
      public override String DDML()
      {
         return [builtin.csddml];
      }
   }
   public delegate void [builtin.dotnettypename]Delegate([builtin.dotnettypename]Type Data);
[endfor]
    
[foreach types.type]

      //------ [type.name] ------
      public class [type.name]Type : TypeInterpreter
      {
	     private static TDDMLValue typeTemplate;
		 public [type.name]Type() : base (ref typeTemplate) {}
         [foreach type.field]
         public [field.cstype] [field.name];
         [endfor]
         public override void pack(out byte[] messageData)
         {
            [foreach type.field]
            [if [field.arrayofstructures] = T]
            packArrayOfStructures([field.name], DDMLValue.member("[field.name]"));
            [elseif [field.structure] = T]
            [field.name].pack(DDMLValue.member("[field.name]"));
            [else]
            DDMLValue.member("[field.name]").setValue([field.name]);
            [endif]
            [endfor]
            messageData = new byte[DDMLValue.sizeBytes()];
            DDMLValue.getData(ref messageData);
         }
         public override void unpack(byte[] messageData)
         {
            DDMLValue.setData(messageData, messageData.Length, 0);        
            [foreach type.field]
            [if [field.arrayofstructures] = T]
            [field.name] = new [field.cstypebase][DDMLValue.member("[field.name]").count()];
            for (uint i = 1; i <= [field.name].Length; i++ )
            {
                [field.name][i-1] = new [field.cstypebase]();
                [field.name][i-1].unpackStructure(DDMLValue.member("[field.name]").item(i));
            }
            [elseif [field.structure] = T]
            [field.name] = new [field.cstypebase]();
            [field.name].unpackStructure(DDMLValue.member("[field.name]"));
            [else]
            [field.name] = DDMLValue.member("[field.name]").as[field.cstypename]();
            [endif]
            [endfor]
         }
         public override String DDML()
         {
            return [type.csddml];
         }
      }
      public delegate void [type.name]Delegate([type.name]Type Data);
[endfor]
[endfile]
